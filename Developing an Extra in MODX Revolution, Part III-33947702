a:5:{s:2:"id";s:8:"33947702";s:4:"info";a:4:{s:6:"Title:";s:48:"Developing an Extra in MODX Revolution, Part III";s:7:"Author:";s:15:"Shaun McCormick";s:16:"Last Changed by:";s:11:"Scott Borys";s:12:"Wiki Markup:";s:63:"[revolution20:Developing an Extra in MODX Revolution, Part III]";}s:6:"parent";s:8:"33947673";s:6:"source";s:35348:"{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

{note}For simple Extras that don&#39;t have a CMP, we could just use [PackMan|addon:PackMan] to package up our Extra. However, we have a CMP, and we want to learn how to do the script. So, here we are.{note}

h2. Setting Up Our Build Directory

This is what our \_build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* \- This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* \- A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* \- This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* \- While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
&lt;?php
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens\!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it\! If you run this via the browser (on mine, [http://localhost/doodles/_build/build.transport.php]) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package\! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call at line 42:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t \-&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* \- Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there.

* *xPDOTransport::PRESERVE_KEYS =&gt; false* \- Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* \- A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* \- This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* \- This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that its unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done\! Our Category is now in the TP. But we need to add the Snippets to it\!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and uncomment it. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* \- This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* \- The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* \- This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* \- Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* \- The default value of the property.
* *lexicon* \- If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable\!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great\! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle at line 67:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* \- This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* \- This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great\!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line at line 80 for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist\! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great\!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package\! First off, let&#39;s add those files.

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver\!), that points to a path of a PHP file (also like a resolver\!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles.

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in\!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX\!

{note}The Doodles Extra in this tutorial can be found on GitHub, here: [https://github.com/splittingred/doodles]
{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}";s:8:"versions";a:15:{i:0;a:3:{s:2:"id";s:8:"33947702";s:3:"ver";s:1:"1";s:4:"code";s:35348:"{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

{note}For simple Extras that don&#39;t have a CMP, we could just use [PackMan|addon:PackMan] to package up our Extra. However, we have a CMP, and we want to learn how to do the script. So, here we are.{note}

h2. Setting Up Our Build Directory

This is what our \_build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* \- This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* \- A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* \- This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* \- While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
&lt;?php
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens\!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it\! If you run this via the browser (on mine, [http://localhost/doodles/_build/build.transport.php]) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package\! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call at line 42:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t \-&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* \- Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there.

* *xPDOTransport::PRESERVE_KEYS =&gt; false* \- Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* \- A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* \- This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* \- This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that its unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done\! Our Category is now in the TP. But we need to add the Snippets to it\!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and uncomment it. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* \- This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* \- The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* \- This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* \- Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* \- The default value of the property.
* *lexicon* \- If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable\!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great\! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle at line 67:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* \- This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* \- This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great\!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line at line 80 for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist\! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great\!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package\! First off, let&#39;s add those files.

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver\!), that points to a path of a PHP file (also like a resolver\!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles.

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in\!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX\!

{note}The Doodles Extra in this tutorial can be found on GitHub, here: [https://github.com/splittingred/doodles]
{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}";}i:1;a:3:{s:2:"id";s:8:"41058449";s:3:"ver";s:1:"1";s:4:"code";s:35360:"{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

{note}For simple Extras that don&#39;t have a CMP, we could just use [PackMan|addon:PackMan] to package up our Extra. However, we have a CMP, and we want to learn how to do the script. So, here we are.{note}

h2. Setting Up Our Build Directory

This is what our \_build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* \- This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* \- A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* \- This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* \- While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
&lt;?php
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens\!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it\! If you run this via the browser (on mine, [http://localhost/doodles/_build/build.transport.php]) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package\! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call at line 42:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t \-&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* \- Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there.

* *xPDOTransport::PRESERVE_KEYS =&gt; false* \- Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* \- A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* \- This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* \- This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that its unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done\! Our Category is now in the TP. But we need to add the Snippets to it\!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and uncomment it. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* \- This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* \- The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* \- This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* \- Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* \- The default value of the property.
* *lexicon* \- If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable\!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great\! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle at line 67:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* \- This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* \- This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great\!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line at line 80 for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist\! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great\!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package\! First off, let&#39;s add those files.

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver\!), that points to a path of a PHP file (also like a resolver\!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles.

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in\!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX\!

{note}The Doodles Extra in this tutorial can be found on GitHub, here: [https://github.com/splittingred/doodles]
{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}";}i:2;a:3:{s:2:"id";s:8:"40763411";s:3:"ver";s:1:"1";s:4:"code";s:35290:"{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

{note}For simple Extras that don&#39;t have a CMP, we could just use [PackMan|addon:PackMan] to package up our Extra. However, we have a CMP, and we want to learn how to do the script. So, here we are.{note}

h2. Setting Up Our Build Directory

This is what our _build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* - This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* - A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* - This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* - While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it! If you run this via the browser (on mine, http://localhost/doodles/_build/build.transport.php) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t -&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* - Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there. 

* *xPDOTransport::PRESERVE_KEYS =&gt; false* - Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* - A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* - This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* - This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that it&#39;s unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done! Our Category is now in the TP. But we need to add the Snippets to it!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and comment it out. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* - This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* - The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* - This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* - Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* - The default value of the property.
* *lexicon* - If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* - This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* - This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package! First off, let&#39;s add those files. 

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver!), that points to a path of a PHP file (also like a resolver!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles. 

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX!

{note}The Doodles Extra in this tutorial can be found on GitHub, here: https://github.com/splittingred/doodles{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
";}i:3;a:3:{s:2:"id";s:8:"33947762";s:3:"ver";s:1:"1";s:4:"code";s:35081:"{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

h2. Setting Up Our Build Directory

This is what our _build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* - This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* - A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* - This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* - While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it! If you run this via the browser (on mine, http://localhost/doodles/_build/build.transport.php) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t -&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* - Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there. 

* *xPDOTransport::PRESERVE_KEYS =&gt; false* - Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* - A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* - This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* - This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that it&#39;s unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done! Our Category is now in the TP. But we need to add the Snippets to it!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and comment it out. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* - This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* - The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* - This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* - Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* - The default value of the property.
* *lexicon* - If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* - This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* - This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package! First off, let&#39;s add those files. 

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver!), that points to a path of a PHP file (also like a resolver!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles. 

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX!

{note}The Doodles Extra in this tutorial can be found on GitHub, here: https://github.com/splittingred/doodles{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
";}i:4;a:3:{s:2:"id";s:8:"33947758";s:3:"ver";s:1:"1";s:4:"code";s:34963:"{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

h2. Setting Up Our Build Directory

This is what our _build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* - This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* - A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* - This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* - While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it! If you run this via the browser (on mine, http://localhost/doodles/_build/build.transport.php) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t -&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* - Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there. 

* *xPDOTransport::PRESERVE_KEYS =&gt; false* - Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* - A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* - This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* - This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that it&#39;s unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done! Our Category is now in the TP. But we need to add the Snippets to it!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and comment it out. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* - This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* - The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* - This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* - Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* - The default value of the property.
* *lexicon* - If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* - This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* - This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package! First off, let&#39;s add those files. 

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver!), that points to a path of a PHP file (also like a resolver!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles. 

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX!

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
";}i:5;a:3:{s:2:"id";s:8:"33947757";s:3:"ver";s:1:"1";s:4:"code";s:35056:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

h2. Setting Up Our Build Directory

This is what our _build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* - This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* - A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* - This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* - While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it! If you run this via the browser (on mine, http://localhost/doodles/_build/build.transport.php) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t -&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* - Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there. 

* *xPDOTransport::PRESERVE_KEYS =&gt; false* - Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* - A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* - This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* - This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that it&#39;s unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done! Our Category is now in the TP. But we need to add the Snippets to it!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and comment it out. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* - This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* - The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* - This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* - Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* - The default value of the property.
* *lexicon* - If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* - This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* - This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. We&#39;ve also got a related object of our Action. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re calling addOne on the menu object to add the Action as a related object to the menu. Note that the fields in each of the fromArray calls are the fields in the DB table for the menu and action, by the way.

So now our Menu and Action are all nicely packaged in.

h2. Adding a Resolver

When someone installs our system, however, they&#39;re going to have 1 big problem - the database table modx_doodles isn&#39;t going to exist! Let&#39;s write a PHP resolver to create it on install. A PHP Resolver is a PHP script that runs after the Vehicle it&#39;s attached to has been installed. We&#39;ll attach this resolver to our Menu vehicle. Right below our $builder-&gt;createVehicle call for the Menu, and before you run putVehicle for that vehicle, add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;resolve.tables.php&#39;,
));
{code}

All that&#39;s passed into this PHP resolver is the &#39;source&#39; field, which points to the PHP script. Let&#39;s create a file at /www/doodles/_build/resolvers/resolve.tables.php, and put this inside:

{code}&lt;?php
if ($object-&gt;xpdo) {
    switch ($options[xPDOTransport::PACKAGE_ACTION]) {
        case xPDOTransport::ACTION_INSTALL:
            $modx =&amp; $object-&gt;xpdo;
            $modelPath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/&#39;;
            $modx-&gt;addPackage(&#39;doodles&#39;,$modelPath);

            $manager = $modx-&gt;getManager();

            $manager-&gt;createObjectContainer(&#39;Doodle&#39;);

            break;
        case xPDOTransport::ACTION_UPGRADE:
            break;
    }
}
return true;{code}

Great. So here we&#39;re doing a few things. Note the initial check for $object-&gt;xpdo. $object is our Menu, since we attached this to the Menu&#39;s vehicle. Then we want to check for the xpdo var on it (which is also MODX). We then run into a switch statement, that checks a mysterious PACKAGE_ACTION const in the $options array. This little switch tells us to only run this code during *new* installs, or ACTION_INSTALL.

Further in the switch, we are assigning $modx as a reference to $object-&gt;xpdo, for easier typing. Then we&#39;ll find our Doodles&#39; model path via our friendly getOption calls, and then run the addPackage call to add our xpdo schema to the database (remember that from Part I?). Finally, we&#39;ll run $modx-&gt;getManager(), which gets an xPDOManager instance, and call $manager-&gt;createObjectContainer(&#39;Doodle&#39;) on it.

This method tells MODX to run the SQL to create the database table for the Doodle class, which is what we want. And at the end of the resolver, we&#39;ll return true so that MODX knows everything went smoothly.

If you build the package, and install it now, it will create our database table. Great!

h2. Adding the Changelog, Readme, License and Setup Options

Let&#39;s get fancy. When installing packages in MODX, often you&#39;ll see a dialog with a license, readme, and changelog. We want that in our package! First off, let&#39;s add those files. 

Create a file in /www/doodles/core/components/doodles/docs/changelog.txt:

{code}Changelog file for Doodles component.

Doodles 1.0
====================================
- Updating text, ready to build
- Added default properties to Doodles snippet in build
- Fixes to doodles class
- Fixed bugs with build, updated readme
- Initial commit{code}

Then create a license file (we&#39;ll let you put the content in) at /www/doodles/core/components/doodles/docs/license.txt.

Finally, create a readme.txt in the docs/ directory:

{code}--------------------
Extra: Doodles
--------------------
Version: 1.0

A simple demo extra for creating robust 3rd-Party Components in MODx Revolution.{code}

Now that we&#39;ve got our docs files, let&#39;s go to the end of our build.transport.php script, right before the $builder-&gt;pack() part, and add these lines:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding package attributes and setup options...&#39;);
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;changelog&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;changelog.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;].&#39;setup.options.php&#39;,
    ),
));{code}

So as you can see here, we have a setPackageAttributes() method, that allows some attributes. They&#39;re pretty self-explanatory - license takes in text for the license (which we grab using file_get_contents), readme takes in text for the readme, and changelog takes in text for the changelog.

The new one is the &#39;setup-options&#39; array. First off, it&#39;s an array with a key of &#39;source&#39; (like a resolver!), that points to a path of a PHP file (also like a resolver!). Let&#39;s create this PHP file, at /www/doodles/_build/setup.options.php:

{code}
&lt;?php
$output = &#39;&#39;;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
        $output = &#39;&lt;h2&gt;Doodles Installer&lt;/h2&gt;
&lt;p&gt;Thanks for installing Doodles! Please review the setup options below before proceeding.&lt;/p&gt;&lt;br /&gt;&#39;;
        break;
    case xPDOTransport::ACTION_UPGRADE:
    case xPDOTransport::ACTION_UNINSTALL:
        break;
}
return $output;{code}

So, this looks familiar to a resolver, eh? That&#39;s because this little bit of code allows us to present &#39;Setup Options&#39; to the user on installation. Right now we&#39;re just going to output a pretty message to tell people thanks for installing Doodles. 

Remember that $options array in our PHP resolver? If we were to put any form elements in this output, they&#39;d be found in that array with the same key. (An input with name of &#39;test&#39; would be in $options[&#39;test&#39;]). That means you could make a resolver that would process the form fields you put in the Setup Options script.

That means that you could have a lot of neat little fields that do pre-installation options. That&#39;s a bit beyond the scope of this tutorial, but now that you know the basics, you can probably figure it out from there. (Also, plenty of existing Extras, such as [Quip|addon:Quip] do this, and you can [view their code|https://github.com/splittingred/Quip] to see how.

h2. Summary

Now you can run your build.transport.php file, and you&#39;ll get a nice little doodles-1.0-beta4.zip file in your MODX install&#39;s core/packages/ directory. You can now either install that by uploading it to a MODX install&#39;s core/packages/ directory (but not the same one you just developed in!), or post it to [modx.com/extras/|http://modx.com/extras/] to be included in the official MODX Provider that hooks into [Package Management]. Pretty neat?

Let&#39;s recap. Over the 3 parts of this tutorial, we:

* Stubbed out the directory structure for our Extra so we could develop externally and even get it on a source control system, such as Git
* Added a custom xPDO model for our custom database table for our Doodles
* Created a dynamic, templatable Snippet that lists our Doodles
* Created a robust, CRUD-based Custom Manager Page to manage our Doodles from
* Wrote a Transport Package (TP) build script to build our package with that installs our files and MODX objects
* Made our TP create the custom DB table on install
* Made our TP display the license/readme/changelog and a nice status message

All in all, I&#39;d say that was pretty successful. Congrats, and we hope you enjoy developing on MODX!

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
";}i:6;a:3:{s:2:"id";s:8:"33947756";s:3:"ver";s:1:"9";s:4:"code";s:27038:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

h2. Setting Up Our Build Directory

This is what our _build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* - This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* - A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* - This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* - While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage(key,version,release){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace(namespace_name,autoincludes,packageNamespace,namespacePath){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it! If you run this via the browser (on mine, http://localhost/doodles/_build/build.transport.php) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t -&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* - Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there. 

* *xPDOTransport::PRESERVE_KEYS =&gt; false* - Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* - A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* - This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* - This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that it&#39;s unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done! Our Category is now in the TP. But we need to add the Snippets to it!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and comment it out. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* - This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}\[\[Doodles? &amp;tpl=`rowTpl`\]\]{quote}

* *desc* - The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* - This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* - Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* - The default value of the property.
* *lexicon* - If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* - This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* - This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re addOne 
return $menu;

h2. Adding a Resolver

h2. Adding the Changelog, Readme, License and Setup Options

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:7;a:3:{s:2:"id";s:8:"33947731";s:3:"ver";s:1:"8";s:4:"code";s:27048:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Overview

In this tutorial, we&#39;re going to be packaging up our Extra that we made in the [past|Developing an Extra in MODX Revolution] [two|Developing an Extra in MODX Revolution, Part II] tutorials into a [Transport Package|Transport Packages] (TP) so that we can install it on any MODX installation, and even submit it to the Extras section on modx.com.

First off, if you&#39;re not sure what a Transport Package is, or what Package Management is, I suggest you read up on [Package Management] and [Transport Packages] first before proceeding.

Our main goals for this part of the tutorial will be getting the Extra in a package: specifically our Snippet; the files in core/components and assets/components; the Action, Menu and Namespace for our CMP; making our Snippet&#39;s default properties i18n supported; and finally, adding a Resolver that creates our custom DB table in the installing user&#39;s database.

h2. Setting Up Our Build Directory

This is what our _build directory will look like when we&#39;re through. We&#39;re already familiar with the build.config.php and build.schema.php files from Part I. For now, let&#39;s just explain a few things about it:

!doodles-build-dir1.png!

* *data* - This is where we&#39;re going to put all of our data-packaging scripts. We&#39;ll get into that shortly.
* *resolvers* - A directory containing our [resolvers|http://rtfm.modx.com/display/revolution20/Transport+Packages#TransportPackages-AResolver] for our Transport Package.
* *build.transport.php* - This is our main build script. Running it will create the Transport Package. We&#39;ll be heavily looking at this file.
* *setup.options.php* - While we won&#39;t use this extensively for our TP, we&#39;ll look at it briefly to show what&#39;s possible with it.

h3. The Build Script

Let&#39;s go ahead and create a file at /www/doodles/_build/build.transport.php, and fill it with this:

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);

/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);

/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

There&#39;s a lot in there. It&#39;s helpful to note that all this is doing so far is packaging in our Namespace, and creating a &quot;doodles-1.0-beta4.zip&quot; transport file. Let&#39;s go deeper to understand a bit more of it.

{code}
$tstart = explode(&#39; &#39;, microtime());
$tstart = $tstart[1] + $tstart[0];
set_time_limit(0);

/* define package names */
define(&#39;PKG_NAME&#39;,&#39;Doodles&#39;);
define(&#39;PKG_NAME_LOWER&#39;,&#39;doodles&#39;);
define(&#39;PKG_VERSION&#39;,&#39;1.0&#39;);
define(&#39;PKG_RELEASE&#39;,&#39;beta4&#39;);{code}
First off, we&#39;re going to get the time started for this build script so we can output at the end how long it took to build it. It&#39;s definitely not necessary code to build the TP, but it&#39;s useful information anyway.

Then we&#39;ll set up some defines we&#39;ll use later to determine our package&#39;s name, version and release. Next:

{code}
/* define build paths */
$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root . &#39;_build/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;chunks&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/chunks/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/lexicon/&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/docs/&#39;,
    &#39;elements&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER.&#39;/elements/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/&#39;.PKG_NAME_LOWER,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/&#39;.PKG_NAME_LOWER,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once $sources[&#39;build&#39;] . &#39;build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;{code}

Okay, here we&#39;re defining a whole bunch of paths on where to find stuff in our directory structure. This will be useful later on in our build script, so we can easily reference locations of files.

{note}Note the source_core and source_assets keys - it&#39;s very important to note that they *do not* have a trailing slash. When we package them in later, this is important.{note}

Finally, we&#39;ll include our build.config.php file and our modx class. Now it&#39;s time to load up the modX object:

{code}$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(PKG_NAME_LOWER,PKG_VERSION,PKG_RELEASE);
$builder-&gt;registerNamespace(PKG_NAME_LOWER,false,true,&#39;{core_path}components/&#39;.PKG_NAME_LOWER.&#39;/&#39;);
{code}

Okay, a bit in here. First off, we&#39;ll instantiate the modX object, and initialize our &#39;mgr&#39; Context. This sets up all the modX environment stuff we&#39;ll need. Next, we&#39;ll tell MODX to be a little more verbose in it&#39;s error reporting during this build script with the $modx-&gt;setLogLevel method - and we&#39;ll tell it to output to the screen as well with the setLogTarget message.

Then we&#39;ll load the &#39;modPackageBuilder&#39; class from the transport/ directory in core/model/modx/ (which is the default since we passed &#39;&#39; into the 3rd parameter of loadClass), which is an assistance class that we&#39;ll use to package up our Extra.

Then we get into 2 interesting methods: createPackage and registerNamespace.

{quote}$modx-&gt;createPackage([key],[version],[release]){quote}

Here&#39;s where the name for our TP gets created. We&#39;ll want to pass the name of our Extra (in lower case with no dots or hyphens!) in the first parameter. Then we&#39;ll want to pass a version and a release number. We chose &#39;1.0&#39; and &#39;beta4&#39; back when we did our defines (remember that?). Now, modTransportPackage has an assistance method to automatically package in our Namespace for us:

{quote}$builder-&gt;registerNamespace([namespace_name],[autoincludes],[packageNamespace],[namespacePath]){quote}

The first parameter is the name of our Namespace (&#39;doodles&#39; for us). The 2nd parameter auto-packages in an array of classes associated with our Namespace (we don&#39;t want this, so we set it to false). The third parameter asks if we want to add the Namespace to the TP (we do, so we set it to true). And finally, the last parameter asks what the path of our Namespace should eventually be.

That last parameter is key - note how we make it resolve to: &#39;\{core_path\}components/doodles/&#39;? The \{core_path\} part is a placeholder that will get replaced by MODX when the Namespace is accessed in their installation. This makes our Package nice and flexible on its paths - we don&#39;t have to explicitly set them, and it becomes more easy to &#39;transport&#39;, so to speak.

And now finally, the last few lines in our script:

{code}
/* zip up package */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packing up transport package zip...&#39;);
$builder-&gt;pack();

$tend= explode(&quot; &quot;, microtime());
$tend= $tend[1] + $tend[0];
$totalTime= sprintf(&quot;%2.4f s&quot;,($tend - $tstart));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\n&lt;br /&gt;Package Built.&lt;br /&gt;\nExecution time: {$totalTime}\n&quot;);
exit ();{code}

The pack() method tells MODX to go ahead and make the Transport Package zip with our built package so far. The rest of the lines after that just display how long it took to do the build. That&#39;s it! If you run this via the browser (on mine, http://localhost/doodles/_build/build.transport.php) you&#39;ll get some debugging info displayed, and then in your MODX&#39;s core/packages/ directory, you&#39;ll find this:

!doodles-zip1.png!

Our Transport Package! Nice and done. However, installing it wont actually do anything. Let&#39;s try and solve that.

h2. Adding in the Data

We&#39;re going to want to package in our Snippet in its own &#39;Doodles&#39; category, to get it to be nice and separated out from other Snippets the user might be using. In our build.transport.php file, add this below our registerNamespace call:

{code}$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,PKG_NAME);

/* add snippets */
//$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
//$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
//if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
//$category-&gt;addMany($snippets);

/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    ),
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

Quite a bit of this is detailed [in this tutorial here|Creating a 3rd Party Component Build Script], but we&#39;ll go over it again here. First off, we create a modCategory object that has the name (category) of &#39;Doodles&#39;. Great. Note how we don&#39;t -&gt;save() on it - we just want the object. Next we have some code to package in the Snippet, but we&#39;ve commented it out for now. Go ahead and ignore it - we&#39;ll come back to it.

Next, we create this really big array of attributes, it seems. A bit more on these - they are attributes for the Vehicle for the Category. What&#39;s a Vehicle? Well, a Vehicle &quot;carries&quot; an Object in the Transport Package. Each object (say, a Snippet, Menu, Category, etc) needs a Vehicle to be carried in the Transport Package. So we&#39;ll create one, but first we want to assign some attributes to it to tell MODX just how this Vehicle should behave when the user installs it.

* *xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;* - Here, we&#39;re telling MODX that the unique key for this Category is the field &#39;category&#39;. Since we are installing this on another machine, the ID of the Category there will most likely be different than our ID on our machine. So MODX needs some way of identifying our &#39;Doodles&#39; category if the User were to decide and uninstall our Doodles Extra. MODX uses this UNIQUE_KEY property to look for a modCategory object with &#39;category&#39; =&gt; &quot;Doodles&quot;, and then removes it there. 

* *xPDOTransport::PRESERVE_KEYS =&gt; false* - Sometimes, however, we want the primary key of our object to be &#39;preserved&#39; - or rather, used when the User installs our package. This is useful for non-auto-incrementing primary keys (PKs), such as Menu items, which we&#39;ll get to later. Our Category doesn&#39;t need its ID preserved, so we&#39;ll set that to false here.

* *xPDOTransport::UPDATE_OBJECT =&gt; true* - A crucial one. This tells MODX that if the Category already exists, update it with our version. If we had set this to false, MODX would just skip this Category if it found it. We don&#39;t want that - say we want to release an update for our Doodles Extra later; we&#39;d want the Category to update.

* *xPDOTransport::RELATED_OBJECTS =&gt; true* - This tells MODX that we have some related objects to our Category we want to package in. (We do. We have a Snippet.) Related objects are important, as this means that they will be &quot;related&quot; to one another on install. Our example is a good one - any Snippets we install, we want to assign to the Category we&#39;re installing.

* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* - This takes in an associative array. Each index in the first depth of it tells MODX what the alias of it is - note we only have one, &quot;Snippets&quot;. That tells MODX to look for any Related Objects in this Category that are Snippets, and then below that defines properties for those Snippets:

{code}&#39;Snippets&#39; =&gt; array(
   xPDOTransport::PRESERVE_KEYS =&gt; false,
   xPDOTransport::UPDATE_OBJECT =&gt; true,
   xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
),{code}

We&#39;re going to tell the package to not preserve the Snippet&#39;s keys (similarly to the Category). Then we want to update it should MODX find it already during installs or upgrades. Finally, we tell MODX that it&#39;s unique key is &#39;name&#39; - MODX will look for a Snippet with the name of &#39;Doodles&#39; (we&#39;ll get to where that&#39;s defined here in a bit) during install, and if it finds it, upgrade it (or remove it during uninstall).

Then we hit this:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);
$builder-&gt;putVehicle($vehicle);{code}

This packages our Category object into a nice little vehicle for us, with the attributes we just defined. And then it adds it to the Transport Package. Done! Our Category is now in the TP. But we need to add the Snippets to it!

h3. Adding the Snippet

Go ahead and create a directory at /www/doodles/_build/data/. Now let&#39;s add a file at /www/doodles/_build/data/transport.snippets.php. Place this in there:

{code}&lt;?php
function getSnippetContent($filename) {
    $o = file_get_contents($filename);
    $o = trim(str_replace(array(&#39;&lt;?php&#39;,&#39;?&gt;&#39;),&#39;&#39;,$o));
    return $o;
}
$snippets = array();

$snippets[1]= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippets[1]-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;name&#39; =&gt; &#39;Doodles&#39;,
    &#39;description&#39; =&gt; &#39;Displays a list of Doodles.&#39;,
    &#39;snippet&#39; =&gt; getSnippetContent($sources[&#39;elements&#39;].&#39;snippets/snippet.doodles.php&#39;),
),&#39;&#39;,true,true);
$properties = include $sources[&#39;data&#39;].&#39;properties/properties.doodles.php&#39;;
$snippets[1]-&gt;setProperties($properties);
unset($properties);

return $snippets;{code}

First off, we&#39;re going to make a little helper method that grabs our snippet we worked on earlier and strips the &lt;?php tags from it. Then, we&#39;ll make a $snippets array - basically an array of all the Snippets we want to package up.

Next, we&#39;ll actually make a new Snippet object. Note, however, we&#39;re *not* saving it - just creating it. Also, we&#39;re going to include some properties on them (more on that in a second). Finally, we return the $snippets array. Remember that part we commented out in our build.transport.php file? This part:

{code}
/* add snippets */
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in snippets...&#39;);
$snippets = include $sources[&#39;data&#39;].&#39;transport.snippets.php&#39;;
if (empty($snippets)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in snippets.&#39;);
$category-&gt;addMany($snippets);{code}

Go ahead and comment it out. Now our Snippets are loaded into the Category Vehicle. We&#39;re done there. Let&#39;s add those properties that we mentioned earlier.

h3. Adding in Snippet Properties

Create a file at /www/doodles/_build/data/properties/properties.doodles.php. Put this in it:

{code}&lt;?php
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;tpl&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.tpl_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;rowTpl&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;sort&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.sort_desc&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;name&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dir&#39;,
        &#39;desc&#39; =&gt; &#39;prop_doodles.dir_desc&#39;,
        &#39;type&#39; =&gt; &#39;list&#39;,
        &#39;options&#39; =&gt; array(
            array(&#39;text&#39; =&gt; &#39;prop_doodles.ascending&#39;,&#39;value&#39; =&gt; &#39;ASC&#39;),
            array(&#39;text&#39; =&gt; &#39;prop_doodles.descending&#39;,&#39;value&#39; =&gt; &#39;DESC&#39;),
        ),
        &#39;value&#39; =&gt; &#39;DESC&#39;,
        &#39;lexicon&#39; =&gt; &#39;doodles:properties&#39;,
    ),
);
return $properties;{code}

These are PHP representations of the default Properties for our Snippet. Let&#39;s look at the keys they have:

* *name* - This is the name, or key, of the property. We&#39;ve got tpl, sort, and dir. For example, in our tpl property, we&#39;re telling it to default to &#39;rowTpl&#39;. When someone wants to use the property, it would look like this in their snippet call:

{quote}[[Doodles? &amp;tpl=`rowTpl`]]{quote}

* *desc* - The description of our property. This can either be the actual description, or, if the &#39;lexicon&#39; attribute on this property is set, a Lexicon key. We&#39;ve got it as a Lexicon key, because we&#39;re going to i18n our properties.
* *type* - This is the &#39;xtype&#39; of the property. Currently, the 4 available values are &quot;textfield&quot;, &quot;textarea&quot;, &quot;combo-boolean&quot; (Yes/No) and &quot;list&quot;. We&#39;ve got two textfields here, and a list type.
* *options* - Only used by the &#39;list&#39; type, this is an array of arrays, which each contain an option in the list. Each option has two values - &#39;text&#39; and &#39;value&#39;, where value is the actual value stored when it&#39;s selected, and &#39;text&#39; is the text displayed for the value. &#39;text&#39; can be a Lexicon key, if wanted.
* *value* - The default value of the property.
* *lexicon* - If wanted, properties can be i18n-compatible. Just specify the Lexicon Topic here, and MODX will handle the rest.

Okay, so we&#39;ve got our properties. But as you can see, we&#39;ve referenced a &#39;doodles:properties&#39; Lexicon Topic. Let&#39;s go ahead and create that, in the file /www/doodles/core/components/doodles/lexicon/en/properties.inc.php:

{code}&lt;?php
$_lang[&#39;prop_doodles.ascending&#39;] = &#39;Ascending&#39;;
$_lang[&#39;prop_doodles.descending&#39;] = &#39;Descending&#39;;
$_lang[&#39;prop_doodles.dir_desc&#39;] = &#39;The direction to sort by.&#39;;
$_lang[&#39;prop_doodles.sort_desc&#39;] = &#39;The field to sort by.&#39;;
$_lang[&#39;prop_doodles.tpl_desc&#39;] = &#39;The chunk for displaying each row.&#39;;{code}

As you can see here, it&#39;s a similar format to our default topic. Also, the keys in each string here match with the &#39;desc&#39; attribute in each of our properties. This means that our Snippet&#39;s properties will be translated when they are shown - useful for making Extras that are translatable!

If you run the build script now, your Category, Snippet and its Properties will be packaged in. Great! But we&#39;ve missed something - the actual files aren&#39;t getting copied. Let&#39;s remedy that.

h3. Adding the File Resolvers

So we want to add /www/doodles/core/components/doodles/ and /www/doodles/assets/components/doodles/ to our Transport Package. We&#39;re going to add those files to our Category Vehicle, via what are called File Resolvers. These scripts run after the package has been installed, and can be used to copy files into the User&#39;s MODX installation.

So, in build.transport.php, right after this, where we add the Category Vehicle:

{code}$vehicle = $builder-&gt;createVehicle($category,$attr);{code}

add this:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding file resolvers to category...&#39;);
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));{code}

Let&#39;s explain. First off, there are two attributes here worth noting:

* *source* - This is the source of the files, or the path in which they can be found. This points to our source_assets and source_core paths, which were defined above. Note the lack of a trailing slash, as we mentioned earlier.

* *target* - This an eval&#39;ed statement that returns where the script will be installed. Here, we&#39;re telling it to install to the assets path and core path of the User&#39;s MODX install, respectively.

Also, the first parameter of the resolve() call tells MODX this is a &#39;file&#39; resolver. We&#39;ll be looking into PHP resolvers later on in this tutorial.

If you run the build script now, it will package in your doodles/core/ and doodles/assets/ directories, and install them into the User&#39;s proper directories. Great!

h3. Adding the Menu and Action

Now that we&#39;ve got most of our Extra nice and packaged, let&#39;s add in the Menu and Action that make up our Custom Manager Page (CMP). Add this code below the putVehicle line for our Category:

{code}
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Packaging in menu...&#39;);
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;
if (empty($menu)) $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Could not package in menu.&#39;);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$modx-&gt;log(modX::LOG_LEVEL_INFO,&#39;Adding in PHP resolvers...&#39;);
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$menu);
{code}

Very similar to our Category Vehicle creation code. There are a couple differences, however, worth noting:

* PRESERVE_KEYS is set to &#39;true&#39; on our menu. This is because menu keys are unique - and we want to preserve that for our installed menu.
* UNIQUE_KEY of the related object Action is an array. This tells MODX to look for a modAction object that has both a &#39;namespace&#39; =&gt; &#39;doodles&#39; and a controller of &#39;controllers/index&#39;. It&#39;s a bit more specific on the search.

As you probably guessed, we need to add a transport.menu.php file. Add one at /www/doodles/_build/data/transport.menu.php:

{code}
&lt;?php
$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; 0,
    &#39;controller&#39; =&gt; &#39;controllers/index&#39;,
    &#39;haslayout&#39; =&gt; true,
    &#39;lang_topics&#39; =&gt; &#39;doodles:default&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);

$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;doodles&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;doodles.desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; 0,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
unset($menus);

return $menu;
{code}

Looks very similar to our transport.snippets.php file, except we&#39;re just returning one menu, and we&#39;re addOne 
return $menu;

h2. Adding a Resolver

h2. Adding the Changelog, Readme, License and Setup Options

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:8;a:3:{s:2:"id";s:8:"33947729";s:3:"ver";s:1:"7";s:4:"code";s:686:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Setting Up Our Build Directory

h3. The Build Script

h2. Adding in the Data

h3. Adding the Snippet

h3. Adding in Snippet Property Translations

h3. Adding the Menu and Action

h2. Adding a Resolver

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:9;a:3:{s:2:"id";s:8:"33947717";s:3:"ver";s:1:"6";s:4:"code";s:608:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Setting Up Our Build Directory

h2. Adding in the Data

h3. Adding in Snippet Property Translations

h2. Adding a Resolver

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:10;a:3:{s:2:"id";s:8:"33947715";s:3:"ver";s:1:"5";s:4:"code";s:599:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Setting Up Our Build Directory

h2. Adding in the Data

h2. Translating Element Properties

h2. Adding a Resolver

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:11;a:3:{s:2:"id";s:8:"33947714";s:3:"ver";s:1:"4";s:4:"code";s:516:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* Part III: Packaging Our Extra{panel}
{toc}

h2. Setting Up Our Build Directory

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:12;a:3:{s:2:"id";s:8:"33947707";s:3:"ver";s:1:"3";s:4:"code";s:567:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a Series:
* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III]{panel}
{toc}

h2. Setting Up Our Build Directory

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:13;a:3:{s:2:"id";s:8:"33947705";s:3:"ver";s:1:"2";s:4:"code";s:572:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel:title=This tutorial is part of a Series}* [Part I: Getting Started and Creating the Doodles Snippet|Developing an Extra in MODX Revolution]
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III]{panel}
{toc}

h2. Setting Up Our Build Directory

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}i:14;a:3:{s:2:"id";s:8:"33947704";s:3:"ver";s:1:"1";s:4:"code";s:426:"{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}

{panel}This tutorial is part of a series:
* Part I: Getting Started and Creating the Doodles Snippet
* Part II: Creating our Custom Manager Page
* Part III: Packaging Our Extra{panel}

{toc}

h2. Setting Up Our Build Directory

h2. Summary

{note}This tutorial is Under Construction and not finished. Thanks for your patience.{note}
";}}}