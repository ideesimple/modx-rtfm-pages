a:5:{s:2:"id";s:8:"33226895";s:4:"info";a:4:{s:6:"Title:";s:58:"Reverse Engineer xPDO Classes from Existing Database Table";s:7:"Author:";s:17:"Everett Griffiths";s:16:"Last Changed by:";s:17:"Everett Griffiths";s:12:"Wiki Markup:";s:73:"[revolution20:Reverse Engineer xPDO Classes from Existing Database Table]";}s:6:"parent";s:8:"18678102";s:6:"source";s:16538:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user

// if this file is not placed side by side with the config.core.php file, add the directory path
include_once &#39;config.core.php&#39;;
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
if (!defined(&#39;MODX_CORE_PATH&#39;)) {
    print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
        &lt;p&gt;MODX_CORE_PATH not defined! Did you include the correct config file?&lt;/p&gt;&#39;);
    exit;
}

$xpdo_path = strtr(MODX_CORE_PATH . &#39;xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = MODX_CORE_PATH . &quot;components/$package_name/&quot;;
$model_dir = MODX_CORE_PATH . &quot;components/$package_name/model/&quot;;
$class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name&quot;;
$schema_dir = MODX_CORE_PATH . &quot;components/$package_name/model/schema&quot;;
$mysql_class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = MODX_CORE_PATH . &quot;components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) ) {
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d) {
if ( !file_exists($d) ) {
if ( !mkdir($d, 0777, true) ) {
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) ) {
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose ) {
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose) {
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema) {
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes) {

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose) {
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir) {
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f ) {
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f)) {
if ( unlink(&quot;$dir/$f&quot;) ) {
if ($verbose) {
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else {
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg) {
if ( php_sapi_name() == &#39;cli&#39; ) {
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g.
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. Defining Key Relationships

Once you have your XML schema file generated, you may need to edit it manually to define any foreign key relationships between your tables.  It&#39;s best if you create a backup of the XML schema file, then add in your aggregate and composite relationships (see [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] for more info).

In the scaffolding script above, set the following:

{code}
$regenerate_schema = false;
{code}

Then re-run the script in order to push your changes in the XML to the PHP class files.



h2. Accessing your Data

Once you&#39;ve created the required xPDO classes, you need to use xPDO&#39;s methods to access them (e.g. in a Snippet or in a Custom Manager Page).

{code}
$modx-&gt;addPackage(&#39;mypackage&#39;,&#39;/full/path/to/core/components/mypackage/model/&#39;,&#39;mp_&#39;);

$my_items = $modx-&gt;getCollection(&#39;Items&#39;);

$output = &#39;&#39;;

if ($my_items) {
    foreach ($my_items as $item) {
        $output .= $item-&gt;get(&#39;itemname&#39;) . &#39;&lt;br/&gt;&#39;;
    }
}
else {
    return &#39;No items found.&#39;;
}

return $output;
{code}

Note that [addPackage|xPDO20:xPDO.addPackage] requires that you specify the correct table prefix\!


h2. See Also

* [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] Looking at XML schema file relations
* [addPackage|xPDO20:xPDO.addPackage] for loading up your schema
* [getObject|xPDO20:xPDO.getObject] for loading up a single object
* [getCollection|xPDO20:xPDO.getCollection] for loading up a collection of objects.
* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Retrieving Objects] a demonstration of how to retrieve objects using xPDO
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";s:8:"versions";a:17:{i:0;a:3:{s:2:"id";s:8:"33226895";s:3:"ver";s:1:"1";s:4:"code";s:16538:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user

// if this file is not placed side by side with the config.core.php file, add the directory path
include_once &#39;config.core.php&#39;;
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
if (!defined(&#39;MODX_CORE_PATH&#39;)) {
    print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
        &lt;p&gt;MODX_CORE_PATH not defined! Did you include the correct config file?&lt;/p&gt;&#39;);
    exit;
}

$xpdo_path = strtr(MODX_CORE_PATH . &#39;xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = MODX_CORE_PATH . &quot;components/$package_name/&quot;;
$model_dir = MODX_CORE_PATH . &quot;components/$package_name/model/&quot;;
$class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name&quot;;
$schema_dir = MODX_CORE_PATH . &quot;components/$package_name/model/schema&quot;;
$mysql_class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = MODX_CORE_PATH . &quot;components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) ) {
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d) {
if ( !file_exists($d) ) {
if ( !mkdir($d, 0777, true) ) {
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) ) {
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose ) {
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose) {
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema) {
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes) {

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose) {
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir) {
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f ) {
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f)) {
if ( unlink(&quot;$dir/$f&quot;) ) {
if ($verbose) {
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else {
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg) {
if ( php_sapi_name() == &#39;cli&#39; ) {
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g.
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. Defining Key Relationships

Once you have your XML schema file generated, you may need to edit it manually to define any foreign key relationships between your tables.  It&#39;s best if you create a backup of the XML schema file, then add in your aggregate and composite relationships (see [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] for more info).

In the scaffolding script above, set the following:

{code}
$regenerate_schema = false;
{code}

Then re-run the script in order to push your changes in the XML to the PHP class files.



h2. Accessing your Data

Once you&#39;ve created the required xPDO classes, you need to use xPDO&#39;s methods to access them (e.g. in a Snippet or in a Custom Manager Page).

{code}
$modx-&gt;addPackage(&#39;mypackage&#39;,&#39;/full/path/to/core/components/mypackage/model/&#39;,&#39;mp_&#39;);

$my_items = $modx-&gt;getCollection(&#39;Items&#39;);

$output = &#39;&#39;;

if ($my_items) {
    foreach ($my_items as $item) {
        $output .= $item-&gt;get(&#39;itemname&#39;) . &#39;&lt;br/&gt;&#39;;
    }
}
else {
    return &#39;No items found.&#39;;
}

return $output;
{code}

Note that [addPackage|xPDO20:xPDO.addPackage] requires that you specify the correct table prefix\!


h2. See Also

* [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] Looking at XML schema file relations
* [addPackage|xPDO20:xPDO.addPackage] for loading up your schema
* [getObject|xPDO20:xPDO.getObject] for loading up a single object
* [getCollection|xPDO20:xPDO.getCollection] for loading up a collection of objects.
* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Retrieving Objects] a demonstration of how to retrieve objects using xPDO
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:1;a:3:{s:2:"id";s:8:"39355655";s:3:"ver";s:1:"1";s:4:"code";s:16314:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user

// if this file is not placed side by side with the config.core.php file, add the directory path
include_once &#39;config.core.php&#39;;
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$xpdo_path = strtr(MODX_CORE_PATH . &#39;xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = MODX_CORE_PATH . &quot;components/$package_name/&quot;;
$model_dir = MODX_CORE_PATH . &quot;components/$package_name/model/&quot;;
$class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name&quot;;
$schema_dir = MODX_CORE_PATH . &quot;components/$package_name/model/schema&quot;;
$mysql_class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = MODX_CORE_PATH . &quot;components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g.
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. Defining Key Relationships

Once you have your XML schema file generated, you may need to edit it manually to define any foreign key relationships between your tables.  It&#39;s best if you create a backup of the XML schema file, then add in your aggregate and composite relationships (see [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] for more info).

In the scaffolding script above, set the following:

{code}
$regenerate_schema = false;
{code}

Then re-run the script in order to push your changes in the XML to the PHP class files.



h2. Accessing your Data

Once you&#39;ve created the required xPDO classes, you need to use xPDO&#39;s methods to access them (e.g. in a Snippet or in a Custom Manager Page).

{code}
$modx-&gt;addPackage(&#39;mypackage&#39;,&#39;/full/path/to/core/components/mypackage/model/&#39;,&#39;mp_&#39;);

$my_items = $modx-&gt;getCollection(&#39;Items&#39;);

$output = &#39;&#39;;

if ($my_items) {
    foreach ($my_items as $item) {
        $output .= $item-&gt;get(&#39;itemname&#39;) . &#39;&lt;br/&gt;&#39;;
    }
}
else {
    return &#39;No items found.&#39;;
}

return $output;
{code}

Note that [addPackage|xPDO20:xPDO.addPackage] requires that you specify the correct table prefix\!


h2. See Also

* [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] Looking at XML schema file relations
* [addPackage|xPDO20:xPDO.addPackage] for loading up your schema
* [getObject|xPDO20:xPDO.getObject] for loading up a single object
* [getCollection|xPDO20:xPDO.getCollection] for loading up a collection of objects.
* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Retrieving Objects] a demonstration of how to retrieve objects using xPDO
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:2;a:3:{s:2:"id";s:8:"39355457";s:3:"ver";s:1:"1";s:4:"code";s:16289:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user

// if this file is not placed side by side with the config.core.php file, add the directory path
include_once &#39;config.core.php&#39;;
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(MODX_CORE_PATH . &#39;config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$xpdo_path = strtr(MODX_CORE_PATH . &#39;xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = MODX_CORE_PATH . &quot;components/$package_name/&quot;;
$model_dir = MODX_CORE_PATH . &quot;components/$package_name/model/&quot;;
$class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name&quot;;
$schema_dir = MODX_CORE_PATH . &quot;components/$package_name/model/schema&quot;;
$mysql_class_dir = MODX_CORE_PATH . &quot;components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = MODX_CORE_PATH . &quot;components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g.
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. Defining Key Relationships

Once you have your XML schema file generated, you may need to edit it manually to define any foreign key relationships between your tables.  It&#39;s best if you create a backup of the XML schema file, then add in your aggregate and composite relationships (see [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] for more info).

In the scaffolding script above, set the following:

{code}
$regenerate_schema = false;
{code}

Then re-run the script in order to push your changes in the XML to the PHP class files.



h2. Accessing your Data

Once you&#39;ve created the required xPDO classes, you need to use xPDO&#39;s methods to access them (e.g. in a Snippet or in a Custom Manager Page).

{code}
$modx-&gt;addPackage(&#39;mypackage&#39;,&#39;/full/path/to/core/components/mypackage/model/&#39;,&#39;mp_&#39;);

$my_items = $modx-&gt;getCollection(&#39;Items&#39;);

$output = &#39;&#39;;

if ($my_items) {
    foreach ($my_items as $item) {
        $output .= $item-&gt;get(&#39;itemname&#39;) . &#39;&lt;br/&gt;&#39;;
    }
}
else {
    return &#39;No items found.&#39;;
}

return $output;
{code}

Note that [addPackage|xPDO20:xPDO.addPackage] requires that you specify the correct table prefix\!


h2. See Also

* [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] Looking at XML schema file relations
* [addPackage|xPDO20:xPDO.addPackage] for loading up your schema
* [getObject|xPDO20:xPDO.getObject] for loading up a single object
* [getCollection|xPDO20:xPDO.getCollection] for loading up a collection of objects.
* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Retrieving Objects] a demonstration of how to retrieve objects using xPDO
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:3;a:3:{s:2:"id";s:8:"39355455";s:3:"ver";s:1:"1";s:4:"code";s:16180:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.  

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. Defining Key Relationships

Once you have your XML schema file generated, you may need to edit it manually to define any foreign key relationships between your tables.  It&#39;s best if you create a backup of the XML schema file, then add in your aggregate and composite relationships (see [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] for more info).

In the scaffolding script above, set the following:

{code}
$regenerate_schema = false;
{code}

Then re-run the script in order to push your changes in the XML to the PHP class files.



h2. Accessing your Data

Once you&#39;ve created the required xPDO classes, you need to use xPDO&#39;s methods to access them (e.g. in a Snippet or in a Custom Manager Page).

{code}
$modx-&gt;addPackage(&#39;mypackage&#39;,&#39;/full/path/to/core/components/mypackage/model/&#39;,&#39;mp_&#39;);

$my_items = $modx-&gt;getCollection(&#39;Items&#39;);

$output = &#39;&#39;;

if ($my_items) {
    foreach ($my_items as $item) {
        $output .= $item-&gt;get(&#39;itemname&#39;) . &#39;&lt;br/&gt;&#39;;
    }
}
else {
    return &#39;No items found.&#39;;
}

return $output;
{code}

Note that [addPackage|xPDO20:xPDO.addPackage] requires that you specify the correct table prefix!


h2. See Also

* [Schema Files and Relations|xPDO20:More Examples of xPDO XML Schema Files] Looking at XML schema file relations
* [addPackage|xPDO20:xPDO.addPackage] for loading up your schema
* [getObject|xPDO20:xPDO.getObject] for loading up a single object
* [getCollection|xPDO20:xPDO.getCollection] for loading up a collection of objects.
* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Retrieving Objects] a demonstration of how to retrieve objects using xPDO
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:4;a:3:{s:2:"id";s:8:"39354570";s:3:"ver";s:1:"1";s:4:"code";s:15492:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.  

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.

h2. Accessing your Data

Once you&#39;ve created the required xPDO classes, you need to use xPDO&#39;s methods to access them (e.g. in a Snippet or in a Custom Manager Page).

{code}
$modx-&gt;addPackage(&#39;mypackage&#39;,&#39;/full/path/to/core/components/mypackage/model/&#39;,&#39;mp_&#39;);

$my_items = $modx-&gt;getCollection(&#39;Items&#39;);

$output = &#39;&#39;;

if ($my_items) {
    foreach ($my_items as $item) {
        $output .= $item-&gt;get(&#39;itemname&#39;) . &#39;&lt;br/&gt;&#39;;
    }
}
else {
    return &#39;No items found.&#39;;
}

return $output;
{code}

Note that [addPackage|xPDO20:xPDO.addPackage] requires that you specify the correct table prefix!


h2. See Also

* [addPackage|xPDO20:xPDO.addPackage] for loading up your schema
* [getObject|xPDO20:xPDO.getObject] for loading up a single object
* [getCollection|xPDO20:xPDO.getCollection] for loading up a collection of objects.
* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Retrieving Objects] a demonstration of how to retrieve objects using xPDO
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:5;a:3:{s:2:"id";s:8:"39354565";s:3:"ver";s:1:"1";s:4:"code";s:14507:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how third-party components are distributed because it provides a predictable and unified way of creating new database tables.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.  

In the image below, it&#39;s important to realize that you can start with any one component, and the other 2 can be automatically generated.

!xPDO_Forward_and_Reverse.jpg|align=center!

Arguably, the easiest &quot;access point&quot; to the xPDO technology is to start with some existing database tables and use those to generate the XML schema file and PHP classes, and that&#39;s what this page demonstrates.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

We need a script to scan your database tables and generate the XML schema and PHP files.  In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:6;a:3:{s:2:"id";s:8:"39354528";s:3:"ver";s:1:"1";s:4:"code";s:14187:"\\

{toc}

h2. Introduction

The xPDO Object-Relational-Bride (ORB) relies on a series of PHP classes to provide an interface to database tables.  These PHP classes can be generated automatically by parsing a specially formatted XML file, by reverse engineering existing database tables, or they can be written by hand (masochists only).  The easiest approach here is to reverse engineer existing MySQL database tables. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, MySQL represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how some third-party components are distributed.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.  

!xPDO_Forward_and_Reverse.jpg|align=center!

You can technically get this set up by defining any one of the 3 items, but in practice, the easiest &quot;access point&quot; to the xPDO technology is to start with either a database table or an XML schema file.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:7;a:3:{s:2:"id";s:8:"39354526";s:3:"ver";s:1:"1";s:4:"code";s:13985:"\\

{toc}

h2. Introduction

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how some third-party components are distributed.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.  

!xPDO_Forward_and_Reverse.jpg|align=center!

You can technically get this set up by defining any one of the 3 items, but in practice, the easiest &quot;access point&quot; to the xPDO technology is to start with either a database table or an XML schema file.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:8;a:3:{s:2:"id";s:8:"39354524";s:3:"ver";s:1:"9";s:4:"code";s:13967:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.


h3. Access Points

xPDO is the engine behind this database abstraction -- ultimately it needs PHP classes that describe the data model.  You can supply an XML schema which will generate the PHP files which will in turn generate the necessary tables -- this is how some third-party components are distributed.  But in this example, we&#39;re going to start with a database table and use that to generate the XML schema, which will in turn generate the necessary PHP classes.  

!xPDO_Forward_and_Reverse.jpg|align=center!

You can technically get this set up by defining any one of the 3 items, but in practice, the easiest &quot;access point&quot; to the xPDO technology is to start with either a database table or an XML schema file.


h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:9;a:3:{s:2:"id";s:8:"36634918";s:3:"ver";s:1:"8";s:4:"code";s:13229:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);

// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}

To check whether or not this script succeeded, take a look inside the folder that is mentioned in its output, e.g. 
*/user/youruser/public_html/core/components/yourpackage/model/yourpackage*.  You should see a couple files -- one for each table.  If you see a TON of tables corresponding to all of MODx&#39;s tables, then try to explicitly set the database password and name -- leave the following line commented out:

{code}
//include(&#39;core/config/config.inc.php&#39;);
{code}

See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:10;a:3:{s:2:"id";s:8:"36634708";s:3:"ver";s:1:"7";s:4:"code";s:12746:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver, to the root of your MODx install (this is important so the script can find xPDO). This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// If your tables use a prefix, this will help identify them and it ensures that
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;;
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false;
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}


See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:11;a:3:{s:2:"id";s:8:"33947659";s:3:"ver";s:1:"6";s:4:"code";s:12667:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver. This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
// If your tables use a prefix, this will help identify them and it ensures that 
// the class names appear &quot;clean&quot;, without the prefix.
$table_prefix = &#39;&#39;; 
// If you specify a table prefix, you probably want this set to &#39;true&#39;. E.g. if you
// have custom tables alongside the modx_xxx tables, restricting the prefix ensures
// that you only generate classes/maps for the tables identified by the $table_prefix.
$restrict_prefix = false; 
// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix, $restrict_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}


See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:12;a:3:{s:2:"id";s:8:"33227207";s:3:"ver";s:1:"5";s:4:"code";s:12252:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver. This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;&#39;;// name of your database
$database_user = &#39;&#39;;// name of the user
$database_password = &#39;&#39;;// password for that database user
$table_prefix = &#39;&#39;; // if your tables use a specific prefix

// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
if ( unlink(&quot;$dir/$f&quot;) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}


See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:13;a:3:{s:2:"id";s:8:"33227205";s:3:"ver";s:1:"4";s:4:"code";s:12349:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver. This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

The crux of this script are 2 xPDO methods (note, however, that the methods belong to children objects):
* writeSchema
* parseSchema

Together, they behave similarly to other ORM&#39;s, e.g. Doctrine
{code}
// Sample Doctrine code:
Doctrine_Core::generateModelsFromDb();
{code}

Here&#39;s a reverse-engineering script that allows a bit of configuration and does a little error checking:

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it,
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications.
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;somedb&#39;;// name of your database
$database_user = &#39;some_user&#39;;// name of the user
$database_password = &#39;some_password&#39;;// password for that database user
$table_prefix = &#39;&#39;; // if your tables use a specific prefix

// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d));
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
chmod(&quot;$dir/$f&quot;, 0777); // gotta try to loosen it up before blowing it away
if ( unlink($f) )
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}


See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:14;a:3:{s:2:"id";s:8:"33227189";s:3:"ver";s:1:"3";s:4:"code";s:11966:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Copy the &quot;reverse-engineering&quot; script provided to your webserver. This script uses the xPDO classes to sniff out the definition of the table you just created.
# If needed, modify the generated XML definition file to define foreign key relationships, then regenerate the class files
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. You will probably need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

{code}
&lt;?php
/*------------------------------------------------------------------------------
================================================================================
=== Reverse Engineer Existing MySQL Database Tables to xPDO Maps and Classes ===
================================================================================

SYNOPSIS:
This script generates the XML schema and PHP class files that describe custom 
database tables.

This script is meant to be executed once only: after the class and schema files
have been created, the purpose of this script has been served.

USAGE:
1. Upload this file to the root of your MODx installation
2. Set the configuration details below
3. Navigate to this script in a browser to execute it, 
e.g. http://yoursite.com/thisscript.php
or, you can do this via the command line, e.g. php this-script.php

INPUT:
Please configure the options below.

OUTPUT:
Creates XML and PHP files:
core/components/$package_name/model/$package_name/*.class.php
core/components/$package_name/model/$package_name/mysql/*.class.php
core/components/$package_name/model/$package_name/mysql/*.inc.php
core/components/$package_name/schema/$package_name.mysql.schema.xml

SEE ALSO:
http://modxcms.com/forums/index.php?topic=40174.0
http://rtfm.modx.com/display/revolution20/Using+Custom+Database+Tables+in+your+3rd+Party+Components
http://rtfm.modx.com/display/xPDO20/xPDOGenerator.writeSchema
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------------
Be sure to create a valid database user with permissions to the appropriate 
databases and tables before you try to run this script, e.g. by running
something like the following:

CREATE USER &#39;your_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;y0urP@$$w0rd&#39;;
GRANT ALL ON your_db.* TO &#39;your_user&#39;@&#39;localhost&#39;;
FLUSH PRIVILEGES;

Be sure to test that the login criteria you created actually work before
continuing. If you *can* log in, but you receive errors (e.g. SQLSTATE[42000] [1044] )
when this script runs, then you may need to grant permissions for CREATE TEMPORARY TABLES
------------------------------------------------------------------------------*/
$debug = false; // if true, will include verbose debugging info, including SQL errors.
$verbose = true;// if true, will print status info.

// The XML schema file *must* be updated each time the database is modified, either
// manually or via this script. By default, the schema is regenerated.
// If you have spent time adding in composite/aggregate relationships to your
// XML schema file (i.e. foreign key relationships), then you may want to set this
// to &#39;false&#39; in order to preserve your custom modifications. 
$regenerate_schema = true;

// Class files are not overwritten by default
$regenerate_classes = true;

// Your package shortname:
$package_name = &#39;&#39;;


// Database Login Info can be set explicitly:
$database_server = &#39;localhost&#39;;// most frequently, your database resides locally
$dbase = &#39;somedb&#39;;// name of your database
$database_user = &#39;some_user&#39;;// name of the user
$database_password = &#39;some_password&#39;;// password for that database user
$table_prefix = &#39;&#39;; // if your tables use a specific prefix

// OR, use your MODx Revo connection details.  Just uncomment the next line:
//include(&#39;core/config/config.inc.php&#39;);




//------------------------------------------------------------------------------
//  DO NOT TOUCH BELOW THIS LINE
//------------------------------------------------------------------------------
$base_path = realpath(dirname(__FILE__));
$xpdo_path = strtr( $base_path . &#39;/core/xpdo/xpdo.class.php&#39;, &#39;\\&#39;, &#39;/&#39;);
include_once ( $xpdo_path );

// A few definitions of files/folders:
$package_dir = &quot;$base_path/core/components/$package_name/&quot;;
$model_dir = &quot;$base_path/core/components/$package_name/model/&quot;;
$class_dir = &quot;$base_path/core/components/$package_name/model/$package_name&quot;;
$schema_dir = &quot;$base_path/core/components/$package_name/model/schema&quot;;
$mysql_class_dir = &quot;$base_path/core/components/$package_name/model/$package_name/mysql&quot;;
$xml_schema_file = &quot;$base_path/core/components/$package_name/model/schema/$package_name.mysql.schema.xml&quot;;

// A few variables used to track execution times.
$mtime= microtime();
$mtime= explode(&#39; &#39;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tstart= $mtime;

// Validations
if ( empty($package_name) )
{
print_msg(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The $package_name cannot be empty!  Please adjust the configuration and try again.&lt;/p&gt;&#39;);
exit;
}

// Create directories if necessary
$dirs = array($package_dir, $schema_dir ,$mysql_class_dir, $class_dir);

foreach ($dirs as $d)
{
if ( !file_exists($d) )
{
if ( !mkdir($d, 0777, true) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;Error creating &lt;code&gt;%s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create the directory (and its parents) and try again.&lt;/p&gt;&#39;
, $d
));
exit;
}
}
if ( !is_writable($d) )
{
print_msg( sprintf(&#39;&lt;h1&gt;Reverse Engineering Error&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;%s&lt;/code&gt; directory is not writable by PHP.&lt;/p&gt;
&lt;p&gt;Adjust the permissions and try again.&lt;/p&gt;&#39;
, $d)); 
exit;
}
}

if ( $verbose )
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; The necessary directories exist and have the correct permissions inside of &lt;br/&gt;
&lt;code&gt;%s&lt;/code&gt;&#39;, $package_dir));
}

// Delete/regenerate map files?
if ( file_exists($xml_schema_file) &amp;&amp; !$regenerate_schema &amp;&amp; $verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; Using existing XML schema file:&lt;br/&gt;&lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}

$xpdo = new xPDO(&quot;mysql:host=$database_server;dbname=$dbase&quot;, $database_user, $database_password, $table_prefix);

// Set the package name and root path of that package
$xpdo-&gt;setPackage($package_name, $package_dir, $package_dir);
$xpdo-&gt;setDebug($debug);

$manager = $xpdo-&gt;getManager();
$generator = $manager-&gt;getGenerator();

//Use this to create an XML schema from an existing database
if ($regenerate_schema)
{
$xml = $generator-&gt;writeSchema($xml_schema_file, $package_name, &#39;xPDOObject&#39;, $table_prefix);
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;&lt;strong&gt;Ok:&lt;/strong&gt; XML schema file generated: &lt;code&gt;%s&lt;/code&gt;&#39;,$xml_schema_file));
}
}

// Use this to generate classes and maps from your schema
if ($regenerate_classes)
{

print_msg(&#39;&lt;br/&gt;Attempting to remove/regenerate class files...&#39;);
delete_class_files( $class_dir );
delete_class_files( $mysql_class_dir );
}

// This is harmless in and of itself: files won&#39;t be overwritten if they exist.
$generator-&gt;parseSchema($xml_schema_file, $model_dir);

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

if ($verbose)
{
print_msg(&quot;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Finished!&lt;/strong&gt; Execution time: {$totalTime}&lt;br/&gt;&quot;);

if ($regenerate_schema)
{
print_msg(&quot;&lt;br/&gt;If you need to define aggregate/composite relationships in your XML schema file, be sure to regenerate your class files.&quot;);
}
}

exit ();


/*------------------------------------------------------------------------------
INPUT: $dir: a directory containing class files you wish to delete.
------------------------------------------------------------------------------*/
function delete_class_files($dir)
{
global $verbose;

$all_files = scandir($dir);
foreach ( $all_files as $f )
{
if ( preg_match(&#39;#\.class\.php$#i&#39;, $f) || preg_match(&#39;#\.map\.inc\.php$#i&#39;, $f))
{
chmod(&quot;$dir/$f&quot;, 0777); // gotta try to loosen it up before blowing it away
if ( unlink($f) ) 
{
if ($verbose)
{
print_msg( sprintf(&#39;&lt;br/&gt;Deleted file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
else
{
print_msg( sprintf(&#39;&lt;br/&gt;Failed to delete file: &lt;code&gt;%s/%s&lt;/code&gt;&#39;,$dir,$f) );
}
}
}
}
/*------------------------------------------------------------------------------
Formats/prints messages.  The behavior is different if the script is run
via the command line (cli).
------------------------------------------------------------------------------*/
function print_msg($msg)
{
if ( php_sapi_name() == &#39;cli&#39; )
{
$msg = preg_replace(&#39;#&lt;br\s*/&gt;#i&#39;, &quot;\n&quot;, $msg);
$msg = preg_replace(&#39;#&lt;h1&gt;#i&#39;, &#39;== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h1&gt;#i&#39;, &#39; ==&#39;, $msg);
$msg = preg_replace(&#39;#&lt;h2&gt;#i&#39;, &#39;=== &#39;, $msg);
$msg = preg_replace(&#39;#&lt;/h2&gt;#i&#39;, &#39; ===&#39;, $msg);
$msg = strip_tags($msg) . &quot;\n&quot;;
}
print $msg;
}

/* EOF */
{code}


See [http://modxcms.com/forums/index.php?topic=40174.0] for more discussion on this script.


h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]
* [xPDO20:Generating the Model Code] -- offers a streamlined version of the script provided here, but you can also change your class templates.
* [xPDO20:More Examples of xPDO XML Schema Files] -- juxtaposes MySQL database tables with xPDO XML schemas
{scrollbar}";}i:15;a:3:{s:2:"id";s:8:"33227171";s:3:"ver";s:1:"2";s:4:"code";s:2640:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Create a &quot;reverse-engineering&quot; script that uses the xPDO classes to sniff out the definition of the table you just created.
# Modify the generated XML definition file according to your needs: the XML generator is still being developed, so your definition may not accurately describe all aspects of your model (e.g. foreign keys).
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. It&#39;s possible that you&#39;ll need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding.

A full example script is coming here.  For now, refer to the forum post and its sample script:

See [http://modxcms.com/forums/index.php?topic=40174.0]


h2. Using your Schema and Class files to Access your Database



h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]

{scrollbar}";}i:16;a:3:{s:2:"id";s:8:"33226896";s:3:"ver";s:1:"1";s:4:"code";s:2641:"\\

{toc}

Learning a new system like xPDO can be daunting, so if this is your first time around, it&#39;s generally considered much easier to deal with a known entity: an existing MySQL database table. Even if you&#39;ve never worked with MySQL before, it has been around for a long time, and there are numerous tutorials, books, videos, and certification programs available to help you learn how to perform basic functions in it.  Because of this popularity, it represents an easier access point for you to create objects than the alternative of writing your own XML definition files for use with xPDO.

Our process will be this:

# Create a database table (or tables) using MySQL (this can be done via the mysql command line or any number of MySQL GUI clients, e.g. SQL-Yog)
# Create a &quot;reverse-engineering&quot; script that uses the xPDO classes to sniff out the definition of the table you just created.
# Modify the generated XML definition file according to your needs: the XML generator is still being developed, so your definition may not accurately describe all aspects of your model (e.g. foreign keys).
# Connect your newly created class and schema files to a Snippet or Custom Manager Page

Even if you plan to deploy your code and its associated data models onto multiple other other platforms, it&#39;s generally considered *much* easier to develop it with a single database in mind. Once you&#39;ve done that, you can then focus on abstraction later.  You can of course jump right into the xPDO definitions and classes that will define database-agnostic classes and schemas, but it is more difficult for the novice precisely because it deals with abstractions.  The further you get from concrete examples, the more difficult the development becomes.

h2. Creating a MySQL table

One of the easiest ways to create a MySQL table is to use one of the many GUI editors available. SQL-Yog is a great desktop application for MySQL management on Windows, Macs offer Sequel Pro.  If you are using a web application, phpMyAdmin is nearly ubiquitous.

h2. Create Reverse Engineering Script

In general, this is a &quot;disposable&quot; script that you may only need to run once. It&#39;s possible that you&#39;ll need to make adjustments and run it more than once, but in concept and in function, this script is merely scaffolding. 

A full example script is coming here.  For now, refer to the forum post and its sample script:

See [http://modxcms.com/forums/index.php?topic=40174.0]


h2. Using your Schema and Class files to Access your Database



h2. See Also

* [xPDO: Creating Objects|XPDO20:Creating Objects]

{scrollbar}";}}}