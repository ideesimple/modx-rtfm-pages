a:5:{s:2:"id";s:8:"22183951";s:4:"info";a:4:{s:6:"Title:";s:17:"Extending modUser";s:7:"Author:";s:18:"W. Shawn Wilkerson";s:16:"Last Changed by:";s:17:"Everett Griffiths";s:12:"Wiki Markup:";s:32:"[revolution20:Extending modUser]";}s:6:"parent";s:8:"18678339";s:6:"source";s:16858:"{toc:printable=false}

h2. Intended Audience

This article is for developers who are looking to add additional data to their MODX users and functionality to the related classes.  Although this is possible via a less integrated approach by simply adding a database table that includes a foreign key relation back to the original MODX users table, the approach outlined here is for a more thorough integration via extending the core modUser class.  The steps here are highly technical and they rely on MODX&#39;s underlying xPDO framework.  You should have some familiarity with xPDO&#39;s objects and methods (e.g. [getObject|xPDO20:xPDO.getObject]) before attempting this tutorial.

h3. See Also 

* [Reverse Engineer xPDO Classes from Existing Database Table]
* [xPDO20:More Examples of xPDO XML Schema Files]
* [xPDO20:Generating the Model Code]


h2. Overview

By extending the MODx Revolution authentication layer we can build very complex and varied user subsystems, e.g. for social networking, user management systems, or other applications not yet conceptualized. This ability to extend the modUser class is just one example of how to extend a core class -- a similar approach could be used to extend any MODX core class.

h2. Purpose

Extending modUser is for those situations when user authentication or user interaction need to be extended or enhanced, e.g. for easier custom authentication.


h2. The Rules

Extending modUser does _not_ mean we are adding anything to the _modx_\_users table in the database. Instead, we will be adding a separate related table, bound to the original table via a foreign key.  At no time should an extended application actually attempt to completely replace the modUser Class.  We use the modUser class as our foundation and we build on it. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h3. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. 

h4. Simple Example

The simplest example we could imagine is that we want to add a single extra attribute to the user data -- so in the database, this would mean we have a separate table with 2 columns: one for the foreign key relation back to the *modx_users* table, and the other column containing our new &quot;extra&quot; attribute, e.g. a _fackbook_url_:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
&lt;!-- extend the modUser class --&gt;
&lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
&lt;composite alias=&quot;Data&quot; local=&quot;id&quot; class=&quot;Userdata&quot; foreign=&quot;userdata_id&quot; cardinality=&quot;one&quot; owner=&quot;local&quot; /&gt;
&lt;/object&gt;

   &lt;object class=&quot;Userdata&quot; table=&quot;data&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
   &lt;field key=&quot;userdata_id&quot; dbtype=&quot;int&quot; precision=&quot;11&quot; phptype=&quot;integer&quot; null=&quot;false&quot; attributes=&quot;unsigned&quot;/&gt;
&lt;field key=&quot;facebook_url&quot; dbtype=&quot;varchar&quot; precision=&quot;100&quot; phptype=&quot;string&quot; null=&quot;true&quot; /&gt;
&lt;index alias=&quot;userdata_id&quot; name=&quot;userdata_id&quot; primary=&quot;false&quot; unique=&quot;true&quot; type=&quot;BTREE&quot;&gt;
            &lt;column key=&quot;userdata_id&quot; length=&quot;&quot; collation=&quot;A&quot; null=&quot;false&quot; /&gt;
        &lt;/index&gt;
&lt;aggregate alias=&quot;extUser&quot; local=&quot;userdata_id&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
&lt;/object&gt;
 &lt;/model&gt;
{code}

Note that the extending of modUser class happens all within that single _object_ node.  Also notice that we specify the prefix for our ancillary table in the _model_ node: *ext_* 

h4. More Involved Example

Note that the _index=&quot;unique&quot;_ bit has been deprecated -- the index declaration should go into its own node as in the example above.

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h3. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent::__construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h3. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h3. 4.) Final Step Create a class to access and utilize your extended class

The whole reason for extending a core class is so you could interact with your extended data more easily.  So at some point in a Snippet or Plugin or CMP, you&#39;d be working with your new data.

h4. Simple Example

Here&#39;s how you might interact with your extended data in a Snippet:

{code}
$modx-&gt;addPackage(&#39;extendeduser&#39;, MODX_CORE_PATH . &#39;components/extendeduser/model/&#39;, &#39;ext_&#39;);
$user = $modx-&gt;getObject(&#39;extUser&#39;, 123); // where 123 is the id of a user
$data = $user-&gt;getOne(&#39;Data&#39;); // use the alias from the schema
// toArray will print all the extra data, e.g. facebook_url
return print_r($data-&gt;toArray(), true);  
{code}

h4. More complex example

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For the sake of brevity, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";s:8:"versions";a:29:{i:0;a:3:{s:2:"id";s:8:"22183951";s:3:"ver";s:1:"2";s:4:"code";s:16858:"{toc:printable=false}

h2. Intended Audience

This article is for developers who are looking to add additional data to their MODX users and functionality to the related classes.  Although this is possible via a less integrated approach by simply adding a database table that includes a foreign key relation back to the original MODX users table, the approach outlined here is for a more thorough integration via extending the core modUser class.  The steps here are highly technical and they rely on MODX&#39;s underlying xPDO framework.  You should have some familiarity with xPDO&#39;s objects and methods (e.g. [getObject|xPDO20:xPDO.getObject]) before attempting this tutorial.

h3. See Also 

* [Reverse Engineer xPDO Classes from Existing Database Table]
* [xPDO20:More Examples of xPDO XML Schema Files]
* [xPDO20:Generating the Model Code]


h2. Overview

By extending the MODx Revolution authentication layer we can build very complex and varied user subsystems, e.g. for social networking, user management systems, or other applications not yet conceptualized. This ability to extend the modUser class is just one example of how to extend a core class -- a similar approach could be used to extend any MODX core class.

h2. Purpose

Extending modUser is for those situations when user authentication or user interaction need to be extended or enhanced, e.g. for easier custom authentication.


h2. The Rules

Extending modUser does _not_ mean we are adding anything to the _modx_\_users table in the database. Instead, we will be adding a separate related table, bound to the original table via a foreign key.  At no time should an extended application actually attempt to completely replace the modUser Class.  We use the modUser class as our foundation and we build on it. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h3. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. 

h4. Simple Example

The simplest example we could imagine is that we want to add a single extra attribute to the user data -- so in the database, this would mean we have a separate table with 2 columns: one for the foreign key relation back to the *modx_users* table, and the other column containing our new &quot;extra&quot; attribute, e.g. a _fackbook_url_:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
&lt;!-- extend the modUser class --&gt;
&lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
&lt;composite alias=&quot;Data&quot; local=&quot;id&quot; class=&quot;Userdata&quot; foreign=&quot;userdata_id&quot; cardinality=&quot;one&quot; owner=&quot;local&quot; /&gt;
&lt;/object&gt;

   &lt;object class=&quot;Userdata&quot; table=&quot;data&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
   &lt;field key=&quot;userdata_id&quot; dbtype=&quot;int&quot; precision=&quot;11&quot; phptype=&quot;integer&quot; null=&quot;false&quot; attributes=&quot;unsigned&quot;/&gt;
&lt;field key=&quot;facebook_url&quot; dbtype=&quot;varchar&quot; precision=&quot;100&quot; phptype=&quot;string&quot; null=&quot;true&quot; /&gt;
&lt;index alias=&quot;userdata_id&quot; name=&quot;userdata_id&quot; primary=&quot;false&quot; unique=&quot;true&quot; type=&quot;BTREE&quot;&gt;
            &lt;column key=&quot;userdata_id&quot; length=&quot;&quot; collation=&quot;A&quot; null=&quot;false&quot; /&gt;
        &lt;/index&gt;
&lt;aggregate alias=&quot;extUser&quot; local=&quot;userdata_id&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
&lt;/object&gt;
 &lt;/model&gt;
{code}

Note that the extending of modUser class happens all within that single _object_ node.  Also notice that we specify the prefix for our ancillary table in the _model_ node: *ext_* 

h4. More Involved Example

Note that the _index=&quot;unique&quot;_ bit has been deprecated -- the index declaration should go into its own node as in the example above.

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h3. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent::__construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h3. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h3. 4.) Final Step Create a class to access and utilize your extended class

The whole reason for extending a core class is so you could interact with your extended data more easily.  So at some point in a Snippet or Plugin or CMP, you&#39;d be working with your new data.

h4. Simple Example

Here&#39;s how you might interact with your extended data in a Snippet:

{code}
$modx-&gt;addPackage(&#39;extendeduser&#39;, MODX_CORE_PATH . &#39;components/extendeduser/model/&#39;, &#39;ext_&#39;);
$user = $modx-&gt;getObject(&#39;extUser&#39;, 123); // where 123 is the id of a user
$data = $user-&gt;getOne(&#39;Data&#39;); // use the alias from the schema
// toArray will print all the extra data, e.g. facebook_url
return print_r($data-&gt;toArray(), true);  
{code}

h4. More complex example

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For the sake of brevity, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:1;a:3:{s:2:"id";s:8:"39355658";s:3:"ver";s:1:"2";s:4:"code";s:16817:"{toc:printable=false}

h2. Intended Audience

This article is for developers who are looking to add additional data to their MODX users.  Although this is possible via a less integrated approach by simply adding a database table that includes a foreign key relation back to the original MODX users table, the approach outlined here is for a more thorough integration via extending the core modUser class.  The steps here are highly technical and they rely on MODX&#39;s underlying xPDO framework.  You should have some familiarity with xPDO&#39;s objects and methods (e.g. [getObject|xPDO20:xPDO.getObject]) before attempting this tutorial.

h3. See Also 

* [Reverse Engineer xPDO Classes from Existing Database Table]
* [xPDO20:More Examples of xPDO XML Schema Files]
* [xPDO20:Generating the Model Code]


h2. Overview

By extending the MODx Revolution authentication layer we can build very complex and varied user subsystems, e.g. for social networking, user management systems, or other applications not yet conceptualized. This ability to extend the modUser class is just one example of how to extend a core class -- a similar approach could be used to extend any MODX core class.

h2. Purpose

Extending modUser is for those situations when user authentication or user interaction need to be extended or enhanced, e.g. for easier custom authentication.


h2. The Rules

Extending modUser does _not_ mean we are adding anything to the _modx_\_users table in the database. Instead, we will be adding a separate related table, bound to the original table via a foreign key.  At no time should an extended application actually attempt to completely replace the modUser Class.  We use the modUser class as our foundation and we build on it. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h3. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. 

h4. Simple Example

The simplest example we could imagine is that we want to add a single extra attribute to the user data -- so in the database, this would mean we have a separate table with 2 columns: one for the foreign key relation back to the *modx_users* table, and the other column containing our new &quot;extra&quot; attribute, e.g. a _fackbook_url_:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
&lt;!-- extend the modUser class --&gt;
&lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
&lt;composite alias=&quot;Data&quot; local=&quot;id&quot; class=&quot;Userdata&quot; foreign=&quot;userdata_id&quot; cardinality=&quot;one&quot; owner=&quot;local&quot; /&gt;
&lt;/object&gt;

   &lt;object class=&quot;Userdata&quot; table=&quot;data&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
   &lt;field key=&quot;userdata_id&quot; dbtype=&quot;int&quot; precision=&quot;11&quot; phptype=&quot;integer&quot; null=&quot;false&quot; attributes=&quot;unsigned&quot;/&gt;
&lt;field key=&quot;facebook_url&quot; dbtype=&quot;varchar&quot; precision=&quot;100&quot; phptype=&quot;string&quot; null=&quot;true&quot; /&gt;
&lt;index alias=&quot;userdata_id&quot; name=&quot;userdata_id&quot; primary=&quot;false&quot; unique=&quot;true&quot; type=&quot;BTREE&quot;&gt;
            &lt;column key=&quot;userdata_id&quot; length=&quot;&quot; collation=&quot;A&quot; null=&quot;false&quot; /&gt;
        &lt;/index&gt;
&lt;aggregate alias=&quot;extUser&quot; local=&quot;userdata_id&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
&lt;/object&gt;
 &lt;/model&gt;
{code}

Note that the extending of modUser class happens all within that single _object_ node.  Also notice that we specify the prefix for our ancillary table in the _model_ node: *ext_* 

h4. More Involved Example

Note that the _index=&quot;unique&quot;_ bit has been deprecated -- the index declaration should go into its own node as in the example above.

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h3. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent::__construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h3. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h3. 4.) Final Step Create a class to access and utilize your extended class

The whole reason for extending a core class is so you could interact with your extended data more easily.  So at some point in a Snippet or Plugin or CMP, you&#39;d be working with your new data.

h4. Simple Example

Here&#39;s how you might interact with your extended data in a Snippet:

{code}
$modx-&gt;addPackage(&#39;extendeduser&#39;, MODX_CORE_PATH . &#39;components/extendeduser/model/&#39;, &#39;ext_&#39;);
$user = $modx-&gt;getObject(&#39;extUser&#39;, 123); // where 123 is the id of a user
$data = $user-&gt;getOne(&#39;Data&#39;); // use the alias from the schema
// toArray will print all the extra data, e.g. facebook_url
return print_r($data-&gt;toArray(), true);  
{code}

h4. More complex example

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For the sake of brevity, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:2;a:3:{s:2:"id";s:8:"39355657";s:3:"ver";s:1:"2";s:4:"code";s:16296:"{toc:printable=false}

h2. Intended Audience

This article is for developers who are looking to add additional data to their MODX users.  Although this is possible via a less integrated approach by simply adding a database table that includes a foreign key relation back to the original MODX users table, the approach outlined here is for a more thorough integration via extending the core modUser class.  The steps here are highly technical and they rely on MODX&#39;s underlying xPDO framework.  You should have some familiarity with xPDO&#39;s objects and methods (e.g. [getObject|xPDO20:xPDO.getObject]) before attempting this tutorial.

h3. See Also 

* [Reverse Engineer xPDO Classes from Existing Database Table]
* [xPDO20:More Examples of xPDO XML Schema Files]
* [xPDO20:Generating the Model Code]


h2. Overview

By extending the MODx Revolution authentication layer we can build very complex and varied user subsystems, e.g. for social networking, user management systems, or other applications not yet conceptualized. This ability to extend the modUser class is just one example of how to extend a core class -- a similar approach could be used to extend any MODX core class.

h2. Purpose

Extending modUser is for those situations when user authentication or user interaction need to be extended or enhanced, e.g. for easier custom authentication.


h2. The Rules

Extending modUser does _not_ mean we are adding anything to the _modx_\_users table in the database. Instead, we will be adding a separate related table, bound to the original table via a foreign key.  At no time should an extended application actually attempt to completely replace the modUser Class.  We use the modUser class as our foundation and we build on it. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h3. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. 

h4. Simple Example

The simplest example we could imagine is that we want to add a single extra attribute to the user data -- so in the database, this would mean we have a separate table with 2 columns: one for the foreign key relation back to the *modx_users* table, and the other column containing our new &quot;extra&quot; attribute, e.g. a _fackbook_url_:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
&lt;!-- extend the modUser class --&gt;
&lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Data&quot; local=&quot;id&quot; foreign=&quot;userdata_id&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
&lt;/object&gt;

   &lt;object class=&quot;Data&quot; table=&quot;data&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
   &lt;field key=&quot;userdata_id&quot; dbtype=&quot;int&quot; precision=&quot;11&quot; phptype=&quot;integer&quot; null=&quot;false&quot; attributes=&quot;unsigned&quot;/&gt;
&lt;field key=&quot;facebook_url&quot; dbtype=&quot;varchar&quot; precision=&quot;100&quot; phptype=&quot;string&quot; null=&quot;true&quot; /&gt;
&lt;index alias=&quot;userdata_id&quot; name=&quot;userdata_id&quot; primary=&quot;false&quot; unique=&quot;true&quot; type=&quot;BTREE&quot;&gt;
            &lt;column key=&quot;userdata_id&quot; length=&quot;&quot; collation=&quot;A&quot; null=&quot;false&quot; /&gt;
        &lt;/index&gt;
&lt;aggregate alias=&quot;User&quot; class=&quot;modUser&quot; local=&quot;userdata_id&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
&lt;/object&gt;
 &lt;/model&gt;
{code}

Note that the extending of modUser class happens all within that single _object_ node.  Also notice that we specify the prefix for our ancillary table in the _model_ node: *ext_*

h4. More Involved Example

Note that the _index=&quot;unique&quot;_ bit has been deprecated -- the index declaration should go into its own node as in the example above.

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h3. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent::__construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h3. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h3. 4.) Final Step Create a class to access and utilize your extended class

The whole reason for extending a core class is so you could interact with your extended data more easily.  So at some point in a Snippet or Plugin or CMP, you&#39;d be working with your new data.

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For the sake of brevity, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:3;a:3:{s:2:"id";s:8:"39355653";s:3:"ver";s:1:"2";s:4:"code";s:16058:"{toc:printable=false}

h2. Intended Audience

This article is for developers who are looking to add additional data to their MODX users.  Although this is possible via a less integrated approach by simply adding a database table that includes a foreign key relation back to the original MODX users table, the approach outlined here is for a more thorough integration via extending the core modUser class.  The steps here are highly technical and they rely on MODX&#39;s underlying xPDO framework.  You should have some familiarity with xPDO&#39;s objects and methods (e.g. [getObject|xPDO20:xPDO.getObject]) before attempting this tutorial.

h3. See Also 

* [Reverse Engineer xPDO Classes from Existing Database Table]
* [xPDO20:More Examples of xPDO XML Schema Files]
* [xPDO20:Generating the Model Code]


h2. Overview

By extending the MODx Revolution authentication layer we can build very complex and varied user subsystems, e.g. for social networking, user management systems, or other applications not yet conceptualized. This ability to extend the modUser class is just one example of how to extend a core class -- a similar approach could be used to extend any MODX core class.

h2. Purpose

Extending modUser is for those situations when user authentication or user interaction need to be extended or enhanced, e.g. for easier custom authentication.


h2. The Rules

Extending modUser does _not_ mean we are adding anything to the _modx_\_users table in the database. Instead, we will be adding a separate related table, bound to the original table via a foreign key.  At no time should an extended application actually attempt to completely replace the modUser Class.  We use the modUser class as our foundation and we build on it. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. 

h5. Simple Example

The simplest example we could imagine is that we want to add a single extra attribute to the user data -- so in the database, this would mean we have a separate table with 2 columns: one for the foreign key relation back to the *modx_users* table, and the other column containing our new &quot;extra&quot; attribute, e.g. a _fackbook_url_:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
&lt;!-- extend the modUser class --&gt;
&lt;object class=&quot;extUser&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Data&quot; local=&quot;id&quot; foreign=&quot;userdata_id&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
&lt;/object&gt;

   &lt;object class=&quot;Data&quot; table=&quot;data&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
   &lt;field key=&quot;userdata_id&quot; dbtype=&quot;int&quot; precision=&quot;11&quot; phptype=&quot;integer&quot; null=&quot;false&quot; attributes=&quot;unsigned&quot;/&gt;
&lt;field key=&quot;facebook_url&quot; dbtype=&quot;varchar&quot; precision=&quot;100&quot; phptype=&quot;string&quot; null=&quot;true&quot; /&gt;
&lt;index alias=&quot;userdata_id&quot; name=&quot;userdata_id&quot; primary=&quot;false&quot; unique=&quot;true&quot; type=&quot;BTREE&quot;&gt;
            &lt;column key=&quot;userdata_id&quot; length=&quot;&quot; collation=&quot;A&quot; null=&quot;false&quot; /&gt;
        &lt;/index&gt;
&lt;aggregate alias=&quot;User&quot; class=&quot;modUser&quot; local=&quot;userdata_id&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
&lt;/object&gt;
 &lt;/model&gt;
{code}

h5. More Involved Example

Note that the _index=&quot;unique&quot;_ bit has been deprecated -- the index declaration should go into its own node as in the example above.

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent::__construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h4. 4.) Final Step Create a class to access and utilize your extended class

The whole reason for extending a core class is so you could interact with your extended data more easily.  So you

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For the sake of brevity, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:4;a:3:{s:2:"id";s:8:"39355651";s:3:"ver";s:1:"2";s:4:"code";s:14087:"{toc:printable=false}

h2. Intended Audience

This article is for developers who are looking to add additional data to their MODX users.  Although this is possible via a less integrated approach by simply adding a database table that includes a foreign key relation back to the original MODX users table, the approach outlined here is for a more thorough integration via extending the core modUser class.  The steps here are highly technical and they rely on MODX&#39;s underlying xPDO framework.  You should have some familiarity with xPDO&#39;s objects and methods (e.g. [getObject|xPDO20:xPDO.getObject]) before attempting this tutorial.

h3. See Also 

* [Reverse Engineer xPDO Classes from Existing Database Table]
* [xPDO20:More Examples of xPDO XML Schema Files]
* [xPDO20:Generating the Model Code]


h2. Overview

By extending the MODx Revolution authentication layer we can build very complex and varied user subsystems, e.g. for social networking, user management systems, or other applications not yet conceptualized. This ability to extend the modUser class is just one example of how to extend a core class -- a similar approach could be used to extend any MODX core class.

h2. Purpose

Extending modUser is for those situations when user authentication or user interaction need to be extended or enhanced, e.g. for easier custom authentication.


h2. The Rules

Extending modUser does _not_ mean we are adding anything to the _modx_\_users table in the database. Instead, we will be adding a separate related table, bound to the original table via a foreign key.  At no time should an extended application actually attempt to completely replace the modUser Class.  We use the modUser class as our foundation and we build on it. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent::__construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h4. 4.) Final Step Create a class to access and utilize your extended class

The whole reason for extending a core class is so you could interact with your extended data more easily.  So you

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For the sake of brevity, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:5;a:3:{s:2:"id";s:8:"39355649";s:3:"ver";s:1:"2";s:4:"code";s:13903:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication. Also, please understand this is a a simplified working concept.&amp;nbsp; You can get much more complex.




h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for [extension_packages].

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:6;a:3:{s:2:"id";s:8:"39355643";s:3:"ver";s:1:"2";s:4:"code";s:13902:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication. Also, please understand this is a a simplified working concept.&amp;nbsp; You can get much more complex.




h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.

*If the key already exists*, add inside the json array

{code}
,{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}
{code}

*If the key does not exists*

* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
[{&quot;extendeduser&quot;:{&quot;path&quot;:&quot;[[++core_path]]components/extendeduser/model/&quot;}}]
{code}


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:7;a:3:{s:2:"id";s:8:"35095051";s:3:"ver";s:1:"2";s:4:"code";s:13959:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication. Also, please understand this is a a simplified working concept.&amp;nbsp; You can get much more complex.




h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpx extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:8;a:3:{s:2:"id";s:8:"33587355";s:3:"ver";s:1:"2";s:4:"code";s:13956:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication. Also, please understand this is a a simplified working concept.&amp;nbsp; You can get much more complex.




h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need much help. While we may use your extension on \*our\* data, please do not begin writing &quot;bloat&quot; which is simply repeating code already provided in the modUser class.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]





The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]





&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]






h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:9;a:3:{s:2:"id";s:8:"33226815";s:3:"ver";s:1:"2";s:4:"code";s:13914:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication. Also, please understand this is a a simplified working concept.&amp;nbsp; You can get much more complex.




h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need your help. While you may use your extension on \*your\* data, please do not begin writing &quot;bloat&quot; which is already in modUser.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any pre existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# Double check the modx.mysql.schema.xml file to make sure you are not using classes or alias it is already using, as yours will supersede the default moduser prohibiting you access to items such as the user attributes (with alias Profile)
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]




The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]




&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]





h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:10;a:3:{s:2:"id";s:8:"25591811";s:3:"ver";s:1:"1";s:4:"code";s:13667:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication. Also, please understand this is a a simplified working concept.&amp;nbsp; You can get much more complex.




h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.

Your extension should be used to access *your extension*. If the user (object) has not been extended, do not allow your extension to interact with them \-\- hence: let your extension die.

MODx Revolution already handles users and probably does not need your help. While you may use your extension on \*your\* data, please do not begin writing &quot;bloat&quot; which is already in modUser.&amp;nbsp; In other words use the Revolution resources for your extended users, but do not create code to replace modUser.

Lastly, get familiar with [revolution20:modUser], before you begin to code.&amp;nbsp; Some methods are not one-to-one as you might assume, such as attributes, which can be assigned per context, resource, etc. Typically use the modUser suggestions to access modUser methods.



h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]



The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]



&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]




h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:11;a:3:{s:2:"id";s:8:"24346626";s:3:"ver";s:1:"1";s:4:"code";s:12768:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have) use either (any criteria can be added):
{code}
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID));
$this-&gt;modx-&gt;getCount(&#39;extPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]


The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]


&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]



h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:12;a:3:{s:2:"id";s:8:"23658500";s:3:"ver";s:1:"1";s:4:"code";s:12740:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether
# To get counts from your data (i.e. how many phone numbers does this person have, use:
{code}
$this-&gt;modx-&gt;getCount(&#39;utPhones&#39;, array(&#39;user&#39; =&gt; $this-&gt;userID)); 
and return $this-&gt;modx-&gt;getCount(&#39;utPhones&#39;);
{code}

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]

The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]


h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:13;a:3:{s:2:"id";s:8:"23658498";s:3:"ver";s:1:"1";s:4:"code";s:12504:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

The model files can be edited with methods and descriptions. Take a look at much of the MODx / xPDO models and you will see this done extensively.

This process can be automated and captured upon user login. For brevity sake, it is best to refer you to splittingred&#39;s github, where he provides a real world application:

The plugins:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]







The events:[&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php|http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]









&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]










h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:14;a:3:{s:2:"id";s:8:"22806564";s:3:"ver";s:1:"1";s:4:"code";s:12470:"{toc:printable=false}

h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

Can I simple edit the model files and add my methods and descriptions there? Yes.&amp;nbsp; Take a look at much of the MODx / xPDO classes and you will see this done extensively.

Is there a way to automate this process and capture it upon user login?&amp;nbsp; Yes.&amp;nbsp; For brevity sake, it is best to refer you to splittingred&#39;s github:

To handle the plugins: [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]






The events referred to in the plugin:[http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]








&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]









h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:15;a:3:{s:2:"id";s:8:"22806562";s:3:"ver";s:1:"1";s:4:"code";s:12463:"h2.
{toc:printable=false}Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to [Currenty available  extended modUser classes|http://rtfm.modx.com/pages/editpage.action?pageId=22183951#ExtendingmodUser-ExtendedmodUserClassescurrentlyAvailable].




h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

Can I simple edit the model files and add my methods and descriptions there? Yes.&amp;nbsp; Take a look at much of the MODx / xPDO classes and you will see this done extensively.

Is there a way to automate this process and capture it upon user login?&amp;nbsp; Yes.&amp;nbsp; For brevity sake, it is best to refer you to splittingred&#39;s github:

To handle the plugins: [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]





The events referred to in the plugin:[http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]






&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]







h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:16;a:3:{s:2:"id";s:8:"22806560";s:3:"ver";s:1:"1";s:4:"code";s:12274:"
h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to



h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

Can I simple edit the model files and add my methods and descriptions there? Yes.&amp;nbsp; Take a look at much of the MODx / xPDO classes and you will see this done extensively.

Is there a way to automate this process and capture it upon user login?&amp;nbsp; Yes.&amp;nbsp; For brevity sake, it is best to refer you to splittingred&#39;s github:

To handle the plugins: [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]




The events referred to in the plugin:[http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]





&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]






h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:17;a:3:{s:2:"id";s:8:"22806558";s:3:"ver";s:1:"1";s:4:"code";s:12277:"h3.


h2. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with. For fully functional applications please refer to



h2. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h2. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h2. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

Can I simple edit the model files and add my methods and descriptions there? Yes.&amp;nbsp; Take a look at much of the MODx / xPDO classes and you will see this done extensively.

Is there a way to automate this process and capture it upon user login?&amp;nbsp; Yes.&amp;nbsp; For brevity sake, it is best to refer you to splittingred&#39;s github:

To handle the plugins: [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]




The events referred to in the plugin:[http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]




&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]





h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:18;a:3:{s:2:"id";s:8:"22806556";s:3:"ver";s:1:"1";s:4:"code";s:12217:"h3. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with.


h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h3. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;Sampleclass&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

Can I simple edit the model files and add my methods and descriptions there? Yes.&amp;nbsp; Take a look at much of the MODx / xPDO classes and you will see this done extensively.

Is there a way to automate this process and capture it upon user login?&amp;nbsp; Yes.&amp;nbsp; For brevity sake, it is best to refer you to splittingred&#39;s github:

To handle the plugins: [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]



The events referred to in the plugin:[http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]



&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]




h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:19;a:3:{s:2:"id";s:8:"22806553";s:3:"ver";s:1:"1";s:4:"code";s:12215:"h3. Intended Audience

This article attempts to ride the line of beginners desiring to learn the basics of setting up an extended modUser class and those more experienced individuals needing a foundation to begin with.


h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h3. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        sample.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Sampleclass&#39;)) {
    class Sampleclass
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.

h2. Suggested additional considerations

Can I simple edit the model files and add my methods and descriptions there? Yes.&amp;nbsp; Take a look at much of the MODx / xPDO classes and you will see this done extensively.

Is there a way to automate this process and capture it upon user login?&amp;nbsp; Yes.&amp;nbsp; For brevity sake, it is best to refer you to splittingred&#39;s github:

To handle the plugins: [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/plugins/plugin.activedirectory.php]


The events referred to in the plugin:[http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onauthentication.php]


&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [http://github.com/splittingred/modActiveDirectory/blob/master/core/components/activedirectory/elements/events/onusernotfound.php]



h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:20;a:3:{s:2:"id";s:8:"22806551";s:3:"ver";s:1:"9";s:4:"code";s:10626:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.

h3. Purpose

Extending modUser is for those situations when user authentication interaction needs overridden, extended, enhanced, etc.&amp;nbsp; The focus is purely user authentication.



h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.


h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:21;a:3:{s:2:"id";s:8:"22806547";s:3:"ver";s:1:"8";s:4:"code";s:10438:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.


h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.


h2. Extended modUser Classes currently Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:22;a:3:{s:2:"id";s:8:"22806539";s:3:"ver";s:1:"7";s:4:"code";s:10436:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.


h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.


h2. Extended modUser Classes current Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:23;a:3:{s:2:"id";s:8:"22806538";s:3:"ver";s:1:"6";s:4:"code";s:10428:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.


h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

It is completely possible to have multiple extended modUser systems active at the same time.&amp;nbsp; It would even be feasible to extend Jason Coward&#39;s rpx extension into a hybrid system utilizing the benefits of both systems.&amp;nbsp; It is also completely possible to have multiple extended modUser applications running autonomously.&amp;nbsp; This is simply done by following this process for each of your extensions, changing only the &quot;class_key&quot; field to reflect the extended class belonging to each respective user.


h2. Extended Classes current Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:24;a:3:{s:2:"id";s:8:"22806537";s:3:"ver";s:1:"5";s:4:"code";s:9889:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.


h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to [revolution20:Using Custom Database Tables in your 3rd Party Components] for further information.


h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note} 

!systemSettings.png|align=center,border=1!


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

h2. Extended Classes current Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:25;a:3:{s:2:"id";s:8:"22806535";s:3:"ver";s:1:"4";s:4:"code";s:9786:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces&quot; or sub-systems.


h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actually attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon. The only indication that the user has been extended will be found by the class_key being changed from &quot;modUser&quot; to the extended class name.


h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to the documentation for further directions.

h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended. The _modx_\_users table in the database contains a field specifically for this purpose: class_key. The default value in this field is modUser. As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model. The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.




*If the key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}


h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser unless you change it
# The extUser will *not* have a table created in the database, but the attached relations will
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table
# Symptoms of step 3 (extension_packages path) not being correct:
## Any user with the class_key of extUser will return an error upon login: &quot;User cannot be found...&quot;.&amp;nbsp; If this is the admin, access your database directly, return the class_key to modUser, login correctly and then alter the path to a correct representation of the path.
## The snippets attached to the class will intermittently work or fail altogether

h2. Extended Classes current Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:26;a:3:{s:2:"id";s:8:"22806531";s:3:"ver";s:1:"3";s:4:"code";s:9297:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces.&quot;

h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actual attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon.

h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to the documentation for further directions.

h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended.&amp;nbsp; The _modx_\_users table in the database contains a field especially for this purpose: class_key.&amp;nbsp; The default value in this field is modUser.&amp;nbsp; As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model.&amp;nbsp; The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.


If you find that it is not there simply Create New Setting and have it look similar to the following:

 !systemSettings.png|border=1!

*If they key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser
# The extUser will *not* have a table created in the database
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table

h2. Extended Classes current Available

[modActiveDirectory|http://github.com/splittingred/modActiveDirectory] an application which provides interaction with a Microsoft Domain Controller

[rpm extension|http://github.com/opengeek/engaged] allows people to login via Facebook and other social networking medium";}i:27;a:3:{s:2:"id";s:8:"22183957";s:3:"ver";s:1:"2";s:4:"code";s:8986:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces.&quot;

h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actual attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon.

h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to the documentation for further directions.

h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended.&amp;nbsp; The _modx_\_users table in the database contains a field especially for this purpose: class_key.&amp;nbsp; The default value in this field is modUser.&amp;nbsp; As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model.&amp;nbsp; The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.


If you find that it is not there simply Create New Setting and have it look similar to the following:

 !systemSettings.png|border=1!

*If they key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp;
{code}
 extendeduser:{core_path}components/extendeduser/model/
{code}
{note}Note the absence of a comma at the beginning of the Value.{note}

 h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser
# The extUser will *not* have a table created in the database
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table";}i:28;a:3:{s:2:"id";s:8:"22183953";s:3:"ver";s:1:"1";s:4:"code";s:8925:"h3. Overview

By extending the MODx Revolution authentication layer we can simply and easily build very complex and varied user subsystems rivaling that of social networking, user management systems, and other applications not yet conceptualized. This ability to extend the modUser class is just one example of the underlying power of MODx Revolution. By following the steps detailed below you will quickly be on your way to developing your own user &quot;interfaces.&quot;

h3. The Rules

Extending modUser does NOT mean we are adding anything to the _modx_\_users table in the database.&amp;nbsp; It simply means we are going to be appending our own data to the end of the table by attaching our data sets via relationships and a schema. At no time should an extended application actual attempt to completely replace the modUser Class.&amp;nbsp; Instead we should be using it as a platform to build upon.

h2. Steps to extending modUser

h4. 1. ) Create the schema and generate a model

The first thing we need to accomplish, is to create an extended user schema which extends modUser.&amp;nbsp; Please note that there is no aggregate relation upwards from your &quot;main&quot; class which is extending modUser. An example follows:

{code}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;extendeduser&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot; tablePrefix=&quot;ext_&quot;&gt;
    &lt;!-- inherit the modx user and extend it --&gt;
    &lt;object class=&quot;extUser&quot; table=&quot;users&quot; extends=&quot;modUser&quot;&gt;
        &lt;composite alias=&quot;Phones&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
        &lt;composite alias=&quot;Table2&quot; local=&quot;id&quot; foreign=&quot;user&quot; cardinality=&quot;many&quot; owner=&quot;local&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- track all user phone numbers --&gt;
    &lt;object table=&quot;phone_numbers&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;areacode&quot; dbtype=&quot;varchar&quot; precision=&quot;3&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;field key=&quot;number&quot; dbtype=&quot;varchar&quot; precision=&quot;7&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot; /&gt;
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;

    &lt;!-- user extension --&gt;
    &lt;object table=&quot;table2&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;user&quot; dbtype=&quot;int&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; index=&quot;index&quot; /&gt;
        &lt;field key=&quot;myspaceurl&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; /&gt;        
        &lt;aggregate alias=&quot;extUser&quot; local=&quot;user&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot; /&gt;
    &lt;/object&gt;
&lt;/model&gt;
{code}

You will need to parse and create the model map associated with this schema. As this process is out of the scope of this topic, please refer to the documentation for further directions.

h4. 2.) Edit the extuser.class.php

To access the extended class, we have to inform modUser that the user in question has been extended.&amp;nbsp; The _modx_\_users table in the database contains a field especially for this purpose: class_key.&amp;nbsp; The default value in this field is modUser.&amp;nbsp; As users are added to your site using your extension we need to &quot;force&quot; the name of our &quot;main&quot; class in the schema, namely extUser in our example.

Edit the extuser.class.php file created when you generated the model.&amp;nbsp; The specific file is the one found in the top of the model tree (you should see a mysql directory) in this same folder. Edit the file to resemble the following:

{code}
 &lt;?php
/**
 * @package extendeduser
 * @subpackage user.mysql
 */
class extUser extends modUser {
    function __construct(xPDO &amp; $xpdo) {
        parent :: __construct($xpdo);
        $this-&gt;set(&#39;class_key&#39;,&#39;extUser&#39;);
    }
}
?&gt;
{code}

h4. 3.) Create (or edit) _extension_packages in System Settings_

Access the System settings found in the System menu of the manager, and search for: extension_packages.


If you find that it is not there simply Create New Setting and have it look similar to the following:

 !systemSettings.png|border=1!

*If they key already exists*, add


{code}
, extendeduser:{core_path}components/extendeduser/model/
{code}{note}Note the comma at the beginning of the Value. Also leave off the quotes.{note}

*If the key does not exists*


* &amp;nbsp;Create a new system setting with name of extension_packages
* Key of extension_packages
* Fieldtype: Textfield
* value&amp;nbsp; extendeduser:{core_path}components/extendeduser/model/
h4. 4.) Final Step Create a class to access and utilize your extended class

{code}
 &lt;?php
/**
 *  File        extended.class.php (requires MODx Revolution 2.x)
 * Created on    Aug 18, 2010
 * Project        shawn_wilkerson
 * @package     extendedUser
 * @version    1.0
 * @category    User Extension
 * @author        W. Shawn Wilkerson
 * @link        http://www.shawnWilkerson.com
 * @copyright  Copyright (c) 2010, W. Shawn Wilkerson.  All rights reserved.
 * @license      GPL
 *
 */
if (!class_exists(&#39;Extendeduser&#39;)) {
    class Extendeduser
    {
        function __construct(modX &amp; $modx, array $config= array ()) {

            /* Import modx as a reference */
            $this-&gt;modx= &amp; $modx;

            /* Establish the environment */
            $this-&gt;extPath= $modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;;
            $this-&gt;modx-&gt;addPackage(&#39;extendeduser&#39;, $this-&gt;extPath .&#39;model/&#39;, &#39;ut_&#39;);
            $this-&gt;_config= array_merge(array (
                &#39;userID&#39; =&gt; $this-&gt;modx-&gt;user-&gt;get(&#39;id&#39;),
            ), $config);

            /* Define the user */
            $this-&gt;userObj = $this-&gt;setUser($this-&gt;_config[&#39;userID&#39;]);
            $this-&gt;userID = $this-&gt;userObj-&gt;get(&#39;id&#39;);
        }

        function __destruct() {
            unset ($this-&gt;extPath, $this-&gt;userObj, $this-&gt;userID, $this-&gt;_config);
        }

        /**
         * Returns object of type Phone.
         */
        public function getPhoneObj() {
            $this-&gt;userObj-&gt;getOne(&#39;Phones&#39;);
            return $this-&gt;userObj-&gt;Phones;
        }

        /**
         * Returns object utUser instance of modUser Defaults to current user.
         * @param $userID
         */
        public function getUserObj($userID) {
            return $this-&gt;modx-&gt;getObject(&#39;modUser&#39;, $userID);
        }

        /**
         * Establishes the user.
         * @param int $userID
         */
        public function setUser($userID){
            return $this-&gt;getUserObj($userID);
        }
    }
}
{code}

h4. 5.) Accessing the class

In our example we will be accessing our extended user throughout our site, therefore we load it as a service as shown in the following example:

{code}
 &lt;?php
$x = $modx-&gt;getService(&#39;extendeduser&#39;,&#39;ExtendedUser&#39;,$modx-&gt;getOption(&#39;core_path&#39;,null, MODX_CORE_PATH).&#39;components/extendeduser/&#39;,$scriptProperties);
if (!($x instanceof Extendeduser)) {
    $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;[Extendeduser] Could not load Extendeduser class.&#39;);
    $modx-&gt;event-&gt;output(true);
}
return;
{code}

h2. Noteworthy items

# Any existing user, will still have modUser as the class_key and therefore will *not* be extended or produce user objects of type extUser
# The extUser will *not* have a table created in the database
# The extended class table(s) *must* be in the same database as the regular _modx_\_users table";}}}