a:5:{s:2:"id";s:8:"18678076";s:4:"info";a:4:{s:6:"Title:";s:20:"Custom Manager Pages";s:7:"Author:";s:15:"Shaun McCormick";s:16:"Last Changed by:";s:17:"Everett Griffiths";s:12:"Wiki Markup:";s:35:"[revolution20:Custom Manager Pages]";}s:6:"parent";s:8:"18678127";s:6:"source";s:11360:"\\
{toc}

h2. What is a CMP?

CMP stands for Custom Manager Page, and it is simply a custom page that a developer or user can create that can be accessed from within the MODx Revolution manager. It can be used to create custom administration interfaces for 3rd Party Components (Extras/3PCs), or it can simply add functionality to the Revolution core.

{note}In MODx Evolution, CMP&#39;s were handled by *Modules*, but Revolution does not use Modules.{note}

h2. Namespaces

Because CMPs are generated by code on the filesystem, you have to define a path to tell MODx where to look for the custom PHP controllers to load the Custom Manager Page.  These paths are called &#39;Namespaces&#39;, and in case you&#39;re not familiar with MVC nomenclature, the generic term for a script or function which generates a page is a &#39;controller&#39;.  The Manager will search for the controller file in the path defined by the Namespace. How the CMP handles redirection from there on is up to the developer.

h3. Creating a Namespace

You can create a Namespace through System \-&gt; Namespaces. From there, you can give it a name and path. Because the Namespace name is often used as part of a URL, MODx recommends to make the Namespace name lowercase; this helps avoid inconsistent behavior that may occur with some webservers that may handle capitalization differently.

The following window is an example of what information makes up a Namespace:

!namespace-create1.png!

In the path, you can also use placeholders for MODx paths:

* \{core_path\} - Resolves to the *MODX_CORE_PATH*.  This is set in the _/config.core.php_ at the root of the site, often it is _/home/username/modx_location/core/_
* \{base_path\} - Resolves to the *MODX_BASE_PATH*, often _/home/username/modx_location/_

h2. Using modAction and modMenu

Actions (modAction) and Menus (modMenu) work together to allow CMP developers to create Manager pages that directly hook into the default Manager, without hacking the MODx core. modMenu objects are the actual menu items you see on the navigation bar in the Manager. modAction objects tell the menu items _what_ to do, usually in the form of sending a request to a controller file.

h3. Creating the modAction

To create a modAction, go to System \-&gt; Actions. Right-click your Namespace from the &#39;Actions&#39; tree and select &quot;Create Action Here. The following window will show something similar to the following:

!action-create1.png!

There are several noteworthy fields here:
# Controller: This is where you&#39;ll put the name of the controller file to look for. _Make sure to leave off the .php extension_. For example, if in your Namespace path, there is a index.php that you&#39;ll want to use to handle your CMPs, set this field to &#39;index&#39;.
# Namespace: This is the name of the Namespace the new action belongs to. Make sure this is set to the Namespace for your Component.
# Parent Controller: This is currently only for organizational purposes, and poses no programmatic change if set to something else.&amp;nbsp;
# Load Headers: If this is checked, MODx will load the Manager header and footer files. This is recommended unless you want to have a completely separate view for your CMP.
# Language Topics: A comma-separated list of Lexicon Topics to load prior to the page load. They are in the standard [Lexicon|Internationalization] loading format.
# Assets: A placeholder field for whatever you want to put in. It is not currently used in MODx Revolution 2.0.0.

{note}MODx will automatically load for the Action any Lexicon Topics you specify in the &quot;Language Topics&quot; field you put here.{note}

h3. Creating the modMenu

From there, you can create your menu item by right clicking on an already-existing menu item (MODx recommends placing custom CMP&#39;s under &#39;Components&#39;), and clicking &#39;Place Action Here&#39;. This will load a window where you can enter details for the new modMenu:

!menu-create1.png!

There are also several noteworthy fields here:

# Text: The Lexicon Entry key\* that will be the menu item&#39;s displayed value. MODx will automatically load your Namespace&#39;s &quot;default&quot; Lexicon Topic, should it exist; so place your Lexicon Entry in that Topic.
# Description: The Lexicon entry key\* that will be used for the menu item&#39;s description.
# Action: The action that connects your menu to the appropriate connector. Select the modAction you just created.
# Icon: This field is currently not in use in MODx Revolution 2.0.0.
# Parameters: Allows you to specify other GET parameters to be added to the Menu&#39;s href URL should you want to, e.g. *&amp;x=1&amp;y=2*.  Steer clear of the *a* variable and other [Reserved Parameters].  Note that each variable must be prepended with an ampersand (&amp;); this is because the contents of this field will simply be appended to a manager url, e.g. [http://yourdomain.com/manager/index.php?a=65&amp;x=1&amp;y=2]
# Handler: Allows you add a Javascript handler to execute instead of the default page loading action. If this is specified, the Menu will default to that handler and ignore the HREF attribute entirely. Use this if you just want to execute a JavaScript action instead of load a page. See the *System --&gt; Actions* menu and look at the *Site --&gt; Clear Cache* menu item: it uses a handler of &quot;MODx.clearCache(); return false;&quot;
# Permissions: If you&#39;d like to restrict view access to this menu item, you can do so here. Just specify the [Permission|Permissions] name you&#39;d want users to have to have to see this menu item.

{note}The Lexicon Entry you specify for the Text or Description *must* be in the &quot;default&quot; Topic for your Namespace.{note}


h2. Returning the Page

Creating a CMP is very similar to a [Snippet|Snippets]; you&#39;ll just return the page content using the PHP &#39;return&#39; statement. MODx recommends you do not use &#39;echo&#39;, since this will load the page content before the headers have a chance to load.

h3. Smarty

One way to create page content is by the use of [Smarty|http://www.smarty.net|Smarty Homepage] templates. The MODx Manager is powered by Smarty, a templating engine which focuses on making it easy for developers to create their own custom templates. To use a template in the Manager, you simply use the following to output the content of your list.tpl onto the page:

{code}
return $modx-&gt;smarty-&gt;fetch( &#39;/path/to/templates/list.tpl&#39; );
{code}


One common use of Smarty is to assign MODx configuration settings and lexicons to a &quot;placeholder&quot; which can then be used in your templates. For example, in your controller file you might place the following code:

{code}
$modx-&gt;smarty-&gt;assign( &#39;_lang&#39;, $this-&gt;modx-&gt;lexicon-&gt;fetch() );
{code}

$modx-&gt;smarty-&gt;assign() takes two parameters:
# $tplVar \[string\] - The name of the placeholder.
# $value \[string\|array\] - An string or associative array of data (key =&gt; value) to load into the placeholder.

Here&#39;s an example of using placeholders:

{code:html}
&lt;h2 class=&quot;modx-page-header&quot;&gt;{$_lang.mycomponent}&lt;/h2&gt;
{code}

This would output a standard MODx Manager page header with the content of the lexicon matching the &quot;mycomponent&quot; key.

h3. Plain-Old HTML

Of course, you don&#39;t need to use Smarty if you don&#39;t want to. One could simply return the HTML code in their controller, instead of calling $modx-&gt;smarty-&gt;fetch():

{code}
$o = &#39;&lt;div class=&quot;test&quot;&gt;&lt;h2&gt;My Component&lt;/h2&gt;&lt;/div&gt;&#39;;

return $o;
{code}

h3. Scripts and CSS

Since ExtJS plays an important part in the MODx Manager, you will probably need to include your own JavaScript files for your components.

The best way to include a JavaScript file on your page is to use $modx-&gt;regClientStartupScript(). This function takes two parameters:
# $src \[string\] - The path to your JavaScript file, or the content of the script to output.
# $plaintext \[boolean\] - Whether the $src content is a path to a file, or the actual script content. Defaults to false (file path).

You can also output custom CSS files in the same way. Simply use $modx-&gt;regClientCSS(), which accepts a single parameter: the path to your CSS file.

However, you don&#39;t *have* to use ExtJS in your Custom Manager Pages - you can use plain HTML, or another JS framework, if you like. If you do decide to use another JS framework, MODx recommends that you not set &quot;Load Headers&quot; to true on the modAction, since this will load the ExtJS scripts. You&#39;ll need to create your own header file and output that with your normal output.

h2. Brief Overview of MODExt

More info on [MODExt], the ExtJS integration for MODx Revolution, can be found [here|MODExt].

h2. Custom Connectors

A Connector is essentially a PHP file whose main purpose is to provide a connection between an AJAX-based request, and a Processor file. Since Processors are usually involved in CRUD (create, read, update, and delete) operations on a database, they should never be accessed directly. Instead, by using a Connector as a proxy to connect to a Processor, additional authentication and security checks can be performed before allowing access to the Processor.

Unlike Controllers, which are used in the Manager to display an actual page (and belong in your component&#39;s /core/ directory), Connectors must be HTTP-accessible. Therefore, it&#39;s best to place them in your component&#39;s /assets/ directory. Now, let&#39;s take a look at the structure of a Connector file.

The first thing your Connector must do is include the MODx configuration file, as well as the main MODx Connector file.

{code}
&lt;?php
$basePath = dirname( dirname( dirname( dirname( dirname( __FILE__ ) ) ) ) );

require_once $basePath . &#39;/config.core.php&#39;;
require_once MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;;
require_once MODX_CONNECTORS_PATH . &#39;index.php&#39;;
{code}

Next, we simply have to &#39;handle&#39; the, or pass the request data on to the appropriate Processor file.

{code}
$modx-&gt;request-&gt;handleRequest( array(
    &#39;processors_path&#39;   =&gt; $modx-&gt;getOption( &#39;core_path&#39; ) . &#39;components/mycomponent/processors/&#39;,
    &#39;location&#39;          =&gt; &#39;&#39;
) );
?&gt;{code}

As you can see, handleRequest() accepts an array of options:
* processors_path: The base directory where your component&#39;s processor files are found.
* location: The subdirectory of processors_path to find the processor.
* action: This tells MODx the filename of the Processor file to load. This value will be taken from the HTTP $_REQUEST\[&#39;action&#39;\] parameter.

That&#39;s all there is to it\! Your AJAX requests simply need to call your Connector file (with an &#39;action&#39; parameter referring to the appropriate Processor file), and voila \-\- you can now use AJAX requests in your component\!


h2. Conclusion

CMPs allow developers to create custom manager interfaces for their MODx Components without hacking the core. They integrate seamlessly into the core MODx installation, and allow for entire custom applications to be built with MODx technologies.

h2. See Also

{pagetree:root=Custom Manager Pages}

{scrollbar}";s:8:"versions";a:3:{i:0;a:3:{s:2:"id";s:8:"18678076";s:3:"ver";s:1:"3";s:4:"code";s:11360:"\\
{toc}

h2. What is a CMP?

CMP stands for Custom Manager Page, and it is simply a custom page that a developer or user can create that can be accessed from within the MODx Revolution manager. It can be used to create custom administration interfaces for 3rd Party Components (Extras/3PCs), or it can simply add functionality to the Revolution core.

{note}In MODx Evolution, CMP&#39;s were handled by *Modules*, but Revolution does not use Modules.{note}

h2. Namespaces

Because CMPs are generated by code on the filesystem, you have to define a path to tell MODx where to look for the custom PHP controllers to load the Custom Manager Page.  These paths are called &#39;Namespaces&#39;, and in case you&#39;re not familiar with MVC nomenclature, the generic term for a script or function which generates a page is a &#39;controller&#39;.  The Manager will search for the controller file in the path defined by the Namespace. How the CMP handles redirection from there on is up to the developer.

h3. Creating a Namespace

You can create a Namespace through System \-&gt; Namespaces. From there, you can give it a name and path. Because the Namespace name is often used as part of a URL, MODx recommends to make the Namespace name lowercase; this helps avoid inconsistent behavior that may occur with some webservers that may handle capitalization differently.

The following window is an example of what information makes up a Namespace:

!namespace-create1.png!

In the path, you can also use placeholders for MODx paths:

* \{core_path\} - Resolves to the *MODX_CORE_PATH*.  This is set in the _/config.core.php_ at the root of the site, often it is _/home/username/modx_location/core/_
* \{base_path\} - Resolves to the *MODX_BASE_PATH*, often _/home/username/modx_location/_

h2. Using modAction and modMenu

Actions (modAction) and Menus (modMenu) work together to allow CMP developers to create Manager pages that directly hook into the default Manager, without hacking the MODx core. modMenu objects are the actual menu items you see on the navigation bar in the Manager. modAction objects tell the menu items _what_ to do, usually in the form of sending a request to a controller file.

h3. Creating the modAction

To create a modAction, go to System \-&gt; Actions. Right-click your Namespace from the &#39;Actions&#39; tree and select &quot;Create Action Here. The following window will show something similar to the following:

!action-create1.png!

There are several noteworthy fields here:
# Controller: This is where you&#39;ll put the name of the controller file to look for. _Make sure to leave off the .php extension_. For example, if in your Namespace path, there is a index.php that you&#39;ll want to use to handle your CMPs, set this field to &#39;index&#39;.
# Namespace: This is the name of the Namespace the new action belongs to. Make sure this is set to the Namespace for your Component.
# Parent Controller: This is currently only for organizational purposes, and poses no programmatic change if set to something else.&amp;nbsp;
# Load Headers: If this is checked, MODx will load the Manager header and footer files. This is recommended unless you want to have a completely separate view for your CMP.
# Language Topics: A comma-separated list of Lexicon Topics to load prior to the page load. They are in the standard [Lexicon|Internationalization] loading format.
# Assets: A placeholder field for whatever you want to put in. It is not currently used in MODx Revolution 2.0.0.

{note}MODx will automatically load for the Action any Lexicon Topics you specify in the &quot;Language Topics&quot; field you put here.{note}

h3. Creating the modMenu

From there, you can create your menu item by right clicking on an already-existing menu item (MODx recommends placing custom CMP&#39;s under &#39;Components&#39;), and clicking &#39;Place Action Here&#39;. This will load a window where you can enter details for the new modMenu:

!menu-create1.png!

There are also several noteworthy fields here:

# Text: The Lexicon Entry key\* that will be the menu item&#39;s displayed value. MODx will automatically load your Namespace&#39;s &quot;default&quot; Lexicon Topic, should it exist; so place your Lexicon Entry in that Topic.
# Description: The Lexicon entry key\* that will be used for the menu item&#39;s description.
# Action: The action that connects your menu to the appropriate connector. Select the modAction you just created.
# Icon: This field is currently not in use in MODx Revolution 2.0.0.
# Parameters: Allows you to specify other GET parameters to be added to the Menu&#39;s href URL should you want to, e.g. *&amp;x=1&amp;y=2*.  Steer clear of the *a* variable and other [Reserved Parameters].  Note that each variable must be prepended with an ampersand (&amp;); this is because the contents of this field will simply be appended to a manager url, e.g. [http://yourdomain.com/manager/index.php?a=65&amp;x=1&amp;y=2]
# Handler: Allows you add a Javascript handler to execute instead of the default page loading action. If this is specified, the Menu will default to that handler and ignore the HREF attribute entirely. Use this if you just want to execute a JavaScript action instead of load a page. See the *System --&gt; Actions* menu and look at the *Site --&gt; Clear Cache* menu item: it uses a handler of &quot;MODx.clearCache(); return false;&quot;
# Permissions: If you&#39;d like to restrict view access to this menu item, you can do so here. Just specify the [Permission|Permissions] name you&#39;d want users to have to have to see this menu item.

{note}The Lexicon Entry you specify for the Text or Description *must* be in the &quot;default&quot; Topic for your Namespace.{note}


h2. Returning the Page

Creating a CMP is very similar to a [Snippet|Snippets]; you&#39;ll just return the page content using the PHP &#39;return&#39; statement. MODx recommends you do not use &#39;echo&#39;, since this will load the page content before the headers have a chance to load.

h3. Smarty

One way to create page content is by the use of [Smarty|http://www.smarty.net|Smarty Homepage] templates. The MODx Manager is powered by Smarty, a templating engine which focuses on making it easy for developers to create their own custom templates. To use a template in the Manager, you simply use the following to output the content of your list.tpl onto the page:

{code}
return $modx-&gt;smarty-&gt;fetch( &#39;/path/to/templates/list.tpl&#39; );
{code}


One common use of Smarty is to assign MODx configuration settings and lexicons to a &quot;placeholder&quot; which can then be used in your templates. For example, in your controller file you might place the following code:

{code}
$modx-&gt;smarty-&gt;assign( &#39;_lang&#39;, $this-&gt;modx-&gt;lexicon-&gt;fetch() );
{code}

$modx-&gt;smarty-&gt;assign() takes two parameters:
# $tplVar \[string\] - The name of the placeholder.
# $value \[string\|array\] - An string or associative array of data (key =&gt; value) to load into the placeholder.

Here&#39;s an example of using placeholders:

{code:html}
&lt;h2 class=&quot;modx-page-header&quot;&gt;{$_lang.mycomponent}&lt;/h2&gt;
{code}

This would output a standard MODx Manager page header with the content of the lexicon matching the &quot;mycomponent&quot; key.

h3. Plain-Old HTML

Of course, you don&#39;t need to use Smarty if you don&#39;t want to. One could simply return the HTML code in their controller, instead of calling $modx-&gt;smarty-&gt;fetch():

{code}
$o = &#39;&lt;div class=&quot;test&quot;&gt;&lt;h2&gt;My Component&lt;/h2&gt;&lt;/div&gt;&#39;;

return $o;
{code}

h3. Scripts and CSS

Since ExtJS plays an important part in the MODx Manager, you will probably need to include your own JavaScript files for your components.

The best way to include a JavaScript file on your page is to use $modx-&gt;regClientStartupScript(). This function takes two parameters:
# $src \[string\] - The path to your JavaScript file, or the content of the script to output.
# $plaintext \[boolean\] - Whether the $src content is a path to a file, or the actual script content. Defaults to false (file path).

You can also output custom CSS files in the same way. Simply use $modx-&gt;regClientCSS(), which accepts a single parameter: the path to your CSS file.

However, you don&#39;t *have* to use ExtJS in your Custom Manager Pages - you can use plain HTML, or another JS framework, if you like. If you do decide to use another JS framework, MODx recommends that you not set &quot;Load Headers&quot; to true on the modAction, since this will load the ExtJS scripts. You&#39;ll need to create your own header file and output that with your normal output.

h2. Brief Overview of MODExt

More info on [MODExt], the ExtJS integration for MODx Revolution, can be found [here|MODExt].

h2. Custom Connectors

A Connector is essentially a PHP file whose main purpose is to provide a connection between an AJAX-based request, and a Processor file. Since Processors are usually involved in CRUD (create, read, update, and delete) operations on a database, they should never be accessed directly. Instead, by using a Connector as a proxy to connect to a Processor, additional authentication and security checks can be performed before allowing access to the Processor.

Unlike Controllers, which are used in the Manager to display an actual page (and belong in your component&#39;s /core/ directory), Connectors must be HTTP-accessible. Therefore, it&#39;s best to place them in your component&#39;s /assets/ directory. Now, let&#39;s take a look at the structure of a Connector file.

The first thing your Connector must do is include the MODx configuration file, as well as the main MODx Connector file.

{code}
&lt;?php
$basePath = dirname( dirname( dirname( dirname( dirname( __FILE__ ) ) ) ) );

require_once $basePath . &#39;/config.core.php&#39;;
require_once MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;;
require_once MODX_CONNECTORS_PATH . &#39;index.php&#39;;
{code}

Next, we simply have to &#39;handle&#39; the, or pass the request data on to the appropriate Processor file.

{code}
$modx-&gt;request-&gt;handleRequest( array(
    &#39;processors_path&#39;   =&gt; $modx-&gt;getOption( &#39;core_path&#39; ) . &#39;components/mycomponent/processors/&#39;,
    &#39;location&#39;          =&gt; &#39;&#39;
) );
?&gt;{code}

As you can see, handleRequest() accepts an array of options:
* processors_path: The base directory where your component&#39;s processor files are found.
* location: The subdirectory of processors_path to find the processor.
* action: This tells MODx the filename of the Processor file to load. This value will be taken from the HTTP $_REQUEST\[&#39;action&#39;\] parameter.

That&#39;s all there is to it\! Your AJAX requests simply need to call your Connector file (with an &#39;action&#39; parameter referring to the appropriate Processor file), and voila \-\- you can now use AJAX requests in your component\!


h2. Conclusion

CMPs allow developers to create custom manager interfaces for their MODx Components without hacking the core. They integrate seamlessly into the core MODx installation, and allow for entire custom applications to be built with MODx technologies.

h2. See Also

{pagetree:root=Custom Manager Pages}

{scrollbar}";}i:1;a:3:{s:2:"id";s:8:"35586345";s:3:"ver";s:1:"2";s:4:"code";s:11204:"\\
{toc}

h2. What is a CMP?

CMP stands for Custom Manager Page, and it is simply a custom page that a developer or user can create that can be accessed from within the MODx Revolution manager. It can be used to create custom administration interfaces for 3rd Party Components (Extras/3PCs), or it can simply add functionality to the Revolution core.

{note}In MODx Evolution, CMP&#39;s were handled by *Modules*, but Revolution does not use Modules.{note}

h2. Namespaces

Because CMPs are generated by code on the filesystem, you have to define a path to tell MODx where to look for the custom PHP controllers to load the Custom Manager Page.  These paths are called &#39;Namespaces&#39;, and in case you&#39;re not familiar with MVC nomenclature, the generic term for a script or function which generates a page is a &#39;controller&#39;.  The Manager will search for the controller file in the path defined by the Namespace. How the CMP handles redirection from there on is up to the developer.

h3. Creating a Namespace

You can create a Namespace through System \-&gt; Namespaces. From there, you can give it a name and path. Because the Namespace name is often used as part of a URL, MODx recommends to make the Namespace name lowercase; this helps avoid inconsistent behavior that may occur with some webservers that may handle capitalization differently.

The following window is an example of what information makes up a Namespace:

!namespace-create1.png!

In the path, you can also use placeholders for MODx paths:

* \{core_path\} - Resolves to the *MODX_CORE_PATH*.  This is set in the _/config.core.php_ at the root of the site, often it is _/home/username/modx_location/core/_
* \{base_path\} - Resolves to the *MODX_BASE_PATH*, often _/home/username/modx_location/_

h2. Using modAction and modMenu

Actions (modAction) and Menus (modMenu) work together to allow CMP developers to create Manager pages that directly hook into the default Manager, without hacking the MODx core. modMenu objects are the actual menu items you see on the navigation bar in the Manager. modAction objects tell the menu items _what_ to do, usually in the form of sending a request to a controller file.

h3. Creating the modAction

To create a modAction, go to System \-&gt; Actions. Right-click your Namespace from the &#39;Actions&#39; tree and select &quot;Create Action Here. The following window will show something similar to the following:

!action-create1.png!

There are several noteworthy fields here:
# Controller: This is where you&#39;ll put the name of the controller file to look for. _Make sure to leave off the .php extension_. For example, if in your Namespace path, there is a index.php that you&#39;ll want to use to handle your CMPs, set this field to &#39;index&#39;.
# Namespace: This is the name of the Namespace the new action belongs to. Make sure this is set to the Namespace for your Component.
# Parent Controller: This is currently only for organizational purposes, and poses no programmatic change if set to something else.&amp;nbsp;
# Load Headers: If this is checked, MODx will load the Manager header and footer files. This is recommended unless you want to have a completely separate view for your CMP.
# Language Topics: A comma-separated list of Lexicon Topics to load prior to the page load. They are in the standard [Lexicon|Internationalization] loading format.
# Assets: A placeholder field for whatever you want to put in. It is not currently used in MODx Revolution 2.0.0.

{note}MODx will automatically load for the Action any Lexicon Topics you specify in the &quot;Language Topics&quot; field you put here.{note}

h3. Creating the modMenu

From there, you can create your menu item by right clicking on an already-existing menu item (MODx recommends placing custom CMP&#39;s under &#39;Components&#39;), and clicking &#39;Place Action Here&#39;. This will load a window where you can enter details for the new modMenu:

!menu-create1.png!

There are also several noteworthy fields here:

# Text: The Lexicon Entry key\* that will be the menu item&#39;s displayed value. MODx will automatically load your Namespace&#39;s &quot;default&quot; Lexicon Topic, should it exist; so place your Lexicon Entry in that Topic.
# Description: The Lexicon entry key\* that will be used for the menu item&#39;s description.
# Action: The action that connects your menu to the appropriate connector. Select the modAction you just created.
# Icon: This field is currently not in use in MODx Revolution 2.0.0.
# Parameters: Allows you to specify other GET parameters to be added to the Menu&#39;s href URL should you want to, e.g. *&amp;x=1&amp;y=2*.  Steer clear of the *a* variable and other [Reserved Parameters].  Note that each variable must be prepended with an ampersand (&amp;); this is because the contents of this field will simply be appended to a manager url, e.g. [http://yourdomain.com/manager/index.php?a=65&amp;x=1&amp;y=2]
# Handler: Allows you add a Javascript handler to execute instead of the default page loading action. If this is specified, the Menu will default to that handler and ignore the HREF attribute entirely. Use this if you just want to execute a JavaScript action instead of load a page.
# Permissions: If you&#39;d like to restrict view access to this menu item, you can do so here. Just specify the [Permission|Permissions] name you&#39;d want users to have to have to see this menu item.

{note}The Lexicon Entry you specify for the Text or Description *must* be in the &quot;default&quot; Topic for your Namespace.{note}


h2. Returning the Page

Creating a CMP is very similar to a [Snippet|Snippets]; you&#39;ll just return the page content using the PHP &#39;return&#39; statement. MODx recommends you do not use &#39;echo&#39;, since this will load the page content before the headers have a chance to load.

h3. Smarty

One way to create page content is by the use of [Smarty|http://www.smarty.net|Smarty Homepage] templates. The MODx Manager is powered by Smarty, a templating engine which focuses on making it easy for developers to create their own custom templates. To use a template in the Manager, you simply use the following to output the content of your list.tpl onto the page:

{code}
return $modx-&gt;smarty-&gt;fetch( &#39;/path/to/templates/list.tpl&#39; );
{code}


One common use of Smarty is to assign MODx configuration settings and lexicons to a &quot;placeholder&quot; which can then be used in your templates. For example, in your controller file you might place the following code:

{code}
$modx-&gt;smarty-&gt;assign( &#39;_lang&#39;, $this-&gt;modx-&gt;lexicon-&gt;fetch() );
{code}

$modx-&gt;smarty-&gt;assign() takes two parameters:
# $tplVar \[string\] - The name of the placeholder.
# $value \[string\|array\] - An string or associative array of data (key =&gt; value) to load into the placeholder.

Here&#39;s an example of using placeholders:

{code:html}
&lt;h2 class=&quot;modx-page-header&quot;&gt;{$_lang.mycomponent}&lt;/h2&gt;
{code}

This would output a standard MODx Manager page header with the content of the lexicon matching the &quot;mycomponent&quot; key.

h3. Plain-Old HTML

Of course, you don&#39;t need to use Smarty if you don&#39;t want to. One could simply return the HTML code in their controller, instead of calling $modx-&gt;smarty-&gt;fetch():

{code}
$o = &#39;&lt;div class=&quot;test&quot;&gt;&lt;h2&gt;My Component&lt;/h2&gt;&lt;/div&gt;&#39;;

return $o;
{code}

h3. Scripts and CSS

Since ExtJS plays an important part in the MODx Manager, you will probably need to include your own JavaScript files for your components.

The best way to include a JavaScript file on your page is to use $modx-&gt;regClientStartupScript(). This function takes two parameters:
# $src \[string\] - The path to your JavaScript file, or the content of the script to output.
# $plaintext \[boolean\] - Whether the $src content is a path to a file, or the actual script content. Defaults to false (file path).

You can also output custom CSS files in the same way. Simply use $modx-&gt;regClientCSS(), which accepts a single parameter: the path to your CSS file.

However, you don&#39;t *have* to use ExtJS in your Custom Manager Pages - you can use plain HTML, or another JS framework, if you like. If you do decide to use another JS framework, MODx recommends that you not set &quot;Load Headers&quot; to true on the modAction, since this will load the ExtJS scripts. You&#39;ll need to create your own header file and output that with your normal output.

h2. Brief Overview of MODExt

More info on [MODExt], the ExtJS integration for MODx Revolution, can be found [here|MODExt].

h2. Custom Connectors

A Connector is essentially a PHP file whose main purpose is to provide a connection between an AJAX-based request, and a Processor file. Since Processors are usually involved in CRUD (create, read, update, and delete) operations on a database, they should never be accessed directly. Instead, by using a Connector as a proxy to connect to a Processor, additional authentication and security checks can be performed before allowing access to the Processor.

Unlike Controllers, which are used in the Manager to display an actual page (and belong in your component&#39;s /core/ directory), Connectors must be HTTP-accessible. Therefore, it&#39;s best to place them in your component&#39;s /assets/ directory. Now, let&#39;s take a look at the structure of a Connector file.

The first thing your Connector must do is include the MODx configuration file, as well as the main MODx Connector file.

{code}
&lt;?php
$basePath = dirname( dirname( dirname( dirname( dirname( __FILE__ ) ) ) ) );

require_once $basePath . &#39;/config.core.php&#39;;
require_once MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;;
require_once MODX_CONNECTORS_PATH . &#39;index.php&#39;;
{code}

Next, we simply have to &#39;handle&#39; the, or pass the request data on to the appropriate Processor file.

{code}
$modx-&gt;request-&gt;handleRequest( array(
    &#39;processors_path&#39;   =&gt; $modx-&gt;getOption( &#39;core_path&#39; ) . &#39;components/mycomponent/processors/&#39;,
    &#39;location&#39;          =&gt; &#39;&#39;
) );
?&gt;{code}

As you can see, handleRequest() accepts an array of options:
* processors_path: The base directory where your component&#39;s processor files are found.
* location: The subdirectory of processors_path to find the processor.
* action: This tells MODx the filename of the Processor file to load. This value will be taken from the HTTP $_REQUEST\[&#39;action&#39;\] parameter.

That&#39;s all there is to it\! Your AJAX requests simply need to call your Connector file (with an &#39;action&#39; parameter referring to the appropriate Processor file), and voila \-\- you can now use AJAX requests in your component\!


h2. Conclusion

CMPs allow developers to create custom manager interfaces for their MODx Components without hacking the core. They integrate seamlessly into the core MODx installation, and allow for entire custom applications to be built with MODx technologies.

h2. See Also

{pagetree:root=Custom Manager Pages}

{scrollbar}";}i:2;a:3:{s:2:"id";s:8:"22806540";s:3:"ver";s:1:"1";s:4:"code";s:11200:"\\
{toc}

h2. What is a CMP?

CMP stands for Custom Manager Page, and it is simply a custom page that a developer or user can create that can be accessed from within the MODx Revolution manager. It can be used to create custom administration interfaces for 3rd Party Components (Extras/3PCs), or it can simply add functionality to the Revolution core.

{note}In MODx Evolution, CMP&#39;s were handled by *Modules*, but Revolution does not use Modules.{note}

h2. Namespaces
Because CMPs are generated by code on the filesystem, you have to define a path to tell MODx where to look for the custom PHP controllers to load the Custom Manager Page.  These paths are called &#39;Namespaces&#39;, and in case you&#39;re not familiar with MVC nomenclature, the generic term for a script or function which generates a page is a &#39;controller&#39;.  The Manager will search for the controller file in the path defined by the Namespace. How the CMP handles redirection from there on is up to the developer.

h3. Creating a Namespace

You can create a Namespace through System -&gt; Namespaces. From there, you can give it a name and path. Because the Namespace name is often used as part of a URL, MODx recommends to make the Namespace name lowercase; this helps avoid inconsistent behavior that may occur with some webservers that may handle capitalization differently. 

The following window is an example of what information makes up a Namespace:

!namespace-create1.png!

In the path, you can also use placeholders for MODx paths:

* \{core_path\} - Resolves to the *MODX_CORE_PATH*.  This is set in the _/config.core.php_ at the root of the site, often it is _/home/username/modx_location/core/_
* \{base_path\} - Resolves to the *MODX_BASE_PATH*, often _/home/username/modx_location/_

h2. Using modAction and modMenu

Actions (modAction) and Menus (modMenu) work together to allow CMP developers to create Manager pages that directly hook into the default Manager, without hacking the MODx core. modMenu objects are the actual menu items you see on the navigation bar in the Manager. modAction objects tell the menu items _what_ to do, usually in the form of sending a request to a controller file.

h3. Creating the modAction

To create a modAction, go to System \-&gt; Actions. Right-click your Namespace from the &#39;Actions&#39; tree and select &quot;Create Action Here. The following window will show something similar to the following:

!action-create1.png!

There are several noteworthy fields here:
# Controller: This is where you&#39;ll put the name of the controller file to look for. _Make sure to leave off the .php extension_. For example, if in your Namespace path, there is a index.php that you&#39;ll want to use to handle your CMPs, set this field to &#39;index&#39;.
# Namespace: This is the name of the Namespace the new action belongs to. Make sure this is set to the Namespace for your Component.
# Parent Controller: This is currently only for organizational purposes, and poses no programmatic change if set to something else.&amp;nbsp;
# Load Headers: If this is checked, MODx will load the Manager header and footer files. This is recommended unless you want to have a completely separate view for your CMP.
# Language Topics: A comma-separated list of Lexicon Topics to load prior to the page load. They are in the standard [Lexicon|Internationalization] loading format.
# Assets: A placeholder field for whatever you want to put in. It is not currently used in MODx Revolution 2.0.0.

{note}MODx will automatically load for the Action any Lexicon Topics you specify in the &quot;Language Topics&quot; field you put here.{note}

h3. Creating the modMenu

From there, you can create your menu item by right clicking on an already-existing menu item (MODx recommends placing custom CMP&#39;s under &#39;Components&#39;), and clicking &#39;Place Action Here&#39;. This will load a window where you can enter details for the new modMenu:

!menu-create1.png!

There are also several noteworthy fields here:

# Text: The Lexicon Entry key* that will be the menu item&#39;s displayed value. MODx will automatically load your Namespace&#39;s &quot;default&quot; Lexicon Topic, should it exist; so place your Lexicon Entry in that Topic.
# Description: The Lexicon entry key* that will be used for the menu item&#39;s description.
# Action: The action that connects your menu to the appropriate connector. Select the modAction you just created.
# Icon: This field is currently not in use in MODx Revolution 2.0.0.
# Parameters: Allows you to specify other GET parameters to be added to the Menu&#39;s href URL should you want to, e.g. *&amp;x=1&amp;y=2*.  Steer clear of the *a* variable and other [Reserved Parameters].  Note that each variable must be prepended with an ampersand (&amp;); this is because the contents of this field will simply be appended to a manager url, e.g. http://yourdomain.com/manager/index.php?a=65&amp;x=1&amp;y=2
# Handler: Allows you add a Javascript handler to execute instead of the default page loading action. If this is specified, the Menu will default to that handler and ignore the HREF attribute entirely. Use this if you just want to execute a JavaScript action instead of load a page.
# Permissions: If you&#39;d like to restrict view access to this menu item, you can do so here. Just specify the [Permission|Permissions] name you&#39;d want users to have to have to see this menu item.

{note}*The Lexicon Entry you specify for the Text or Description *must* be in the &quot;default&quot; Topic for your Namespace.{note}


h2. Returning the Page

Creating a CMP is very similar to a [Snippet|Snippets]; you&#39;ll just return the page content using the PHP &#39;return&#39; statement. MODx recommends you do not use &#39;echo&#39;, since this will load the page content before the headers have a chance to load.

h3. Smarty

One way to create page content is by the use of [Smarty|http://www.smarty.net|Smarty Homepage] templates. The MODx Manager is powered by Smarty, a templating engine which focuses on making it easy for developers to create their own custom templates. To use a template in the Manager, you simply use the following to output the content of your list.tpl onto the page:

{code}
return $modx-&gt;smarty-&gt;fetch( &#39;/path/to/templates/list.tpl&#39; );
{code}


One common use of Smarty is to assign MODx configuration settings and lexicons to a &quot;placeholder&quot; which can then be used in your templates. For example, in your controller file you might place the following code:

{code}
$modx-&gt;smarty-&gt;assign( &#39;_lang&#39;, $this-&gt;modx-&gt;lexicon-&gt;fetch() );
{code}

$modx-&gt;smarty-&gt;assign() takes two parameters:
# $tplVar \[string\] - The name of the placeholder.
# $value \[string\|array\] - An string or associative array of data (key =&gt; value) to load into the placeholder.

Here&#39;s an example of using placeholders:

{code:html}
&lt;h2 class=&quot;modx-page-header&quot;&gt;{$_lang.mycomponent}&lt;/h2&gt;
{code}

This would output a standard MODx Manager page header with the content of the lexicon matching the &quot;mycomponent&quot; key.

h3. Plain-Old HTML

Of course, you don&#39;t need to use Smarty if you don&#39;t want to. One could simply return the HTML code in their controller, instead of calling $modx-&gt;smarty-&gt;fetch():

{code}
$o = &#39;&lt;div class=&quot;test&quot;&gt;&lt;h2&gt;My Component&lt;/h2&gt;&lt;/div&gt;&#39;;

return $o;
{code}

h3. Scripts and CSS

Since ExtJS plays an important part in the MODx Manager, you will probably need to include your own JavaScript files for your components.

The best way to include a JavaScript file on your page is to use $modx-&gt;regClientStartupScript(). This function takes two parameters:
# $src \[string\] - The path to your JavaScript file, or the content of the script to output.
# $plaintext \[boolean\] - Whether the $src content is a path to a file, or the actual script content. Defaults to false (file path).

You can also output custom CSS files in the same way. Simply use $modx-&gt;regClientCSS(), which accepts a single parameter: the path to your CSS file.

However, you don&#39;t *have* to use ExtJS in your Custom Manager Pages - you can use plain HTML, or another JS framework, if you like. If you do decide to use another JS framework, MODx recommends that you not set &quot;Load Headers&quot; to true on the modAction, since this will load the ExtJS scripts. You&#39;ll need to create your own header file and output that with your normal output.

h2. Brief Overview of MODExt

More info on [MODExt], the ExtJS integration for MODx Revolution, can be found [here|MODExt].

h2. Custom Connectors

A Connector is essentially a PHP file whose main purpose is to provide a connection between an AJAX-based request, and a Processor file. Since Processors are usually involved in CRUD (create, read, update, and delete) operations on a database, they should never be accessed directly. Instead, by using a Connector as a proxy to connect to a Processor, additional authentication and security checks can be performed before allowing access to the Processor.

Unlike Controllers, which are used in the Manager to display an actual page (and belong in your component&#39;s /core/ directory), Connectors must be HTTP-accessible. Therefore, it&#39;s best to place them in your component&#39;s /assets/ directory. Now, let&#39;s take a look at the structure of a Connector file.

The first thing your Connector must do is include the MODx configuration file, as well as the main MODx Connector file.

{code}
&lt;?php
$basePath = dirname( dirname( dirname( dirname( dirname( __FILE__ ) ) ) ) );

require_once $basePath . &#39;/config.core.php&#39;;
require_once MODX_CORE_PATH . &#39;config/&#39; . MODX_CONFIG_KEY . &#39;.inc.php&#39;;
require_once MODX_CONNECTORS_PATH . &#39;index.php&#39;;
{code}

Next, we simply have to &#39;handle&#39; the, or pass the request data on to the appropriate Processor file.

{code}
$modx-&gt;request-&gt;handleRequest( array(
    &#39;processors_path&#39;   =&gt; $modx-&gt;getOption( &#39;core_path&#39; ) . &#39;components/mycomponent/processors/&#39;,
    &#39;location&#39;          =&gt; &#39;&#39;
) );
?&gt;{code}

As you can see, handleRequest() accepts an array of options:
* processors_path: The base directory where your component&#39;s processor files are found.
* location: The subdirectory of processors_path to find the processor.
* action: This tells MODx the filename of the Processor file to load. This value will be taken from the HTTP $_REQUEST\[&#39;action&#39;\] parameter.

That&#39;s all there is to it\! Your AJAX requests simply need to call your Connector file (with an &#39;action&#39; parameter referring to the appropriate Processor file), and voila \-\- you can now use AJAX requests in your component\!


h2. Conclusion

CMPs allow developers to create custom manager interfaces for their MODx Components without hacking the core. They integrate seamlessly into the core MODx installation, and allow for entire custom applications to be built with MODx technologies.

h2. See Also

{pagetree:root=Custom Manager Pages}

{scrollbar}";}}}