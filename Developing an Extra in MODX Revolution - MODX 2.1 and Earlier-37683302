a:5:{s:2:"id";s:8:"37683302";s:4:"info";a:4:{s:6:"Title:";s:61:"Developing an Extra in MODX Revolution - MODX 2.1 and Earlier";s:7:"Author:";s:15:"Shaun McCormick";s:16:"Last Changed by:";s:15:"Shaun McCormick";s:12:"Wiki Markup:";s:76:"[revolution20:Developing an Extra in MODX Revolution - MODX 2.1 and Earlier]";}s:6:"parent";s:8:"37683304";s:6:"source";s:30828:"{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{toc}

h2. Overview

This tutorial is written as a comprehensive example on developing Extras for MODX Revolution - as well as how to setup your Extra to be easily packaged into a Transport Package, as well as able to be developed outside the MODX webroot so that source control (such as Git) can be used.

The overview will be dissecting the &quot;Doodles&quot; Extra, which is a simple Extra that uses a custom table to store objects called &quot;Doodles&quot;, which have a name and a description. We&#39;ll have a Snippet that pulls them and displays a list of them that is templatable via a Chunk, a Custom Manager Page using ExtJS to have a CRUD grid for editing, and a build script for packaging. And we&#39;ll make it all i18n-compatible to allow easy translating. *This is an extremely comprehensive tutorial*, so if you&#39;re wanting only specific parts, use the Table of Contents above.

{note}The Doodles Extra in this tutorial can be found on GitHub, here: https://github.com/splittingred/Doodles/tree/2.1{note}

h2. Setting Up Our Directories

There are many ways that you could start developing your Extra - you could do so straight out of MODX and package it with a packaging tool like [addon:PackMan], or you could alternatively develop it outside of the MODX webroot and put it in a source control system such as [Git|http://github.com/]. This tutorial will be doing the latter method, as it is beneficial for a few reasons:

* Allows immediate development straight from your Git repository
* Allows easy collaboration between developers, as there is no copying files or changing core files - just developing in your preferred IDE and then doing some initial setup on paths.
* Allows isolation of your code to be independent of MODX&#39;s core - so if you need to move it, you can do it in only one place.

Let&#39;s start. I&#39;ve created a directory in my /www/ directory at: /www/doodles/ 

You can do it wherever you want, but for this tutorial I&#39;ll refer to /www/doodles/. Make sure that this directory is *web-accessible* locally, as you&#39;ll need that later on. I have /www/ setup as / on my localhost environment, for example.

{note}You *may* have to add a System Setting in your MODX install called session_cookie_path and give it a value of &quot;/&quot; (no quotations).  This will tell MODX to use the same session when you&#39;re running stuff at http://localhost/doodles/. Also, giving it a unique name via session_cookie_name (like &quot;modxlocaldevsession&quot;) is a good idea too. That&#39;ll prevent conflicts with other MODX installs on your local machine. If you do this, empty the core/cache/ directory and relogin after doing so.{note}

In here, we&#39;ll have quite a few directories:

!doodles-dir-structure.png!

Let&#39;s note a few things. First off, our main 3 directories are core/, assets/ and _build/. Let&#39;s explain a few things about how MODX Extras work - typically (although this does not have to be done), Extras are separated into 2 different directories when installed: core/components/myextra/ and assets/components/myextra/. Why? Well, the assets/components/ directory *only* contains the web-specific assets - JavaScript files, CSS files, etc. These are the files you want publically accessible to the web. All the PHP files, classes, maps, and other files, however, are in the core/components/ directory. This keeps those files secure in the core/ directory (which can be moved outside the webroot in some MODX installations for even more security).

They&#39;re separated into our directory structure here to mimic how they will be in the MODX installation after it&#39;s installed by the Transport Package.

The _build/ directory isn&#39;t even packaged into the zip file after we create a Transport Package for it. It&#39;s there primarily for building the Transport Package. We&#39;ll get into that near the end of the tutorial.

Let&#39;s dive deeper into each subdirectory. In the assets/ directory, the only not-obvious file is the connector.php. This file will allow us to have custom processors for our Custom Manager Page (CMP) we&#39;ll be writing. We&#39;ll get more into that later.

In the core/components/doodles/ directory, we have a few directories worth explaining:

* *controllers* - These are the controllers for our CMP. More on those later.
* *docs* - Just contains a changelog, readme and license file.
* *elements* - All our Snippets, Chunks, Plugins, etc.
* *lexicon* - All our i18n language files. More on those later.
* *model* - Where all of our classes lie, as well as our XML schema file for our custom database tables.
* *processors* - All our custom processors for our CMP.

Let&#39;s also note that this directory is *completely* outside of our MODX webroot (mine&#39;s installed in /www/modx/). So - yes. You can run &quot;git init&quot; and make yourself a Git repository out of the /www/doodles/ directory (or whatever you made it). And you can push that up, without having to worry about it (though there&#39;s a few files we&#39;ll talk about later you&#39;ll want to add to a .gitignore file). 

There we have it. A completely isolated development environment from MODX so that we can do separate development and seamless collaboration. Let&#39;s get further in.

h2. Creating the Doodles Snippet

Okay. Go ahead and create a Snippet file in:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

You&#39;ll have to make a snippets/ directory, if you haven&#39;t already. Your file should be empty, but let&#39;s add a few lines of code:

{code}
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($doodles instanceof Doodles)) return &#39;&#39;;
{code}

Whoa! What&#39;s that? Well, it&#39;s where the magic happens. Let&#39;s break down each part. First off, we have the getService call. It&#39;s shorthand notation right now, so let&#39;s split it up a bit to make it easier to read:

{code}
$defaultDoodlesCorePath = $modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;;
$doodlesCorePath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$defaultDoodlesCorePath);
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);
{code}
Okay, so first off, what is $modx-&gt;getOption? That&#39;s a method that grabs the System Setting with the key (the first parameter). In the first line, we are grabbing a &#39;default&#39; path we are assuming our Doodles core path is going to be, by prefixing the MODX core path to it. It&#39;ll be: /www/modx/core/components/doodles/

Next, we&#39;ll pass that as a fallback value for the next getOption call. This one passes 3 parameters: a key named &quot;doodles.core_path&quot;, null, and our default path var we just assigned. In getOption, the 2nd parameter is an array to search for the key (which we aren&#39;t doing, so we can set it to null), and the 3rd paramter is a default value if the key isn&#39;t found.

So, for right now, our 2nd line will return /www/modx/core/components/doodles/. But that&#39;s not where our Doodles core path is! (hint: it&#39;s at /www/doodles/core/components/doodles). We want to tell these lines to find it there. So what do we do?

h3. Making the Magic Path Settings

We set a couple System Settings (that are specific to our development environment) that tell these lines where to get our files! Go ahead and make the following System Settings and set their values:

* *doodles.core_path* - /www/doodles/core/components/doodles/
* *doodles.assets_url* - /doodles/assets/components/doodles/

If you need to change either of those to reflect your correct paths, such as the URL one, do so. Now our first line will return: /www/doodles/core/components/doodles/ Bingo! Cool, huh?

Why do we do this? Why not just refer to /www/doodles/core/components/doodles/? Well, that wouldn&#39;t work in someone else&#39;s installation. There&#39;s is most likely to be at MODXPATH/core/components/doodles/. Our Transport Package (later) will handle all of that dynamic path stuff, but we want to add an override to allow us to develop Doodles outside of the MODX path. And we just did. Coding bliss!

Now on to the third line:
{code}$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);{code}

Okay, this gets crazy. $modx-&gt;getService loads a class and instantiates an object of it, if it exists, and sets it to $modx-&gt;doodles here in this case (the first parameter passed in). More on getService can be found [here|modX.getService]. But wait! We don&#39;t have a Doodles class! Well, it&#39;s time to make one.

h3. Making the Doodles Base Class

First off, you&#39;re probably asking me why we&#39;re even making this class. Well, it&#39;ll help for a few reasons: we can define some basic paths in it that we&#39;ll use across our custom Extra, and it can also give us some app-wide methods we can use. Trust me, it&#39;s useful. So let&#39;s make it in /www/doodles/core/components/doodles/model/doodles/doodles.class.php:

{code}
class Doodles {
    public $modx;
    public $config = array();
    function __construct(modX &amp;$modx,array $config = array()) {
        $this-&gt;modx =&amp; $modx;

        $basePath = $this-&gt;modx-&gt;getOption(&#39;doodles.core_path&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;);
        $assetsUrl = $this-&gt;modx-&gt;getOption(&#39;doodles.assets_url&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;assets_url&#39;).&#39;components/doodles/&#39;);
        $this-&gt;config = array_merge(array(
            &#39;basePath&#39; =&gt; $basePath,
            &#39;corePath&#39; =&gt; $basePath,
            &#39;modelPath&#39; =&gt; $basePath.&#39;model/&#39;,
            &#39;processorsPath&#39; =&gt; $basePath.&#39;processors/&#39;,
            &#39;chunksPath&#39; =&gt; $basePath.&#39;elements/chunks/&#39;,
            &#39;jsUrl&#39; =&gt; $assetsUrl.&#39;js/&#39;,
            &#39;cssUrl&#39; =&gt; $assetsUrl.&#39;css/&#39;,
            &#39;assetsUrl&#39; =&gt; $assetsUrl,
            &#39;connectorUrl&#39; =&gt; $assetsUrl.&#39;connector.php&#39;,
        ),$config);
        $this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);
    }
}
{code}

Great! It&#39;s pretty simple for now - just creates a class object that has a constructor that sets a reference to the modX object at $doodles-&gt;modx. This is useful later. Also, it populates some basic paths we may use later on into the $doodles-&gt;config array, and it does it with our fancy System Settings trick so we can point it to our /www/doodles/ path!

Now, back to our Snippet. Let&#39;s go ahead and add some default properties to our Snippet, after the lines above, so it looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Cool. Now we want to use [xPDO|xPDO20:Home] to query the database to grab our records...oops. We haven&#39;t made an xPDO model for them yet. We should do that.

h3. Making the Model

xPDO does database abstraction into neat OOP query methods. It currently is beginning to support multiple databases, and it does that by the abstraction of DB queries. Also, it allows you to keep your DB rows in nice, clean classes and do all kinds of neat things in very short lines of code. But to do that, we have to add an xPDO model to our Snippet (via the $modx-&gt;addPackage method). But first we have to build that model, using an xPDO Schema. There&#39;s a [nice long tutorial here|http://rtfm.modx.com/display/xPDO20/Creating+a+Model+With+xPDO] on how to do that, but we&#39;ll go over it fast for now.

Go ahead and make a xml file in /www/doodles/core/components/doodles/model/schema/doodles.mysql.schema.xml. Put this in it:

{code}&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;
    &lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
        &lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;

        &lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
        &lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;

        &lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
        &lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
    &lt;/object&gt;
&lt;/model&gt;{code}

Ooookay. Lots of stuff here. First off, the first line:

{code}&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;{code}

This tells the schema that our xPDO package is called &#39;doodles&#39;. This is what we&#39;ll refer to in our addPackage() call. Great. It also says the base class for all the objects defined here is &quot;xPDOObject&quot;, and that this schema is made for MySQL. Finally, it gives a default MySQL engine of MyISAM. Next!

{code}&lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;{code}
An &quot;object&quot; in a xPDO schema is basically a database table. This line says, give xPDO a name for the table called &#39;\{table_prefix\}_doodles&#39;. Assuming your table prefix you did in your MODX install is &#39;modx_&#39;, it would translate to &#39;modx_doodles&#39;. Then it says that it extends &quot;xPDOSimpleObject&quot;. What&#39;s that? Well, xPDOObject is the base object for any xPDO table class. xPDOSimpleObject extends it, but adds a nice little &quot;id&quot; auto-increment field to that table. So, since we&#39;re gonna want a &quot;id&quot; field on our table, we use xPDOSimpleObject.

{code}&lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
&lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;{code}

The rest of these fields are pretty self-explanatory - they are fields on the DB table. Let&#39;s move on to the last two parts:

{code}&lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
&lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;{code}

Okay, this is where related objects come in with xPDO. For the purposes of this tutorial, just know that this tells xPDO that the createdby field maps to a modUser, and the editedby field maps to another modUser. Cool? Now let&#39;s get into parsing that xml file and creating our classes and maps.

h3. The Schema Parsing Script

Now it&#39;s time to look at our elusive _build directory. Go ahead and create a file in there: /www/doodles/_build/build.schema.php and put this in:

{code}
&lt;?php
require_once dirname(__FILE__).&#39;/build.config.php&#39;;
include_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;
$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;model&#39; =&gt; $root.&#39;core/components/doodles/model/&#39;,
    &#39;schema_file&#39; =&gt; $root.&#39;core/components/doodles/model/schema/doodles.mysql.schema.xml&#39;,
);
$manager= $modx-&gt;getManager();
$generator= $manager-&gt;getGenerator();

if (!is_dir($sources[&#39;model&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Model directory not found!&#39;); die(); }
if (!file_exists($sources[&#39;schema_file&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Schema file not found!&#39;); die(); }
$generator-&gt;parseSchema($sources[&#39;schema_file&#39;],$sources[&#39;model&#39;]);

echo &#39;Done.&#39;;
exit();
{code}

Basically this file parses your XML schema file and makes xPDO classes and maps (PHP representations of that XML file) for your component. We&#39;ll come back to this, but first off, it&#39;s not gonna run. It&#39;s gonna die on looking for a /www/doodles/_build/build.config.php file. Time to make one of those!

{code}
&lt;?php
define(&#39;MODX_BASE_PATH&#39;, &#39;/www/modx/&#39;);
define(&#39;MODX_CORE_PATH&#39;, MODX_BASE_PATH . &#39;core/&#39;);
define(&#39;MODX_MANAGER_PATH&#39;, MODX_BASE_PATH . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_PATH&#39;, MODX_BASE_PATH . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_PATH&#39;, MODX_BASE_PATH . &#39;assets/&#39;);

define(&#39;MODX_BASE_URL&#39;,&#39;/modx/&#39;);
define(&#39;MODX_CORE_URL&#39;, MODX_BASE_URL . &#39;core/&#39;);
define(&#39;MODX_MANAGER_URL&#39;, MODX_BASE_URL . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_URL&#39;, MODX_BASE_URL . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_URL&#39;, MODX_BASE_URL . &#39;assets/&#39;);
{code}

Obviously, you may need to change those paths to wherever your MODX installation is at.

Now, you can go to your _build/build.schema.php file, and run it. I do it by loading up in a web browser: http://localhost/doodles/_build/build.schema.php. You may need to change that URL to wherever you made the doodles directory web-accessible (you did like I said to earlier, didn&#39;t you? If not, now&#39;s a good time!).

That should run and generate you some nice pretty class files and maps:

!doodles-maps.png!

Bravo! You&#39;ve just made your maps and classes. Let&#39;s go make an adjustment to our Doodles base class, so it automatically adds in the Doodles xPDO package whenever we load the class. Add this line after the $this-&gt;config = array_merge part, at the end of the constructor:

{code}$this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);{code}

This tells xPDO that we want to add the &#39;doodles&#39; xPDO package in, allowing us to query that custom table. Bravo!

Okay, our Snippet so far looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Pretty lame snippet, eh? Well, all we&#39;re doing right now is setting up the Doodles class object into a variable called $dood, and setting up some defaults for properties we&#39;ll use later. $scriptProperties is an array, by the way, of all the properties passed into the Snippet. The getOption calls here parse it to find the properties in them, and if not set, gives them default values.

h3. The include Snippet

You&#39;re probably also thinking, &quot;It&#39;s not even in the MODX manager yet! Who is this guy and who does he think he&#39;s kidding?&quot; Good question. Well, let&#39;s do that then!

Now, to preserve our custom System Setting-based paths we did earlier, we&#39;re not going to want to actually create a Doodles snippet in our manager, and paste its code in there. That&#39;d make it pretty annoying to develop - lots of copy+paste, etc. So, we&#39;re going to make a generic &quot;include&quot; snippet that looks like this:

{code}
$o = include $file;
return $o;
{code}

That&#39;s it. Seriously. Now, create a Resource called &quot;Doodles&quot; with an alias of &quot;doodles&quot; in your MODX install and put this in it:

{code}[[!include? &amp;file=`[[++doodles.core_path]]elements/snippets/snippet.doodles.php`]]{code}

This says, &quot;Include and run the file in the Doodles core path System Setting we set at earlier, plus concatenate to the end of that path &#39;elements/snippets/snippet.doodles.php&#39;&quot;. That&#39;ll resolve to:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

Which works perfect for us! Then we can edit our Snippet in our favorite IDE and go about our business. It&#39;ll also pass any properties we pass into the include snippet call into our Doodles snippet as well. Cool! Back to the Snippet.

h3. Building the Query

First off, we need to create the table. This will be done in a resolver later, but for now, just add this to your snippet, before the return statement:

{code}$m = $modx-&gt;getManager();
$created = $m-&gt;createObjectContainer(&#39;Doodle&#39;);
return $created ? &#39;Table created.&#39; : &#39;Table not created.&#39;;{code}

Then go ahead and run your snippet. This will automatically create the DB table that we made in our schema. Now that you&#39;ve got that done, remove that code and we can continue on.

Okay, let&#39;s add this to our Snippet before the return statement:

{code}$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;);
$output = count($doodles);{code}

That&#39;s going to grab an array of Doodle objects, or in non-xPDO terms, a bunch of rows from the database. Go ahead and save your snippet, then run it in the browser at http://localhost/modx/doodles.html (or wherever the Resource was). You should get this:

{quote}0{quote}

Ha, tricked you! In reality, the first time it runs it wont grab anything, since we don&#39;t have any data in the table. Let&#39;s go put some data in the table.

Use whatever DB editing software (such as phpMyAdmin) you want, and find the &#39;modx_doodles&#39; table in your database. Add a few rows to it (just add name/description values for now). That should give you some data. Let&#39;s assume you added 2 rows. Go ahead and run your snippet, and you should get:

{quote}2{quote}

Great! Your custom database query works! Let&#39;s make it more complex. We can use xPDO&#39;s [xPDOQuery|xPDO20:xPDOQuery] to create some pretty complex queries. For now, let&#39;s just add a sort command to it:

{code}
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);
{code}

Great. That will sort it by the field in $sort (which we defined above) and the direction in $dir. Now we need to actually create some output for it. Let&#39;s do it!

h3. The Doodles class getChunk Method

In a lot of my Extras, I add a couple of helper methods to my base class called getChunk. What they allow me to do is use file-based chunks to develop in. So, let&#39;s do that. Go ahead and open up your Doodles class and add these two methods in:

{code}
    public function getChunk($name,$properties = array()) {
        $chunk = null;
        if (!isset($this-&gt;chunks[$name])) {
            $chunk = $this-&gt;_getTplChunk($name);
            if (empty($chunk)) {
                $chunk = $this-&gt;modx-&gt;getObject(&#39;modChunk&#39;,array(&#39;name&#39; =&gt; $name));
                if ($chunk == false) return false;
            }
            $this-&gt;chunks[$name] = $chunk-&gt;getContent();
        } else {
            $o = $this-&gt;chunks[$name];
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;setContent($o);
        }
        $chunk-&gt;setCacheable(false);
        return $chunk-&gt;process($properties);
    }

    private function _getTplChunk($name,$postfix = &#39;.chunk.tpl&#39;) {
        $chunk = false;
        $f = $this-&gt;config[&#39;chunksPath&#39;].strtolower($name).$postfix;
        if (file_exists($f)) {
            $o = file_get_contents($f);
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;set(&#39;name&#39;,$name);
            $chunk-&gt;setContent($o);
        }
        return $chunk;
    }{code}

For now, all you need to know is that these methods will look for Chunks in your /www/doodles/core/components/doodles/elements/chunks/ directory, postfixed with &#39;.chunk.tpl&#39; and all in lowercase. If it doesn&#39;t find them on the filesystem, it looks for them in MODX. So, if we called:

{code}$o = $dood-&gt;getChunk(&#39;hello&#39;,array(&#39;name&#39; =&gt; &#39;Joe&#39;));{code}
It would set to $o the contents of /www/doodles/core/components/doodles/elements/chunks/hello.chunk.tpl, with the property \[\[+name\]\] parsed as Joe. This will allow you to edit your Chunks in your IDE, rather than in MODX. It will also allow you to package your Extra without installing default chunks into the user&#39;s MODX install (which they would be tempted to overwrite, which would get erased in upgrades of your Extra).

So, back to our snippet. Create a Chunk file in /www/doodles/core/components/doodles/elements/chunks/rowtpl.chunk.tpl, and put this inside:

{code}&lt;li&gt;&lt;strong&gt;[[+name]]&lt;/strong&gt; - [[+description]]&lt;/li&gt;{code}

Now add this below your query but above the return line in your Snippet:

{code}
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}{code}

So, what this does is iterates over all the Doodle objects we got with the getCollection call, and creates a PHP array from their values with the toArray method. Then, it uses getChunk and that array to set values to the Chunk for each row, and append that to the $output variable. So we get a bunch of \&lt;li\&gt; tags (as many as you added rows in the DB for). It should look something like this:

!doodleoutput1.png!

Cool, huh? You can obviously change that Chunk to whatever you want - and people can pass in a name of a Chunk to &amp;tpl in their Snippet call to use whatever Chunk they want. Templatability in your Snippet! Hooray!

So let&#39;s recap. Our snippet looks like this:

{code}&lt;?php
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

/* build query */
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);

/* iterate */
$output = &#39;&#39;;
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}

return $output;{code}

And we&#39;ve got it loading our custom base class from our System Setting-defined paths, adding our custom xPDO db package, pulling from our custom database table, and outputting it via a Chunk. Cool,  huh?

h2. Summary

We&#39;ve got ourselves a nice custom database model, which our Doodles Snippet using to grab Doodles records from our database. We also have looked at the basic structure for a comprehensive MODX Extra.

But we&#39;re gonna want some way of editing that data in the MODX manager, right? Well, that&#39;s where Custom Manager Pages (CMPs) come in. Go on and proceed to the [next part of this tutorial|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier].

{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{scrollbar}";s:8:"versions";a:3:{i:0;a:3:{s:2:"id";s:8:"37683302";s:3:"ver";s:1:"3";s:4:"code";s:30828:"{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{toc}

h2. Overview

This tutorial is written as a comprehensive example on developing Extras for MODX Revolution - as well as how to setup your Extra to be easily packaged into a Transport Package, as well as able to be developed outside the MODX webroot so that source control (such as Git) can be used.

The overview will be dissecting the &quot;Doodles&quot; Extra, which is a simple Extra that uses a custom table to store objects called &quot;Doodles&quot;, which have a name and a description. We&#39;ll have a Snippet that pulls them and displays a list of them that is templatable via a Chunk, a Custom Manager Page using ExtJS to have a CRUD grid for editing, and a build script for packaging. And we&#39;ll make it all i18n-compatible to allow easy translating. *This is an extremely comprehensive tutorial*, so if you&#39;re wanting only specific parts, use the Table of Contents above.

{note}The Doodles Extra in this tutorial can be found on GitHub, here: https://github.com/splittingred/Doodles/tree/2.1{note}

h2. Setting Up Our Directories

There are many ways that you could start developing your Extra - you could do so straight out of MODX and package it with a packaging tool like [addon:PackMan], or you could alternatively develop it outside of the MODX webroot and put it in a source control system such as [Git|http://github.com/]. This tutorial will be doing the latter method, as it is beneficial for a few reasons:

* Allows immediate development straight from your Git repository
* Allows easy collaboration between developers, as there is no copying files or changing core files - just developing in your preferred IDE and then doing some initial setup on paths.
* Allows isolation of your code to be independent of MODX&#39;s core - so if you need to move it, you can do it in only one place.

Let&#39;s start. I&#39;ve created a directory in my /www/ directory at: /www/doodles/ 

You can do it wherever you want, but for this tutorial I&#39;ll refer to /www/doodles/. Make sure that this directory is *web-accessible* locally, as you&#39;ll need that later on. I have /www/ setup as / on my localhost environment, for example.

{note}You *may* have to add a System Setting in your MODX install called session_cookie_path and give it a value of &quot;/&quot; (no quotations).  This will tell MODX to use the same session when you&#39;re running stuff at http://localhost/doodles/. Also, giving it a unique name via session_cookie_name (like &quot;modxlocaldevsession&quot;) is a good idea too. That&#39;ll prevent conflicts with other MODX installs on your local machine. If you do this, empty the core/cache/ directory and relogin after doing so.{note}

In here, we&#39;ll have quite a few directories:

!doodles-dir-structure.png!

Let&#39;s note a few things. First off, our main 3 directories are core/, assets/ and _build/. Let&#39;s explain a few things about how MODX Extras work - typically (although this does not have to be done), Extras are separated into 2 different directories when installed: core/components/myextra/ and assets/components/myextra/. Why? Well, the assets/components/ directory *only* contains the web-specific assets - JavaScript files, CSS files, etc. These are the files you want publically accessible to the web. All the PHP files, classes, maps, and other files, however, are in the core/components/ directory. This keeps those files secure in the core/ directory (which can be moved outside the webroot in some MODX installations for even more security).

They&#39;re separated into our directory structure here to mimic how they will be in the MODX installation after it&#39;s installed by the Transport Package.

The _build/ directory isn&#39;t even packaged into the zip file after we create a Transport Package for it. It&#39;s there primarily for building the Transport Package. We&#39;ll get into that near the end of the tutorial.

Let&#39;s dive deeper into each subdirectory. In the assets/ directory, the only not-obvious file is the connector.php. This file will allow us to have custom processors for our Custom Manager Page (CMP) we&#39;ll be writing. We&#39;ll get more into that later.

In the core/components/doodles/ directory, we have a few directories worth explaining:

* *controllers* - These are the controllers for our CMP. More on those later.
* *docs* - Just contains a changelog, readme and license file.
* *elements* - All our Snippets, Chunks, Plugins, etc.
* *lexicon* - All our i18n language files. More on those later.
* *model* - Where all of our classes lie, as well as our XML schema file for our custom database tables.
* *processors* - All our custom processors for our CMP.

Let&#39;s also note that this directory is *completely* outside of our MODX webroot (mine&#39;s installed in /www/modx/). So - yes. You can run &quot;git init&quot; and make yourself a Git repository out of the /www/doodles/ directory (or whatever you made it). And you can push that up, without having to worry about it (though there&#39;s a few files we&#39;ll talk about later you&#39;ll want to add to a .gitignore file). 

There we have it. A completely isolated development environment from MODX so that we can do separate development and seamless collaboration. Let&#39;s get further in.

h2. Creating the Doodles Snippet

Okay. Go ahead and create a Snippet file in:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

You&#39;ll have to make a snippets/ directory, if you haven&#39;t already. Your file should be empty, but let&#39;s add a few lines of code:

{code}
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($doodles instanceof Doodles)) return &#39;&#39;;
{code}

Whoa! What&#39;s that? Well, it&#39;s where the magic happens. Let&#39;s break down each part. First off, we have the getService call. It&#39;s shorthand notation right now, so let&#39;s split it up a bit to make it easier to read:

{code}
$defaultDoodlesCorePath = $modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;;
$doodlesCorePath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$defaultDoodlesCorePath);
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);
{code}
Okay, so first off, what is $modx-&gt;getOption? That&#39;s a method that grabs the System Setting with the key (the first parameter). In the first line, we are grabbing a &#39;default&#39; path we are assuming our Doodles core path is going to be, by prefixing the MODX core path to it. It&#39;ll be: /www/modx/core/components/doodles/

Next, we&#39;ll pass that as a fallback value for the next getOption call. This one passes 3 parameters: a key named &quot;doodles.core_path&quot;, null, and our default path var we just assigned. In getOption, the 2nd parameter is an array to search for the key (which we aren&#39;t doing, so we can set it to null), and the 3rd paramter is a default value if the key isn&#39;t found.

So, for right now, our 2nd line will return /www/modx/core/components/doodles/. But that&#39;s not where our Doodles core path is! (hint: it&#39;s at /www/doodles/core/components/doodles). We want to tell these lines to find it there. So what do we do?

h3. Making the Magic Path Settings

We set a couple System Settings (that are specific to our development environment) that tell these lines where to get our files! Go ahead and make the following System Settings and set their values:

* *doodles.core_path* - /www/doodles/core/components/doodles/
* *doodles.assets_url* - /doodles/assets/components/doodles/

If you need to change either of those to reflect your correct paths, such as the URL one, do so. Now our first line will return: /www/doodles/core/components/doodles/ Bingo! Cool, huh?

Why do we do this? Why not just refer to /www/doodles/core/components/doodles/? Well, that wouldn&#39;t work in someone else&#39;s installation. There&#39;s is most likely to be at MODXPATH/core/components/doodles/. Our Transport Package (later) will handle all of that dynamic path stuff, but we want to add an override to allow us to develop Doodles outside of the MODX path. And we just did. Coding bliss!

Now on to the third line:
{code}$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);{code}

Okay, this gets crazy. $modx-&gt;getService loads a class and instantiates an object of it, if it exists, and sets it to $modx-&gt;doodles here in this case (the first parameter passed in). More on getService can be found [here|modX.getService]. But wait! We don&#39;t have a Doodles class! Well, it&#39;s time to make one.

h3. Making the Doodles Base Class

First off, you&#39;re probably asking me why we&#39;re even making this class. Well, it&#39;ll help for a few reasons: we can define some basic paths in it that we&#39;ll use across our custom Extra, and it can also give us some app-wide methods we can use. Trust me, it&#39;s useful. So let&#39;s make it in /www/doodles/core/components/doodles/model/doodles/doodles.class.php:

{code}
class Doodles {
    public $modx;
    public $config = array();
    function __construct(modX &amp;$modx,array $config = array()) {
        $this-&gt;modx =&amp; $modx;

        $basePath = $this-&gt;modx-&gt;getOption(&#39;doodles.core_path&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;);
        $assetsUrl = $this-&gt;modx-&gt;getOption(&#39;doodles.assets_url&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;assets_url&#39;).&#39;components/doodles/&#39;);
        $this-&gt;config = array_merge(array(
            &#39;basePath&#39; =&gt; $basePath,
            &#39;corePath&#39; =&gt; $basePath,
            &#39;modelPath&#39; =&gt; $basePath.&#39;model/&#39;,
            &#39;processorsPath&#39; =&gt; $basePath.&#39;processors/&#39;,
            &#39;chunksPath&#39; =&gt; $basePath.&#39;elements/chunks/&#39;,
            &#39;jsUrl&#39; =&gt; $assetsUrl.&#39;js/&#39;,
            &#39;cssUrl&#39; =&gt; $assetsUrl.&#39;css/&#39;,
            &#39;assetsUrl&#39; =&gt; $assetsUrl,
            &#39;connectorUrl&#39; =&gt; $assetsUrl.&#39;connector.php&#39;,
        ),$config);
        $this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);
    }
}
{code}

Great! It&#39;s pretty simple for now - just creates a class object that has a constructor that sets a reference to the modX object at $doodles-&gt;modx. This is useful later. Also, it populates some basic paths we may use later on into the $doodles-&gt;config array, and it does it with our fancy System Settings trick so we can point it to our /www/doodles/ path!

Now, back to our Snippet. Let&#39;s go ahead and add some default properties to our Snippet, after the lines above, so it looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Cool. Now we want to use [xPDO|xPDO20:Home] to query the database to grab our records...oops. We haven&#39;t made an xPDO model for them yet. We should do that.

h3. Making the Model

xPDO does database abstraction into neat OOP query methods. It currently is beginning to support multiple databases, and it does that by the abstraction of DB queries. Also, it allows you to keep your DB rows in nice, clean classes and do all kinds of neat things in very short lines of code. But to do that, we have to add an xPDO model to our Snippet (via the $modx-&gt;addPackage method). But first we have to build that model, using an xPDO Schema. There&#39;s a [nice long tutorial here|http://rtfm.modx.com/display/xPDO20/Creating+a+Model+With+xPDO] on how to do that, but we&#39;ll go over it fast for now.

Go ahead and make a xml file in /www/doodles/core/components/doodles/model/schema/doodles.mysql.schema.xml. Put this in it:

{code}&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;
    &lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
        &lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;

        &lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
        &lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;

        &lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
        &lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
    &lt;/object&gt;
&lt;/model&gt;{code}

Ooookay. Lots of stuff here. First off, the first line:

{code}&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;{code}

This tells the schema that our xPDO package is called &#39;doodles&#39;. This is what we&#39;ll refer to in our addPackage() call. Great. It also says the base class for all the objects defined here is &quot;xPDOObject&quot;, and that this schema is made for MySQL. Finally, it gives a default MySQL engine of MyISAM. Next!

{code}&lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;{code}
An &quot;object&quot; in a xPDO schema is basically a database table. This line says, give xPDO a name for the table called &#39;\{table_prefix\}_doodles&#39;. Assuming your table prefix you did in your MODX install is &#39;modx_&#39;, it would translate to &#39;modx_doodles&#39;. Then it says that it extends &quot;xPDOSimpleObject&quot;. What&#39;s that? Well, xPDOObject is the base object for any xPDO table class. xPDOSimpleObject extends it, but adds a nice little &quot;id&quot; auto-increment field to that table. So, since we&#39;re gonna want a &quot;id&quot; field on our table, we use xPDOSimpleObject.

{code}&lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
&lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;{code}

The rest of these fields are pretty self-explanatory - they are fields on the DB table. Let&#39;s move on to the last two parts:

{code}&lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
&lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;{code}

Okay, this is where related objects come in with xPDO. For the purposes of this tutorial, just know that this tells xPDO that the createdby field maps to a modUser, and the editedby field maps to another modUser. Cool? Now let&#39;s get into parsing that xml file and creating our classes and maps.

h3. The Schema Parsing Script

Now it&#39;s time to look at our elusive _build directory. Go ahead and create a file in there: /www/doodles/_build/build.schema.php and put this in:

{code}
&lt;?php
require_once dirname(__FILE__).&#39;/build.config.php&#39;;
include_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;
$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;model&#39; =&gt; $root.&#39;core/components/doodles/model/&#39;,
    &#39;schema_file&#39; =&gt; $root.&#39;core/components/doodles/model/schema/doodles.mysql.schema.xml&#39;,
);
$manager= $modx-&gt;getManager();
$generator= $manager-&gt;getGenerator();

if (!is_dir($sources[&#39;model&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Model directory not found!&#39;); die(); }
if (!file_exists($sources[&#39;schema_file&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Schema file not found!&#39;); die(); }
$generator-&gt;parseSchema($sources[&#39;schema_file&#39;],$sources[&#39;model&#39;]);

echo &#39;Done.&#39;;
exit();
{code}

Basically this file parses your XML schema file and makes xPDO classes and maps (PHP representations of that XML file) for your component. We&#39;ll come back to this, but first off, it&#39;s not gonna run. It&#39;s gonna die on looking for a /www/doodles/_build/build.config.php file. Time to make one of those!

{code}
&lt;?php
define(&#39;MODX_BASE_PATH&#39;, &#39;/www/modx/&#39;);
define(&#39;MODX_CORE_PATH&#39;, MODX_BASE_PATH . &#39;core/&#39;);
define(&#39;MODX_MANAGER_PATH&#39;, MODX_BASE_PATH . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_PATH&#39;, MODX_BASE_PATH . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_PATH&#39;, MODX_BASE_PATH . &#39;assets/&#39;);

define(&#39;MODX_BASE_URL&#39;,&#39;/modx/&#39;);
define(&#39;MODX_CORE_URL&#39;, MODX_BASE_URL . &#39;core/&#39;);
define(&#39;MODX_MANAGER_URL&#39;, MODX_BASE_URL . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_URL&#39;, MODX_BASE_URL . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_URL&#39;, MODX_BASE_URL . &#39;assets/&#39;);
{code}

Obviously, you may need to change those paths to wherever your MODX installation is at.

Now, you can go to your _build/build.schema.php file, and run it. I do it by loading up in a web browser: http://localhost/doodles/_build/build.schema.php. You may need to change that URL to wherever you made the doodles directory web-accessible (you did like I said to earlier, didn&#39;t you? If not, now&#39;s a good time!).

That should run and generate you some nice pretty class files and maps:

!doodles-maps.png!

Bravo! You&#39;ve just made your maps and classes. Let&#39;s go make an adjustment to our Doodles base class, so it automatically adds in the Doodles xPDO package whenever we load the class. Add this line after the $this-&gt;config = array_merge part, at the end of the constructor:

{code}$this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);{code}

This tells xPDO that we want to add the &#39;doodles&#39; xPDO package in, allowing us to query that custom table. Bravo!

Okay, our Snippet so far looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Pretty lame snippet, eh? Well, all we&#39;re doing right now is setting up the Doodles class object into a variable called $dood, and setting up some defaults for properties we&#39;ll use later. $scriptProperties is an array, by the way, of all the properties passed into the Snippet. The getOption calls here parse it to find the properties in them, and if not set, gives them default values.

h3. The include Snippet

You&#39;re probably also thinking, &quot;It&#39;s not even in the MODX manager yet! Who is this guy and who does he think he&#39;s kidding?&quot; Good question. Well, let&#39;s do that then!

Now, to preserve our custom System Setting-based paths we did earlier, we&#39;re not going to want to actually create a Doodles snippet in our manager, and paste its code in there. That&#39;d make it pretty annoying to develop - lots of copy+paste, etc. So, we&#39;re going to make a generic &quot;include&quot; snippet that looks like this:

{code}
$o = include $file;
return $o;
{code}

That&#39;s it. Seriously. Now, create a Resource called &quot;Doodles&quot; with an alias of &quot;doodles&quot; in your MODX install and put this in it:

{code}[[!include? &amp;file=`[[++doodles.core_path]]elements/snippets/snippet.doodles.php`]]{code}

This says, &quot;Include and run the file in the Doodles core path System Setting we set at earlier, plus concatenate to the end of that path &#39;elements/snippets/snippet.doodles.php&#39;&quot;. That&#39;ll resolve to:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

Which works perfect for us! Then we can edit our Snippet in our favorite IDE and go about our business. It&#39;ll also pass any properties we pass into the include snippet call into our Doodles snippet as well. Cool! Back to the Snippet.

h3. Building the Query

First off, we need to create the table. This will be done in a resolver later, but for now, just add this to your snippet, before the return statement:

{code}$m = $modx-&gt;getManager();
$created = $m-&gt;createObjectContainer(&#39;Doodle&#39;);
return $created ? &#39;Table created.&#39; : &#39;Table not created.&#39;;{code}

Then go ahead and run your snippet. This will automatically create the DB table that we made in our schema. Now that you&#39;ve got that done, remove that code and we can continue on.

Okay, let&#39;s add this to our Snippet before the return statement:

{code}$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;);
$output = count($doodles);{code}

That&#39;s going to grab an array of Doodle objects, or in non-xPDO terms, a bunch of rows from the database. Go ahead and save your snippet, then run it in the browser at http://localhost/modx/doodles.html (or wherever the Resource was). You should get this:

{quote}0{quote}

Ha, tricked you! In reality, the first time it runs it wont grab anything, since we don&#39;t have any data in the table. Let&#39;s go put some data in the table.

Use whatever DB editing software (such as phpMyAdmin) you want, and find the &#39;modx_doodles&#39; table in your database. Add a few rows to it (just add name/description values for now). That should give you some data. Let&#39;s assume you added 2 rows. Go ahead and run your snippet, and you should get:

{quote}2{quote}

Great! Your custom database query works! Let&#39;s make it more complex. We can use xPDO&#39;s [xPDOQuery|xPDO20:xPDOQuery] to create some pretty complex queries. For now, let&#39;s just add a sort command to it:

{code}
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);
{code}

Great. That will sort it by the field in $sort (which we defined above) and the direction in $dir. Now we need to actually create some output for it. Let&#39;s do it!

h3. The Doodles class getChunk Method

In a lot of my Extras, I add a couple of helper methods to my base class called getChunk. What they allow me to do is use file-based chunks to develop in. So, let&#39;s do that. Go ahead and open up your Doodles class and add these two methods in:

{code}
    public function getChunk($name,$properties = array()) {
        $chunk = null;
        if (!isset($this-&gt;chunks[$name])) {
            $chunk = $this-&gt;_getTplChunk($name);
            if (empty($chunk)) {
                $chunk = $this-&gt;modx-&gt;getObject(&#39;modChunk&#39;,array(&#39;name&#39; =&gt; $name));
                if ($chunk == false) return false;
            }
            $this-&gt;chunks[$name] = $chunk-&gt;getContent();
        } else {
            $o = $this-&gt;chunks[$name];
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;setContent($o);
        }
        $chunk-&gt;setCacheable(false);
        return $chunk-&gt;process($properties);
    }

    private function _getTplChunk($name,$postfix = &#39;.chunk.tpl&#39;) {
        $chunk = false;
        $f = $this-&gt;config[&#39;chunksPath&#39;].strtolower($name).$postfix;
        if (file_exists($f)) {
            $o = file_get_contents($f);
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;set(&#39;name&#39;,$name);
            $chunk-&gt;setContent($o);
        }
        return $chunk;
    }{code}

For now, all you need to know is that these methods will look for Chunks in your /www/doodles/core/components/doodles/elements/chunks/ directory, postfixed with &#39;.chunk.tpl&#39; and all in lowercase. If it doesn&#39;t find them on the filesystem, it looks for them in MODX. So, if we called:

{code}$o = $dood-&gt;getChunk(&#39;hello&#39;,array(&#39;name&#39; =&gt; &#39;Joe&#39;));{code}
It would set to $o the contents of /www/doodles/core/components/doodles/elements/chunks/hello.chunk.tpl, with the property \[\[+name\]\] parsed as Joe. This will allow you to edit your Chunks in your IDE, rather than in MODX. It will also allow you to package your Extra without installing default chunks into the user&#39;s MODX install (which they would be tempted to overwrite, which would get erased in upgrades of your Extra).

So, back to our snippet. Create a Chunk file in /www/doodles/core/components/doodles/elements/chunks/rowtpl.chunk.tpl, and put this inside:

{code}&lt;li&gt;&lt;strong&gt;[[+name]]&lt;/strong&gt; - [[+description]]&lt;/li&gt;{code}

Now add this below your query but above the return line in your Snippet:

{code}
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}{code}

So, what this does is iterates over all the Doodle objects we got with the getCollection call, and creates a PHP array from their values with the toArray method. Then, it uses getChunk and that array to set values to the Chunk for each row, and append that to the $output variable. So we get a bunch of \&lt;li\&gt; tags (as many as you added rows in the DB for). It should look something like this:

!doodleoutput1.png!

Cool, huh? You can obviously change that Chunk to whatever you want - and people can pass in a name of a Chunk to &amp;tpl in their Snippet call to use whatever Chunk they want. Templatability in your Snippet! Hooray!

So let&#39;s recap. Our snippet looks like this:

{code}&lt;?php
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

/* build query */
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);

/* iterate */
$output = &#39;&#39;;
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}

return $output;{code}

And we&#39;ve got it loading our custom base class from our System Setting-defined paths, adding our custom xPDO db package, pulling from our custom database table, and outputting it via a Chunk. Cool,  huh?

h2. Summary

We&#39;ve got ourselves a nice custom database model, which our Doodles Snippet using to grab Doodles records from our database. We also have looked at the basic structure for a comprehensive MODX Extra.

But we&#39;re gonna want some way of editing that data in the MODX manager, right? Well, that&#39;s where Custom Manager Pages (CMPs) come in. Go on and proceed to the [next part of this tutorial|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier].

{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{scrollbar}";}i:1;a:3:{s:2:"id";s:8:"37683315";s:3:"ver";s:1:"2";s:4:"code";s:30819:"{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{toc}

h2. Overview

This tutorial is written as a comprehensive example on developing Extras for MODX Revolution - as well as how to setup your Extra to be easily packaged into a Transport Package, as well as able to be developed outside the MODX webroot so that source control (such as Git) can be used.

The overview will be dissecting the &quot;Doodles&quot; Extra, which is a simple Extra that uses a custom table to store objects called &quot;Doodles&quot;, which have a name and a description. We&#39;ll have a Snippet that pulls them and displays a list of them that is templatable via a Chunk, a Custom Manager Page using ExtJS to have a CRUD grid for editing, and a build script for packaging. And we&#39;ll make it all i18n-compatible to allow easy translating. *This is an extremely comprehensive tutorial*, so if you&#39;re wanting only specific parts, use the Table of Contents above.

{note}The Doodles Extra in this tutorial can be found on GitHub, here: https://github.com/splittingred/doodles{note}

h2. Setting Up Our Directories

There are many ways that you could start developing your Extra - you could do so straight out of MODX and package it with a packaging tool like [addon:PackMan], or you could alternatively develop it outside of the MODX webroot and put it in a source control system such as [Git|http://github.com/]. This tutorial will be doing the latter method, as it is beneficial for a few reasons:

* Allows immediate development straight from your Git repository
* Allows easy collaboration between developers, as there is no copying files or changing core files - just developing in your preferred IDE and then doing some initial setup on paths.
* Allows isolation of your code to be independent of MODX&#39;s core - so if you need to move it, you can do it in only one place.

Let&#39;s start. I&#39;ve created a directory in my /www/ directory at: /www/doodles/ 

You can do it wherever you want, but for this tutorial I&#39;ll refer to /www/doodles/. Make sure that this directory is *web-accessible* locally, as you&#39;ll need that later on. I have /www/ setup as / on my localhost environment, for example.

{note}You *may* have to add a System Setting in your MODX install called session_cookie_path and give it a value of &quot;/&quot; (no quotations).  This will tell MODX to use the same session when you&#39;re running stuff at http://localhost/doodles/. Also, giving it a unique name via session_cookie_name (like &quot;modxlocaldevsession&quot;) is a good idea too. That&#39;ll prevent conflicts with other MODX installs on your local machine. If you do this, empty the core/cache/ directory and relogin after doing so.{note}

In here, we&#39;ll have quite a few directories:

!doodles-dir-structure.png!

Let&#39;s note a few things. First off, our main 3 directories are core/, assets/ and _build/. Let&#39;s explain a few things about how MODX Extras work - typically (although this does not have to be done), Extras are separated into 2 different directories when installed: core/components/myextra/ and assets/components/myextra/. Why? Well, the assets/components/ directory *only* contains the web-specific assets - JavaScript files, CSS files, etc. These are the files you want publically accessible to the web. All the PHP files, classes, maps, and other files, however, are in the core/components/ directory. This keeps those files secure in the core/ directory (which can be moved outside the webroot in some MODX installations for even more security).

They&#39;re separated into our directory structure here to mimic how they will be in the MODX installation after it&#39;s installed by the Transport Package.

The _build/ directory isn&#39;t even packaged into the zip file after we create a Transport Package for it. It&#39;s there primarily for building the Transport Package. We&#39;ll get into that near the end of the tutorial.

Let&#39;s dive deeper into each subdirectory. In the assets/ directory, the only not-obvious file is the connector.php. This file will allow us to have custom processors for our Custom Manager Page (CMP) we&#39;ll be writing. We&#39;ll get more into that later.

In the core/components/doodles/ directory, we have a few directories worth explaining:

* *controllers* - These are the controllers for our CMP. More on those later.
* *docs* - Just contains a changelog, readme and license file.
* *elements* - All our Snippets, Chunks, Plugins, etc.
* *lexicon* - All our i18n language files. More on those later.
* *model* - Where all of our classes lie, as well as our XML schema file for our custom database tables.
* *processors* - All our custom processors for our CMP.

Let&#39;s also note that this directory is *completely* outside of our MODX webroot (mine&#39;s installed in /www/modx/). So - yes. You can run &quot;git init&quot; and make yourself a Git repository out of the /www/doodles/ directory (or whatever you made it). And you can push that up, without having to worry about it (though there&#39;s a few files we&#39;ll talk about later you&#39;ll want to add to a .gitignore file). 

There we have it. A completely isolated development environment from MODX so that we can do separate development and seamless collaboration. Let&#39;s get further in.

h2. Creating the Doodles Snippet

Okay. Go ahead and create a Snippet file in:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

You&#39;ll have to make a snippets/ directory, if you haven&#39;t already. Your file should be empty, but let&#39;s add a few lines of code:

{code}
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($doodles instanceof Doodles)) return &#39;&#39;;
{code}

Whoa! What&#39;s that? Well, it&#39;s where the magic happens. Let&#39;s break down each part. First off, we have the getService call. It&#39;s shorthand notation right now, so let&#39;s split it up a bit to make it easier to read:

{code}
$defaultDoodlesCorePath = $modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;;
$doodlesCorePath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$defaultDoodlesCorePath);
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);
{code}
Okay, so first off, what is $modx-&gt;getOption? That&#39;s a method that grabs the System Setting with the key (the first parameter). In the first line, we are grabbing a &#39;default&#39; path we are assuming our Doodles core path is going to be, by prefixing the MODX core path to it. It&#39;ll be: /www/modx/core/components/doodles/

Next, we&#39;ll pass that as a fallback value for the next getOption call. This one passes 3 parameters: a key named &quot;doodles.core_path&quot;, null, and our default path var we just assigned. In getOption, the 2nd parameter is an array to search for the key (which we aren&#39;t doing, so we can set it to null), and the 3rd paramter is a default value if the key isn&#39;t found.

So, for right now, our 2nd line will return /www/modx/core/components/doodles/. But that&#39;s not where our Doodles core path is! (hint: it&#39;s at /www/doodles/core/components/doodles). We want to tell these lines to find it there. So what do we do?

h3. Making the Magic Path Settings

We set a couple System Settings (that are specific to our development environment) that tell these lines where to get our files! Go ahead and make the following System Settings and set their values:

* *doodles.core_path* - /www/doodles/core/components/doodles/
* *doodles.assets_url* - /doodles/assets/components/doodles/

If you need to change either of those to reflect your correct paths, such as the URL one, do so. Now our first line will return: /www/doodles/core/components/doodles/ Bingo! Cool, huh?

Why do we do this? Why not just refer to /www/doodles/core/components/doodles/? Well, that wouldn&#39;t work in someone else&#39;s installation. There&#39;s is most likely to be at MODXPATH/core/components/doodles/. Our Transport Package (later) will handle all of that dynamic path stuff, but we want to add an override to allow us to develop Doodles outside of the MODX path. And we just did. Coding bliss!

Now on to the third line:
{code}$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);{code}

Okay, this gets crazy. $modx-&gt;getService loads a class and instantiates an object of it, if it exists, and sets it to $modx-&gt;doodles here in this case (the first parameter passed in). More on getService can be found [here|modX.getService]. But wait! We don&#39;t have a Doodles class! Well, it&#39;s time to make one.

h3. Making the Doodles Base Class

First off, you&#39;re probably asking me why we&#39;re even making this class. Well, it&#39;ll help for a few reasons: we can define some basic paths in it that we&#39;ll use across our custom Extra, and it can also give us some app-wide methods we can use. Trust me, it&#39;s useful. So let&#39;s make it in /www/doodles/core/components/doodles/model/doodles/doodles.class.php:

{code}
class Doodles {
    public $modx;
    public $config = array();
    function __construct(modX &amp;$modx,array $config = array()) {
        $this-&gt;modx =&amp; $modx;

        $basePath = $this-&gt;modx-&gt;getOption(&#39;doodles.core_path&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;);
        $assetsUrl = $this-&gt;modx-&gt;getOption(&#39;doodles.assets_url&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;assets_url&#39;).&#39;components/doodles/&#39;);
        $this-&gt;config = array_merge(array(
            &#39;basePath&#39; =&gt; $basePath,
            &#39;corePath&#39; =&gt; $basePath,
            &#39;modelPath&#39; =&gt; $basePath.&#39;model/&#39;,
            &#39;processorsPath&#39; =&gt; $basePath.&#39;processors/&#39;,
            &#39;chunksPath&#39; =&gt; $basePath.&#39;elements/chunks/&#39;,
            &#39;jsUrl&#39; =&gt; $assetsUrl.&#39;js/&#39;,
            &#39;cssUrl&#39; =&gt; $assetsUrl.&#39;css/&#39;,
            &#39;assetsUrl&#39; =&gt; $assetsUrl,
            &#39;connectorUrl&#39; =&gt; $assetsUrl.&#39;connector.php&#39;,
        ),$config);
        $this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);
    }
}
{code}

Great! It&#39;s pretty simple for now - just creates a class object that has a constructor that sets a reference to the modX object at $doodles-&gt;modx. This is useful later. Also, it populates some basic paths we may use later on into the $doodles-&gt;config array, and it does it with our fancy System Settings trick so we can point it to our /www/doodles/ path!

Now, back to our Snippet. Let&#39;s go ahead and add some default properties to our Snippet, after the lines above, so it looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Cool. Now we want to use [xPDO|xPDO20:Home] to query the database to grab our records...oops. We haven&#39;t made an xPDO model for them yet. We should do that.

h3. Making the Model

xPDO does database abstraction into neat OOP query methods. It currently is beginning to support multiple databases, and it does that by the abstraction of DB queries. Also, it allows you to keep your DB rows in nice, clean classes and do all kinds of neat things in very short lines of code. But to do that, we have to add an xPDO model to our Snippet (via the $modx-&gt;addPackage method). But first we have to build that model, using an xPDO Schema. There&#39;s a [nice long tutorial here|http://rtfm.modx.com/display/xPDO20/Creating+a+Model+With+xPDO] on how to do that, but we&#39;ll go over it fast for now.

Go ahead and make a xml file in /www/doodles/core/components/doodles/model/schema/doodles.mysql.schema.xml. Put this in it:

{code}&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;
    &lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
        &lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;

        &lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
        &lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;

        &lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
        &lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
    &lt;/object&gt;
&lt;/model&gt;{code}

Ooookay. Lots of stuff here. First off, the first line:

{code}&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;{code}

This tells the schema that our xPDO package is called &#39;doodles&#39;. This is what we&#39;ll refer to in our addPackage() call. Great. It also says the base class for all the objects defined here is &quot;xPDOObject&quot;, and that this schema is made for MySQL. Finally, it gives a default MySQL engine of MyISAM. Next!

{code}&lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;{code}
An &quot;object&quot; in a xPDO schema is basically a database table. This line says, give xPDO a name for the table called &#39;\{table_prefix\}_doodles&#39;. Assuming your table prefix you did in your MODX install is &#39;modx_&#39;, it would translate to &#39;modx_doodles&#39;. Then it says that it extends &quot;xPDOSimpleObject&quot;. What&#39;s that? Well, xPDOObject is the base object for any xPDO table class. xPDOSimpleObject extends it, but adds a nice little &quot;id&quot; auto-increment field to that table. So, since we&#39;re gonna want a &quot;id&quot; field on our table, we use xPDOSimpleObject.

{code}&lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
&lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;{code}

The rest of these fields are pretty self-explanatory - they are fields on the DB table. Let&#39;s move on to the last two parts:

{code}&lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
&lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;{code}

Okay, this is where related objects come in with xPDO. For the purposes of this tutorial, just know that this tells xPDO that the createdby field maps to a modUser, and the editedby field maps to another modUser. Cool? Now let&#39;s get into parsing that xml file and creating our classes and maps.

h3. The Schema Parsing Script

Now it&#39;s time to look at our elusive _build directory. Go ahead and create a file in there: /www/doodles/_build/build.schema.php and put this in:

{code}
&lt;?php
require_once dirname(__FILE__).&#39;/build.config.php&#39;;
include_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;
$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;model&#39; =&gt; $root.&#39;core/components/doodles/model/&#39;,
    &#39;schema_file&#39; =&gt; $root.&#39;core/components/doodles/model/schema/doodles.mysql.schema.xml&#39;,
);
$manager= $modx-&gt;getManager();
$generator= $manager-&gt;getGenerator();

if (!is_dir($sources[&#39;model&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Model directory not found!&#39;); die(); }
if (!file_exists($sources[&#39;schema_file&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Schema file not found!&#39;); die(); }
$generator-&gt;parseSchema($sources[&#39;schema_file&#39;],$sources[&#39;model&#39;]);

echo &#39;Done.&#39;;
exit();
{code}

Basically this file parses your XML schema file and makes xPDO classes and maps (PHP representations of that XML file) for your component. We&#39;ll come back to this, but first off, it&#39;s not gonna run. It&#39;s gonna die on looking for a /www/doodles/_build/build.config.php file. Time to make one of those!

{code}
&lt;?php
define(&#39;MODX_BASE_PATH&#39;, &#39;/www/modx/&#39;);
define(&#39;MODX_CORE_PATH&#39;, MODX_BASE_PATH . &#39;core/&#39;);
define(&#39;MODX_MANAGER_PATH&#39;, MODX_BASE_PATH . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_PATH&#39;, MODX_BASE_PATH . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_PATH&#39;, MODX_BASE_PATH . &#39;assets/&#39;);

define(&#39;MODX_BASE_URL&#39;,&#39;/modx/&#39;);
define(&#39;MODX_CORE_URL&#39;, MODX_BASE_URL . &#39;core/&#39;);
define(&#39;MODX_MANAGER_URL&#39;, MODX_BASE_URL . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_URL&#39;, MODX_BASE_URL . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_URL&#39;, MODX_BASE_URL . &#39;assets/&#39;);
{code}

Obviously, you may need to change those paths to wherever your MODX installation is at.

Now, you can go to your _build/build.schema.php file, and run it. I do it by loading up in a web browser: http://localhost/doodles/_build/build.schema.php. You may need to change that URL to wherever you made the doodles directory web-accessible (you did like I said to earlier, didn&#39;t you? If not, now&#39;s a good time!).

That should run and generate you some nice pretty class files and maps:

!doodles-maps.png!

Bravo! You&#39;ve just made your maps and classes. Let&#39;s go make an adjustment to our Doodles base class, so it automatically adds in the Doodles xPDO package whenever we load the class. Add this line after the $this-&gt;config = array_merge part, at the end of the constructor:

{code}$this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);{code}

This tells xPDO that we want to add the &#39;doodles&#39; xPDO package in, allowing us to query that custom table. Bravo!

Okay, our Snippet so far looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Pretty lame snippet, eh? Well, all we&#39;re doing right now is setting up the Doodles class object into a variable called $dood, and setting up some defaults for properties we&#39;ll use later. $scriptProperties is an array, by the way, of all the properties passed into the Snippet. The getOption calls here parse it to find the properties in them, and if not set, gives them default values.

h3. The include Snippet

You&#39;re probably also thinking, &quot;It&#39;s not even in the MODX manager yet! Who is this guy and who does he think he&#39;s kidding?&quot; Good question. Well, let&#39;s do that then!

Now, to preserve our custom System Setting-based paths we did earlier, we&#39;re not going to want to actually create a Doodles snippet in our manager, and paste its code in there. That&#39;d make it pretty annoying to develop - lots of copy+paste, etc. So, we&#39;re going to make a generic &quot;include&quot; snippet that looks like this:

{code}
$o = include $file;
return $o;
{code}

That&#39;s it. Seriously. Now, create a Resource called &quot;Doodles&quot; with an alias of &quot;doodles&quot; in your MODX install and put this in it:

{code}[[!include? &amp;file=`[[++doodles.core_path]]elements/snippets/snippet.doodles.php`]]{code}

This says, &quot;Include and run the file in the Doodles core path System Setting we set at earlier, plus concatenate to the end of that path &#39;elements/snippets/snippet.doodles.php&#39;&quot;. That&#39;ll resolve to:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

Which works perfect for us! Then we can edit our Snippet in our favorite IDE and go about our business. It&#39;ll also pass any properties we pass into the include snippet call into our Doodles snippet as well. Cool! Back to the Snippet.

h3. Building the Query

First off, we need to create the table. This will be done in a resolver later, but for now, just add this to your snippet, before the return statement:

{code}$m = $modx-&gt;getManager();
$created = $m-&gt;createObjectContainer(&#39;Doodle&#39;);
return $created ? &#39;Table created.&#39; : &#39;Table not created.&#39;;{code}

Then go ahead and run your snippet. This will automatically create the DB table that we made in our schema. Now that you&#39;ve got that done, remove that code and we can continue on.

Okay, let&#39;s add this to our Snippet before the return statement:

{code}$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;);
$output = count($doodles);{code}

That&#39;s going to grab an array of Doodle objects, or in non-xPDO terms, a bunch of rows from the database. Go ahead and save your snippet, then run it in the browser at http://localhost/modx/doodles.html (or wherever the Resource was). You should get this:

{quote}0{quote}

Ha, tricked you! In reality, the first time it runs it wont grab anything, since we don&#39;t have any data in the table. Let&#39;s go put some data in the table.

Use whatever DB editing software (such as phpMyAdmin) you want, and find the &#39;modx_doodles&#39; table in your database. Add a few rows to it (just add name/description values for now). That should give you some data. Let&#39;s assume you added 2 rows. Go ahead and run your snippet, and you should get:

{quote}2{quote}

Great! Your custom database query works! Let&#39;s make it more complex. We can use xPDO&#39;s [xPDOQuery|xPDO20:xPDOQuery] to create some pretty complex queries. For now, let&#39;s just add a sort command to it:

{code}
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);
{code}

Great. That will sort it by the field in $sort (which we defined above) and the direction in $dir. Now we need to actually create some output for it. Let&#39;s do it!

h3. The Doodles class getChunk Method

In a lot of my Extras, I add a couple of helper methods to my base class called getChunk. What they allow me to do is use file-based chunks to develop in. So, let&#39;s do that. Go ahead and open up your Doodles class and add these two methods in:

{code}
    public function getChunk($name,$properties = array()) {
        $chunk = null;
        if (!isset($this-&gt;chunks[$name])) {
            $chunk = $this-&gt;_getTplChunk($name);
            if (empty($chunk)) {
                $chunk = $this-&gt;modx-&gt;getObject(&#39;modChunk&#39;,array(&#39;name&#39; =&gt; $name));
                if ($chunk == false) return false;
            }
            $this-&gt;chunks[$name] = $chunk-&gt;getContent();
        } else {
            $o = $this-&gt;chunks[$name];
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;setContent($o);
        }
        $chunk-&gt;setCacheable(false);
        return $chunk-&gt;process($properties);
    }

    private function _getTplChunk($name,$postfix = &#39;.chunk.tpl&#39;) {
        $chunk = false;
        $f = $this-&gt;config[&#39;chunksPath&#39;].strtolower($name).$postfix;
        if (file_exists($f)) {
            $o = file_get_contents($f);
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;set(&#39;name&#39;,$name);
            $chunk-&gt;setContent($o);
        }
        return $chunk;
    }{code}

For now, all you need to know is that these methods will look for Chunks in your /www/doodles/core/components/doodles/elements/chunks/ directory, postfixed with &#39;.chunk.tpl&#39; and all in lowercase. If it doesn&#39;t find them on the filesystem, it looks for them in MODX. So, if we called:

{code}$o = $dood-&gt;getChunk(&#39;hello&#39;,array(&#39;name&#39; =&gt; &#39;Joe&#39;));{code}
It would set to $o the contents of /www/doodles/core/components/doodles/elements/chunks/hello.chunk.tpl, with the property \[\[+name\]\] parsed as Joe. This will allow you to edit your Chunks in your IDE, rather than in MODX. It will also allow you to package your Extra without installing default chunks into the user&#39;s MODX install (which they would be tempted to overwrite, which would get erased in upgrades of your Extra).

So, back to our snippet. Create a Chunk file in /www/doodles/core/components/doodles/elements/chunks/rowtpl.chunk.tpl, and put this inside:

{code}&lt;li&gt;&lt;strong&gt;[[+name]]&lt;/strong&gt; - [[+description]]&lt;/li&gt;{code}

Now add this below your query but above the return line in your Snippet:

{code}
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}{code}

So, what this does is iterates over all the Doodle objects we got with the getCollection call, and creates a PHP array from their values with the toArray method. Then, it uses getChunk and that array to set values to the Chunk for each row, and append that to the $output variable. So we get a bunch of \&lt;li\&gt; tags (as many as you added rows in the DB for). It should look something like this:

!doodleoutput1.png!

Cool, huh? You can obviously change that Chunk to whatever you want - and people can pass in a name of a Chunk to &amp;tpl in their Snippet call to use whatever Chunk they want. Templatability in your Snippet! Hooray!

So let&#39;s recap. Our snippet looks like this:

{code}&lt;?php
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

/* build query */
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);

/* iterate */
$output = &#39;&#39;;
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}

return $output;{code}

And we&#39;ve got it loading our custom base class from our System Setting-defined paths, adding our custom xPDO db package, pulling from our custom database table, and outputting it via a Chunk. Cool,  huh?

h2. Summary

We&#39;ve got ourselves a nice custom database model, which our Doodles Snippet using to grab Doodles records from our database. We also have looked at the basic structure for a comprehensive MODX Extra.

But we&#39;re gonna want some way of editing that data in the MODX manager, right? Well, that&#39;s where Custom Manager Pages (CMPs) come in. Go on and proceed to the [next part of this tutorial|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier].

{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{scrollbar}";}i:2;a:3:{s:2:"id";s:8:"37683310";s:3:"ver";s:1:"1";s:4:"code";s:30796:"{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{toc}

h2. Overview

This tutorial is written as a comprehensive example on developing Extras for MODX Revolution - as well as how to setup your Extra to be easily packaged into a Transport Package, as well as able to be developed outside the MODX webroot so that source control (such as Git) can be used.

The overview will be dissecting the &quot;Doodles&quot; Extra, which is a simple Extra that uses a custom table to store objects called &quot;Doodles&quot;, which have a name and a description. We&#39;ll have a Snippet that pulls them and displays a list of them that is templatable via a Chunk, a Custom Manager Page using ExtJS to have a CRUD grid for editing, and a build script for packaging. And we&#39;ll make it all i18n-compatible to allow easy translating. *This is an extremely comprehensive tutorial*, so if you&#39;re wanting only specific parts, use the Table of Contents above.

{note}The Doodles Extra in this tutorial can be found on GitHub, here: https://github.com/splittingred/doodles{note}

h2. Setting Up Our Directories

There are many ways that you could start developing your Extra - you could do so straight out of MODX and package it with a packaging tool like [addon:PackMan], or you could alternatively develop it outside of the MODX webroot and put it in a source control system such as [Git|http://github.com/]. This tutorial will be doing the latter method, as it is beneficial for a few reasons:

* Allows immediate development straight from your Git repository
* Allows easy collaboration between developers, as there is no copying files or changing core files - just developing in your preferred IDE and then doing some initial setup on paths.
* Allows isolation of your code to be independent of MODX&#39;s core - so if you need to move it, you can do it in only one place.

Let&#39;s start. I&#39;ve created a directory in my /www/ directory at: /www/doodles/ 

You can do it wherever you want, but for this tutorial I&#39;ll refer to /www/doodles/. Make sure that this directory is *web-accessible* locally, as you&#39;ll need that later on. I have /www/ setup as / on my localhost environment, for example.

{note}You *may* have to add a System Setting in your MODX install called session_cookie_path and give it a value of &quot;/&quot; (no quotations).  This will tell MODX to use the same session when you&#39;re running stuff at http://localhost/doodles/. Also, giving it a unique name via session_cookie_name (like &quot;modxlocaldevsession&quot;) is a good idea too. That&#39;ll prevent conflicts with other MODX installs on your local machine. If you do this, empty the core/cache/ directory and relogin after doing so.{note}

In here, we&#39;ll have quite a few directories:

!doodles-dir-structure.png!

Let&#39;s note a few things. First off, our main 3 directories are core/, assets/ and _build/. Let&#39;s explain a few things about how MODX Extras work - typically (although this does not have to be done), Extras are separated into 2 different directories when installed: core/components/myextra/ and assets/components/myextra/. Why? Well, the assets/components/ directory *only* contains the web-specific assets - JavaScript files, CSS files, etc. These are the files you want publically accessible to the web. All the PHP files, classes, maps, and other files, however, are in the core/components/ directory. This keeps those files secure in the core/ directory (which can be moved outside the webroot in some MODX installations for even more security).

They&#39;re separated into our directory structure here to mimic how they will be in the MODX installation after it&#39;s installed by the Transport Package.

The _build/ directory isn&#39;t even packaged into the zip file after we create a Transport Package for it. It&#39;s there primarily for building the Transport Package. We&#39;ll get into that near the end of the tutorial.

Let&#39;s dive deeper into each subdirectory. In the assets/ directory, the only not-obvious file is the connector.php. This file will allow us to have custom processors for our Custom Manager Page (CMP) we&#39;ll be writing. We&#39;ll get more into that later.

In the core/components/doodles/ directory, we have a few directories worth explaining:

* *controllers* - These are the controllers for our CMP. More on those later.
* *docs* - Just contains a changelog, readme and license file.
* *elements* - All our Snippets, Chunks, Plugins, etc.
* *lexicon* - All our i18n language files. More on those later.
* *model* - Where all of our classes lie, as well as our XML schema file for our custom database tables.
* *processors* - All our custom processors for our CMP.

Let&#39;s also note that this directory is *completely* outside of our MODX webroot (mine&#39;s installed in /www/modx/). So - yes. You can run &quot;git init&quot; and make yourself a Git repository out of the /www/doodles/ directory (or whatever you made it). And you can push that up, without having to worry about it (though there&#39;s a few files we&#39;ll talk about later you&#39;ll want to add to a .gitignore file). 

There we have it. A completely isolated development environment from MODX so that we can do separate development and seamless collaboration. Let&#39;s get further in.

h2. Creating the Doodles Snippet

Okay. Go ahead and create a Snippet file in:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

You&#39;ll have to make a snippets/ directory, if you haven&#39;t already. Your file should be empty, but let&#39;s add a few lines of code:

{code}
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($doodles instanceof Doodles)) return &#39;&#39;;
{code}

Whoa! What&#39;s that? Well, it&#39;s where the magic happens. Let&#39;s break down each part. First off, we have the getService call. It&#39;s shorthand notation right now, so let&#39;s split it up a bit to make it easier to read:

{code}
$defaultDoodlesCorePath = $modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;;
$doodlesCorePath = $modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$defaultDoodlesCorePath);
$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);
{code}
Okay, so first off, what is $modx-&gt;getOption? That&#39;s a method that grabs the System Setting with the key (the first parameter). In the first line, we are grabbing a &#39;default&#39; path we are assuming our Doodles core path is going to be, by prefixing the MODX core path to it. It&#39;ll be: /www/modx/core/components/doodles/

Next, we&#39;ll pass that as a fallback value for the next getOption call. This one passes 3 parameters: a key named &quot;doodles.core_path&quot;, null, and our default path var we just assigned. In getOption, the 2nd parameter is an array to search for the key (which we aren&#39;t doing, so we can set it to null), and the 3rd paramter is a default value if the key isn&#39;t found.

So, for right now, our 2nd line will return /www/modx/core/components/doodles/. But that&#39;s not where our Doodles core path is! (hint: it&#39;s at /www/doodles/core/components/doodles). We want to tell these lines to find it there. So what do we do?

h3. Making the Magic Path Settings

We set a couple System Settings (that are specific to our development environment) that tell these lines where to get our files! Go ahead and make the following System Settings and set their values:

* *doodles.core_path* - /www/doodles/core/components/doodles/
* *doodles.assets_url* - /doodles/assets/components/doodles/

If you need to change either of those to reflect your correct paths, such as the URL one, do so. Now our first line will return: /www/doodles/core/components/doodles/ Bingo! Cool, huh?

Why do we do this? Why not just refer to /www/doodles/core/components/doodles/? Well, that wouldn&#39;t work in someone else&#39;s installation. There&#39;s is most likely to be at MODXPATH/core/components/doodles/. Our Transport Package (later) will handle all of that dynamic path stuff, but we want to add an override to allow us to develop Doodles outside of the MODX path. And we just did. Coding bliss!

Now on to the third line:
{code}$doodles = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$doodlesCorePath.&#39;model/doodles/&#39;,$scriptProperties);{code}

Okay, this gets crazy. $modx-&gt;getService loads a class and instantiates an object of it, if it exists, and sets it to $modx-&gt;doodles here in this case (the first parameter passed in). More on getService can be found [here|modX.getService]. But wait! We don&#39;t have a Doodles class! Well, it&#39;s time to make one.

h3. Making the Doodles Base Class

First off, you&#39;re probably asking me why we&#39;re even making this class. Well, it&#39;ll help for a few reasons: we can define some basic paths in it that we&#39;ll use across our custom Extra, and it can also give us some app-wide methods we can use. Trust me, it&#39;s useful. So let&#39;s make it in /www/doodles/core/components/doodles/model/doodles/doodles.class.php:

{code}
class Doodles {
    public $modx;
    public $config = array();
    function __construct(modX &amp;$modx,array $config = array()) {
        $this-&gt;modx =&amp; $modx;

        $basePath = $this-&gt;modx-&gt;getOption(&#39;doodles.core_path&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;);
        $assetsUrl = $this-&gt;modx-&gt;getOption(&#39;doodles.assets_url&#39;,$config,$this-&gt;modx-&gt;getOption(&#39;assets_url&#39;).&#39;components/doodles/&#39;);
        $this-&gt;config = array_merge(array(
            &#39;basePath&#39; =&gt; $basePath,
            &#39;corePath&#39; =&gt; $basePath,
            &#39;modelPath&#39; =&gt; $basePath.&#39;model/&#39;,
            &#39;processorsPath&#39; =&gt; $basePath.&#39;processors/&#39;,
            &#39;chunksPath&#39; =&gt; $basePath.&#39;elements/chunks/&#39;,
            &#39;jsUrl&#39; =&gt; $assetsUrl.&#39;js/&#39;,
            &#39;cssUrl&#39; =&gt; $assetsUrl.&#39;css/&#39;,
            &#39;assetsUrl&#39; =&gt; $assetsUrl,
            &#39;connectorUrl&#39; =&gt; $assetsUrl.&#39;connector.php&#39;,
        ),$config);
        $this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);
    }
}
{code}

Great! It&#39;s pretty simple for now - just creates a class object that has a constructor that sets a reference to the modX object at $doodles-&gt;modx. This is useful later. Also, it populates some basic paths we may use later on into the $doodles-&gt;config array, and it does it with our fancy System Settings trick so we can point it to our /www/doodles/ path!

Now, back to our Snippet. Let&#39;s go ahead and add some default properties to our Snippet, after the lines above, so it looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Cool. Now we want to use [xPDO|xPDO20:Home] to query the database to grab our records...oops. We haven&#39;t made an xPDO model for them yet. We should do that.

h3. Making the Model

xPDO does database abstraction into neat OOP query methods. It currently is beginning to support multiple databases, and it does that by the abstraction of DB queries. Also, it allows you to keep your DB rows in nice, clean classes and do all kinds of neat things in very short lines of code. But to do that, we have to add an xPDO model to our Snippet (via the $modx-&gt;addPackage method). But first we have to build that model, using an xPDO Schema. There&#39;s a [nice long tutorial here|http://rtfm.modx.com/display/xPDO20/Creating+a+Model+With+xPDO] on how to do that, but we&#39;ll go over it fast for now.

Go ahead and make a xml file in /www/doodles/core/components/doodles/model/schema/doodles.mysql.schema.xml. Put this in it:

{code}&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;
    &lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;
        &lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
        &lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;

        &lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
        &lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
        &lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;

        &lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
        &lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
    &lt;/object&gt;
&lt;/model&gt;{code}

Ooookay. Lots of stuff here. First off, the first line:

{code}&lt;model package=&quot;doodles&quot; baseClass=&quot;xPDOObject&quot; platform=&quot;mysql&quot; defaultEngine=&quot;MyISAM&quot;&gt;{code}

This tells the schema that our xPDO package is called &#39;doodles&#39;. This is what we&#39;ll refer to in our addPackage() call. Great. It also says the base class for all the objects defined here is &quot;xPDOObject&quot;, and that this schema is made for MySQL. Finally, it gives a default MySQL engine of MyISAM. Next!

{code}&lt;object class=&quot;Doodle&quot; table=&quot;doodles&quot; extends=&quot;xPDOSimpleObject&quot;&gt;{code}
An &quot;object&quot; in a xPDO schema is basically a database table. This line says, give xPDO a name for the table called &#39;\{table_prefix\}_doodles&#39;. Assuming your table prefix you did in your MODX install is &#39;modx_&#39;, it would translate to &#39;modx_doodles&#39;. Then it says that it extends &quot;xPDOSimpleObject&quot;. What&#39;s that? Well, xPDOObject is the base object for any xPDO table class. xPDOSimpleObject extends it, but adds a nice little &quot;id&quot; auto-increment field to that table. So, since we&#39;re gonna want a &quot;id&quot; field on our table, we use xPDOSimpleObject.

{code}&lt;field key=&quot;name&quot; dbtype=&quot;varchar&quot; precision=&quot;255&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;description&quot; dbtype=&quot;text&quot; phptype=&quot;string&quot; null=&quot;false&quot; default=&quot;&quot;/&gt;
&lt;field key=&quot;createdon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;createdby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;
&lt;field key=&quot;editedon&quot; dbtype=&quot;datetime&quot; phptype=&quot;datetime&quot; null=&quot;true&quot;/&gt;
&lt;field key=&quot;editedby&quot; dbtype=&quot;int&quot; precision=&quot;10&quot; attributes=&quot;unsigned&quot; phptype=&quot;integer&quot; null=&quot;false&quot; default=&quot;0&quot; /&gt;{code}

The rest of these fields are pretty self-explanatory - they are fields on the DB table. Let&#39;s move on to the last two parts:

{code}&lt;aggregate alias=&quot;CreatedBy&quot; class=&quot;modUser&quot; local=&quot;createdby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;
&lt;aggregate alias=&quot;EditedBy&quot; class=&quot;modUser&quot; local=&quot;editedby&quot; foreign=&quot;id&quot; cardinality=&quot;one&quot; owner=&quot;foreign&quot;/&gt;{code}

Okay, this is where related objects come in with xPDO. For the purposes of this tutorial, just know that this tells xPDO that the createdby field maps to a modUser, and the editedby field maps to another modUser. Cool? Now let&#39;s get into parsing that xml file and creating our classes and maps.

h3. The Schema Parsing Script

Now it&#39;s time to look at our elusive _build directory. Go ahead and create a file in there: /www/doodles/_build/build.schema.php and put this in:

{code}
&lt;?php
require_once dirname(__FILE__).&#39;/build.config.php&#39;;
include_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;
$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
echo &#39;&lt;pre&gt;&#39;; /* used for nice formatting of log messages */
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(&#39;ECHO&#39;);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources = array(
    &#39;model&#39; =&gt; $root.&#39;core/components/doodles/model/&#39;,
    &#39;schema_file&#39; =&gt; $root.&#39;core/components/doodles/model/schema/doodles.mysql.schema.xml&#39;,
);
$manager= $modx-&gt;getManager();
$generator= $manager-&gt;getGenerator();

if (!is_dir($sources[&#39;model&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Model directory not found!&#39;); die(); }
if (!file_exists($sources[&#39;schema_file&#39;])) { $modx-&gt;log(modX::LOG_LEVEL_ERROR,&#39;Schema file not found!&#39;); die(); }
$generator-&gt;parseSchema($sources[&#39;schema_file&#39;],$sources[&#39;model&#39;]);

echo &#39;Done.&#39;;
exit();
{code}

Basically this file parses your XML schema file and makes xPDO classes and maps (PHP representations of that XML file) for your component. We&#39;ll come back to this, but first off, it&#39;s not gonna run. It&#39;s gonna die on looking for a /www/doodles/_build/build.config.php file. Time to make one of those!

{code}
&lt;?php
define(&#39;MODX_BASE_PATH&#39;, &#39;/www/modx/&#39;);
define(&#39;MODX_CORE_PATH&#39;, MODX_BASE_PATH . &#39;core/&#39;);
define(&#39;MODX_MANAGER_PATH&#39;, MODX_BASE_PATH . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_PATH&#39;, MODX_BASE_PATH . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_PATH&#39;, MODX_BASE_PATH . &#39;assets/&#39;);

define(&#39;MODX_BASE_URL&#39;,&#39;/modx/&#39;);
define(&#39;MODX_CORE_URL&#39;, MODX_BASE_URL . &#39;core/&#39;);
define(&#39;MODX_MANAGER_URL&#39;, MODX_BASE_URL . &#39;manager/&#39;);
define(&#39;MODX_CONNECTORS_URL&#39;, MODX_BASE_URL . &#39;connectors/&#39;);
define(&#39;MODX_ASSETS_URL&#39;, MODX_BASE_URL . &#39;assets/&#39;);
{code}

Obviously, you may need to change those paths to wherever your MODX installation is at.

Now, you can go to your _build/build.schema.php file, and run it. I do it by loading up in a web browser: http://localhost/doodles/_build/build.schema.php. You may need to change that URL to wherever you made the doodles directory web-accessible (you did like I said to earlier, didn&#39;t you? If not, now&#39;s a good time!).

That should run and generate you some nice pretty class files and maps:

!doodles-maps.png!

Bravo! You&#39;ve just made your maps and classes. Let&#39;s go make an adjustment to our Doodles base class, so it automatically adds in the Doodles xPDO package whenever we load the class. Add this line after the $this-&gt;config = array_merge part, at the end of the constructor:

{code}$this-&gt;modx-&gt;addPackage(&#39;doodles&#39;,$this-&gt;config[&#39;modelPath&#39;]);{code}

This tells xPDO that we want to add the &#39;doodles&#39; xPDO package in, allowing us to query that custom table. Bravo!

Okay, our Snippet so far looks like this:

{code}
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

$output = &#39;&#39;;

return $output;
{code}

Pretty lame snippet, eh? Well, all we&#39;re doing right now is setting up the Doodles class object into a variable called $dood, and setting up some defaults for properties we&#39;ll use later. $scriptProperties is an array, by the way, of all the properties passed into the Snippet. The getOption calls here parse it to find the properties in them, and if not set, gives them default values.

h3. The include Snippet

You&#39;re probably also thinking, &quot;It&#39;s not even in the MODX manager yet! Who is this guy and who does he think he&#39;s kidding?&quot; Good question. Well, let&#39;s do that then!

Now, to preserve our custom System Setting-based paths we did earlier, we&#39;re not going to want to actually create a Doodles snippet in our manager, and paste its code in there. That&#39;d make it pretty annoying to develop - lots of copy+paste, etc. So, we&#39;re going to make a generic &quot;include&quot; snippet that looks like this:

{code}
$o = include $file;
return $o;
{code}

That&#39;s it. Seriously. Now, create a Resource called &quot;Doodles&quot; with an alias of &quot;doodles&quot; in your MODX install and put this in it:

{code}[[!include? &amp;file=`[[++doodles.core_path]]elements/snippets/snippet.doodles.php`]]{code}

This says, &quot;Include and run the file in the Doodles core path System Setting we set at earlier, plus concatenate to the end of that path &#39;elements/snippets/snippet.doodles.php&#39;&quot;. That&#39;ll resolve to:

/www/doodles/core/components/doodles/elements/snippets/snippet.doodles.php

Which works perfect for us! Then we can edit our Snippet in our favorite IDE and go about our business. It&#39;ll also pass any properties we pass into the include snippet call into our Doodles snippet as well. Cool! Back to the Snippet.

h3. Building the Query

First off, we need to create the table. This will be done in a resolver later, but for now, just add this to your snippet, before the return statement:

{code}$m = $modx-&gt;getManager();
$created = $m-&gt;createObjectContainer(&#39;Doodle&#39;);
return $created ? &#39;Table created.&#39; : &#39;Table not created.&#39;;{code}

Then go ahead and run your snippet. This will automatically create the DB table that we made in our schema. Now that you&#39;ve got that done, remove that code and we can continue on.

Okay, let&#39;s add this to our Snippet before the return statement:

{code}$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;);
$output = count($doodles);{code}

That&#39;s going to grab an array of Doodle objects, or in non-xPDO terms, a bunch of rows from the database. Go ahead and save your snippet, then run it in the browser at http://localhost/modx/doodles.html (or wherever the Resource was). You should get this:

{quote}0{quote}

Ha, tricked you! In reality, the first time it runs it wont grab anything, since we don&#39;t have any data in the table. Let&#39;s go put some data in the table.

Use whatever DB editing software (such as phpMyAdmin) you want, and find the &#39;modx_doodles&#39; table in your database. Add a few rows to it (just add name/description values for now). That should give you some data. Let&#39;s assume you added 2 rows. Go ahead and run your snippet, and you should get:

{quote}2{quote}

Great! Your custom database query works! Let&#39;s make it more complex. We can use xPDO&#39;s [xPDOQuery|xPDO20:xPDOQuery] to create some pretty complex queries. For now, let&#39;s just add a sort command to it:

{code}
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);
{code}

Great. That will sort it by the field in $sort (which we defined above) and the direction in $dir. Now we need to actually create some output for it. Let&#39;s do it!

h3. The Doodles class getChunk Method

In a lot of my Extras, I add a couple of helper methods to my base class called getChunk. What they allow me to do is use file-based chunks to develop in. So, let&#39;s do that. Go ahead and open up your Doodles class and add these two methods in:

{code}
    public function getChunk($name,$properties = array()) {
        $chunk = null;
        if (!isset($this-&gt;chunks[$name])) {
            $chunk = $this-&gt;_getTplChunk($name);
            if (empty($chunk)) {
                $chunk = $this-&gt;modx-&gt;getObject(&#39;modChunk&#39;,array(&#39;name&#39; =&gt; $name));
                if ($chunk == false) return false;
            }
            $this-&gt;chunks[$name] = $chunk-&gt;getContent();
        } else {
            $o = $this-&gt;chunks[$name];
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;setContent($o);
        }
        $chunk-&gt;setCacheable(false);
        return $chunk-&gt;process($properties);
    }

    private function _getTplChunk($name,$postfix = &#39;.chunk.tpl&#39;) {
        $chunk = false;
        $f = $this-&gt;config[&#39;chunksPath&#39;].strtolower($name).$postfix;
        if (file_exists($f)) {
            $o = file_get_contents($f);
            $chunk = $this-&gt;modx-&gt;newObject(&#39;modChunk&#39;);
            $chunk-&gt;set(&#39;name&#39;,$name);
            $chunk-&gt;setContent($o);
        }
        return $chunk;
    }{code}

For now, all you need to know is that these methods will look for Chunks in your /www/doodles/core/components/doodles/elements/chunks/ directory, postfixed with &#39;.chunk.tpl&#39; and all in lowercase. If it doesn&#39;t find them on the filesystem, it looks for them in MODX. So, if we called:

{code}$o = $dood-&gt;getChunk(&#39;hello&#39;,array(&#39;name&#39; =&gt; &#39;Joe&#39;));{code}
It would set to $o the contents of /www/doodles/core/components/doodles/elements/chunks/hello.chunk.tpl, with the property \[\[+name\]\] parsed as Joe. This will allow you to edit your Chunks in your IDE, rather than in MODX. It will also allow you to package your Extra without installing default chunks into the user&#39;s MODX install (which they would be tempted to overwrite, which would get erased in upgrades of your Extra).

So, back to our snippet. Create a Chunk file in /www/doodles/core/components/doodles/elements/chunks/rowtpl.chunk.tpl, and put this inside:

{code}&lt;li&gt;&lt;strong&gt;[[+name]]&lt;/strong&gt; - [[+description]]&lt;/li&gt;{code}

Now add this below your query but above the return line in your Snippet:

{code}
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}{code}

So, what this does is iterates over all the Doodle objects we got with the getCollection call, and creates a PHP array from their values with the toArray method. Then, it uses getChunk and that array to set values to the Chunk for each row, and append that to the $output variable. So we get a bunch of \&lt;li\&gt; tags (as many as you added rows in the DB for). It should look something like this:

!doodleoutput1.png!

Cool, huh? You can obviously change that Chunk to whatever you want - and people can pass in a name of a Chunk to &amp;tpl in their Snippet call to use whatever Chunk they want. Templatability in your Snippet! Hooray!

So let&#39;s recap. Our snippet looks like this:

{code}&lt;?php
$dood = $modx-&gt;getService(&#39;doodles&#39;,&#39;Doodles&#39;,$modx-&gt;getOption(&#39;doodles.core_path&#39;,null,$modx-&gt;getOption(&#39;core_path&#39;).&#39;components/doodles/&#39;).&#39;model/doodles/&#39;,$scriptProperties);
if (!($dood instanceof Doodles)) return &#39;&#39;;

/* setup default properties */
$tpl = $modx-&gt;getOption(&#39;tpl&#39;,$scriptProperties,&#39;rowTpl&#39;);
$sort = $modx-&gt;getOption(&#39;sort&#39;,$scriptProperties,&#39;name&#39;);
$dir = $modx-&gt;getOption(&#39;dir&#39;,$scriptProperties,&#39;ASC&#39;);

/* build query */
$c = $modx-&gt;newQuery(&#39;Doodle&#39;);
$c-&gt;sortby($sort,$dir);
$doodles = $modx-&gt;getCollection(&#39;Doodle&#39;,$c);

/* iterate */
$output = &#39;&#39;;
foreach ($doodles as $doodle) {
    $doodleArray = $doodle-&gt;toArray();
    $output .= $dood-&gt;getChunk($tpl,$doodleArray);
}

return $output;{code}

And we&#39;ve got it loading our custom base class from our System Setting-defined paths, adding our custom xPDO db package, pulling from our custom database table, and outputting it via a Chunk. Cool,  huh?

h2. Summary

We&#39;ve got ourselves a nice custom database model, which our Doodles Snippet using to grab Doodles records from our database. We also have looked at the basic structure for a comprehensive MODX Extra.

But we&#39;re gonna want some way of editing that data in the MODX manager, right? Well, that&#39;s where Custom Manager Pages (CMPs) come in. Go on and proceed to the [next part of this tutorial|Developing an Extra in MODX Revolution, Part II].

{panel}This tutorial is part of a Series:
* Part I: Getting Started and Creating the Doodles Snippet
* [Part II: Creating our Custom Manager Page|Developing an Extra in MODX Revolution, Part II - MODX 2.1 and Earlier]
* [Part III: Packaging Our Extra|Developing an Extra in MODX Revolution, Part III - MODX 2.1 and Earlier]{panel}

{scrollbar}";}}}