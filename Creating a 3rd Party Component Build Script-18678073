a:5:{s:2:"id";s:8:"18678073";s:4:"info";a:4:{s:6:"Title:";s:43:"Creating a 3rd Party Component Build Script";s:7:"Author:";s:15:"Shaun McCormick";s:16:"Last Changed by:";s:12:"Mark Hamstra";s:12:"Wiki Markup:";s:58:"[revolution20:Creating a 3rd Party Component Build Script]";}s:6:"parent";s:8:"37683306";s:6:"source";s:31891:"\\

{toc}
{note}Users using Revolution 2.0.0-beta-4 or earlier should note that the defines are different in beta5 and onward. An example: xPDOTransport::UNIQUE_KEYS in beta5\+ is XPDO_TRANSPORT_UNIQUE_KEYS in beta4 and earlier. MODx recommends to just update to beta5/SVN.{note}A build script. What is that, you might ask? This is the meat of the packaging process; here is where your component is actually put into the nice, neat .zip transport package that you find on modxcms.com or through Revolution&#39;s Package Management section.

This tutorial will guide you through how to create one of those scripts. We&#39;ll be using a sample component called Quip, which contains a modAction, a few menus, some chunks and a snippet, lexicons, setup options, a license, a readme, and system settings. It&#39;s basically a quick, easy run through of all the basics to creating a fundamental build script.

h2. Directory Structure

First off, let&#39;s take a quick look at our directory structure. This isn&#39;t always how you have to do it - this one is specifically built this way for SVN; but it&#39;s definitely recommended, especially with the _assets/components/quip/_ and _core/components/quip/_ structures, since that makes creating the transport package much easier.

!quip-dir1.png!

h2. Starting the Build Script

Let&#39;s first start with some phpdoc comments at the top, and then start the timer.
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0); /* makes sure our script doesnt timeout */
{code}Now let&#39;s define some basic paths. We can define these up top into a &quot;sources&quot; array to make them easier to reach later in the build script. Note how the &#39;source_core&#39; and &#39;source_assets&#39; directories do _not_ post-fix a foreslash onto their paths. This is required.
{code}$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/quip/lexicon/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root); /* save memory */
{code}Now, we&#39;ll need to include some files to get the build libraries we&#39;ll need. First, let&#39;s include a file we&#39;ll create called &#39;build.config.php&#39; in our build dir.
{code}require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
{code}In this file, we&#39;ll want to define the location of our MODx Revolution installation so that the build script can know where to get the modX class, as well as where to put the package when finished. Our file will look somewhat like this:
{code}&lt;?php
/**
 * Define the MODX path constants necessary for core installation
 *
 * @package quip
 * @subpackage build
 */
define(&#39;MODX_CORE_PATH&#39;, &#39;/absolute/path/to/modx/core/&#39;);
define(&#39;MODX_CONFIG_KEY&#39;,&#39;config&#39;);
{code}You&#39;ll want to make sure to change the value of MODX_CORE_PATH to the absolute path of where your MODx Revolution core is installed. MODX_CONFIG_KEY can stay the same, unless you&#39;re doing a multi-domain install.

Now, you&#39;ll want to include the modX class, and instantiate it. We&#39;ll also initialize it into the &#39;mgr&#39; context, and set the log output to HTML to make our errors and info messages nice and formatted - unless we&#39;re doing this from the cmd line, where we&#39;ll want just standard echo messages.
{code}require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);
{code}Okay, it&#39;s time for the meat. Let&#39;s first off use $modx-&gt;loadClass to load the modPackageBuilder class. Then we&#39;ll instantiate an instance of it, and create a package.
{code}$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha7&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}The modPackageBuilder::createPackage function has 3 parameters:
_name_, _version_, and _release_. For us,
we&#39;ll be doing quip-0.1-alpha7, so let&#39;s go with that.

Next, we&#39;ll register a [Namespace|Namespaces] to this package. Not all packages need [Namespaces]; but all 3rd Party Components do. Basically, a Namespace is an organizing tool for MODx so that MODx can know what objects are tied to what package. This is helpful later on should we want to uninstall our package; we&#39;d want it to remove the objects we&#39;d install.

Plus, should we want to add any [Lexicon Entries|Internationalization] to this package (which we will), MODx does so by relating it to it&#39;s Namespace. Our package builder will assign our Lexicon Entries to the Namespace, so we can easily manage _just_ our Lexicon Entries; not any others.

h2. Packaging in Objects

Objects are packaged as _Vehicles_ in MODx Revolution; basically think of a vehicle as a sort of storage system that transports the data and/or files into the zip package. Packages can contain many vehicles; vehicles can contain many objects or files - however, vehicles that contain an object must only have one reference object (or parent object, whichever you prefer) that the vehicle is based off of.

So, let&#39;s look at some examples for creating a vehicle before digging into our build script. This first example packages in a simple object, with some parameters:
{code}$snippet = $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,1);
$snippet-&gt;set(&#39;name&#39;,&#39;Test&#39;);
$vehicle = $builder-&gt;createVehicle($snippet,array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
));
{code}So, first off, we created a snippet object. Note that you&#39;ll have to specify an arbitrary ID for it, even though we wont keep it later. This is required. Then, we used the &#39;createVehicle&#39; function in modPackageBuilder to create the vehicle object. Let&#39;s look at those attributes options more closely:

* *xPDOTransport::UNIQUE_KEY* _(string/array)_ \- Here you&#39;d place the unique key that identifies the object you&#39;re creating. This will tell MODx to search for the modSnippet with the &#39;name&#39; equal to the packaged in name (here, &#39;Test&#39;) when updating or removing the object. For most objects, this will be &#39;name&#39;; others require different settings. Some might even require an array of two or more fields.
* *xPDOTransport::UPDATE_OBJECT* _(boolean)_ \- Either true or false, this tells MODx whether or not to update the object if it is found in the DB upon install (or update). Sometimes, if the object is already there, you may not want to update it - the update might erase the user&#39;s current settings for that object.
* *xPDOTransport::PRESERVE_KEYS* _(boolean)_ \- Either true or false, this tells MODx whether or not to rewrite the primary keys when the object is found. This can be useful if you&#39;re wanting the PKs to stay the same when you update - some PKs are auto_increment, and if you&#39;re wanting those to stay the same number, you&#39;d set this to true. Note: If the object already exists, this feature only works if xPDOTransport::UPDATE_OBJECT is set to true as well. If the object is not found, it will work regardless.

Simple enough? So our example tells it to look for a Snippet named &#39;Test&#39;, and if it finds it, update its contents. If it doesnt find it, create it. However, if it does find it; we told MODx not to update its PK - there&#39;s no need to adjust that in this situation.

Now, what about related objects? What if I want to package in my modMenu, along with its Action associated with the modMenu? Here&#39;s a bit more complex scenario:
{code}$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;0&#39;,
    &#39;controller&#39; =&gt; &#39;index&#39;,
    &#39;haslayout&#39; =&gt; &#39;1&#39;,
    &#39;lang_topics&#39; =&gt; &#39;quip:default,file&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;quip_desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; &#39;0&#39;,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
{code}Okay, a bit more meat here. We&#39;re introducing 2 new parameters:

* *xPDOTransport::RELATED_OBJECTS* _(boolean)_ \- Either true or false, this will tell MODx we want to search for related objects to this object. This must be set for the next parameter to work.
* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* _(array)_ \- This defines the types and details of the related objects we want to grab. If you note, the format is simply an associative array of attributes - similar to the parent object&#39;s attributes - where the key is the &quot;alias&quot; of the related object we want to grab. The aliases can be found in the Schema, located in _core/model/schema/modx.mysql.schema.xml_.

So our example above tells us on the modAction (found by looking for the modAction with a namespace of &#39;quip&#39; and a controller of &#39;index&#39;) to include the related modAction object that we package in. We packaged them in manually using xPDO&#39;s addOne function on the modAction.

Also, if we wanted to package in related objects to the modAction objects, we would just have had to define that in the &#39;Action&#39; attributes and addMany (or addOne) on that action. You can go however deep in nesting that you want.

So, back to our script. To recap, so far we have:
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;_build/lexicon/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha5&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}So, let&#39;s first package in our modActions and modMenus for our backend:
{code}/* load action/menu */
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;

$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$action); /* to keep memory low */
{code}Wait\! Notice how I put the action data in a different file? You don&#39;t have to do this - it&#39;s completely personal preference - but it does keep our build script clean, and isolate our actions/menus to a separate file for easy management.

Let&#39;s do the same with our system settings:
{code}/* load system settings */
$settings = include $sources[&#39;data&#39;].&#39;transport.settings.php&#39;;

$attributes= array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;key&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; false,
);
foreach ($settings as $setting) {
    $vehicle = $builder-&gt;createVehicle($setting,$attributes);
    $builder-&gt;putVehicle($vehicle);
}
unset($settings,$setting,$attributes);
{code}Great\! We&#39;ve got our actions, menus and settings packaged in. Now, using our newfound knowledge about related objects, let&#39;s create a category called &#39;Quip&#39; and put our Snippet and Chunks in that category. We&#39;ll go through this a bit slower, so we can easily see how this works:
{code}/* create category */
$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,&#39;Quip&#39;);
{code}Okay, great. Step one done: category created. Now about that Snippet:
{code}/* create the snippet */
$snippet= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,0);
$snippet-&gt;set(&#39;name&#39;, &#39;Quip&#39;);
$snippet-&gt;set(&#39;description&#39;, &#39;A simple commenting component.&#39;);
$snippet-&gt;set(&#39;snippet&#39;,file_get_contents($sources[&#39;source_core&#39;].&#39;/snippet.quip.php&#39;);
{code}Great\! Note how here we&#39;re actually using the file_get_contents() function to grab the contents of the snippet from our dev environment and place it here. This makes it easy to run the build in future iterations; no need to continually update this call - just update that file.

Now, we had some properties on that snippet...how do we put those in?
{code}$properties = include $sources[&#39;data&#39;].&#39;properties.inc.php&#39;;
$snippet-&gt;setProperties($properties);
$category-&gt;addMany($snippet);
{code}{note}

We&#39;re using the addMany method here, and not the addOne method. Wether you need to use one or the other does not so much depend on the amount of objects you are relating (in this case only one snippet), but the cardinality of the relationship. That may sound complex - but the cardinality simply means if it is a one-on-one or one-to-many relationship. In this case, a category has a one-to-many relationship with snippets (there can be many snippets in one category) and that means you will have to use the addMany method. You can pass an array of objects or just one object to that method, but which one you use depends on the cardinality. Read more about [relationships|xPDO20:Defining Relationships], [xPDO20:addOne] and [xPDO20:addMany].


{note}


You&#39;ll use modSnippet&#39;s setProperties function to pass in an array of property arrays. So, let&#39;s take a look at that properties.inc.php file:
{code}&lt;?php
/**
 * Default snippet properties
 *
 * @package quip
 * @subpackage build
 */
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;closed&#39;,
        &#39;desc&#39; =&gt; &#39;If set to true, the thread will not accept new comments.&#39;,
        &#39;type&#39; =&gt; &#39;combo-boolean&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; false,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dateFormat&#39;,
        &#39;desc&#39; =&gt; &#39;The format of the dates displayed for a comment.&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;%b %d, %Y at %I:%M %p&#39;,
    ),
    /* ...removed others for brevity... */
);
return $properties;
{code}Simple enough. And now on to the chunks:
{code}/* add chunks */
$chunks = include $sources[&#39;data&#39;].&#39;transport.chunks.php&#39;;
if (is_array($chunks)) {
    $category-&gt;addMany($chunks);
} else { $modx-&gt;log(modX::LOG_LEVEL_FATAL,&#39;Adding chunks failed.&#39;); }
{code}Good. We returned an array of chunks, and used modCategory&#39;s addMany() function to add them in. We also added a sanity check just in case we made a typo or something. Now, let&#39;s package all that into a vehicle:
{code}/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
        &#39;Chunks&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    )
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
{code}Great\! We&#39;ve got our category vehicle, complete with all the related chunks and snippet. They&#39;ll be installed in the right category when our users install our package, too - so it&#39;ll look nice and sharp\!

h2. Validators and Resolvers

Validators and resolvers are basically scripts that run during the install process. Validators are run pre-install; meaning that they are run before the main package installation happens. If they return false, the installation does not proceed.

Resolvers, on the other hand, execute after the main package has installed. They can either be file or PHP scripts. A file resolver simply copies over files into a specific target location. A PHP resolver executes a script after install.

With that said, we&#39;re going to attach 2 file resolvers, and one PHP resolver, to our script:

{code}$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;setupoptions.resolver.php&#39;,
));
$builder-&gt;putVehicle($vehicle);
{code}Okay, first things first. File resolvers take two options:

* *source* \- This is the target directory or script. If it&#39;s a file resolver, it must not end with a trailing slash and must be a valid directory. If it&#39;s a PHP script resolver, it must be a valid and accessible file.
* *target* \- Only applicable to file resolvers, this tells MODx where to install the source files. It is an eval()&#39;ed statement, so must be used as in the example. The standard MODx defines are available to you; use those to grab base paths to target.

So in our examples, we simply move all the files in our source core directory to modx/core/components/quip/ (since our directory that we&#39;re moving is named &quot;quip&quot;), and all the files in our source assets directory to modx/assets/components/quip/.

You might be asking why we&#39;re moving these to two directories. Well, in practice, it&#39;s best to keep non-web-accessible files - such as PHP scripts, tpl files, docs, etc - in the core (which can be placed outside the webroot) so that they are kept secure from web visitors. This keeps only the files that need to be accessed through the web by your Component in the web-accessible part of your site.

Next, we add a PHP resolver, called &#39;setupoptions.resolver.php&#39;. We&#39;ll get back to this in much more detail, because it actually deals with the setup options process we&#39;ll get to later.

And finally, we pack the vehicle into the package using the putVehicle function.

h2. Lexicons

So now we&#39;ve got a package with system settings, actions, menus, snippets, chunks, a category, and a few resolvers all set up. Let&#39;s talk about our lexicons.

We have our lexicon structured nicely in our \core/components/quip/lexicon directory:

!quip-dir2.png!

As you can see, we have a subdirectory as &#39;en&#39;, the IANA code for English. Then, we have a &#39;default.inc.php&#39; - this represents the &#39;default&#39; lexicon topic. Should we want to create separate lexicon topics, we would name them &#39;topicname.inc.php&#39;.

As of MODx Revolution RC-2, MODx will automatically find the lexicons in your lexicon directory, assuming that you put them in this structure in the following place: &#39;\{namespace_path\}lexicon/&#39;, where the Namespace path is the path you put for your Namespace earlier. You don&#39;t have to build in the lexicons directly at all; MODx will parse it for you.

This is because the lexicons are cached first from your files, then any overrides from the DB are merged and cached. This allows people to &#39;override&#39; your lexicons by using Lexicon Management in the Manager, should they choose to, without breaking their upgrade path for your Component.

h2. Package Attributes: License, Readme and Setup Options

Each package has what are called &#39;package attributes&#39;, which can be passed to any resolver or validator. You could pass pretty much anything you want into the function modPackageBuilder::setPackageAttributes(), in an array format. There are, however, three special keys that we&#39;ll deal with.

* *license* (string) - This represents your license agreement. Should MODx find this not empty during install, it will prompt the user to agree to it before they can proceed to install the package.
* *readme* (string) - This holds the readme. Before installing, if this is not empty, the user will be able to view the readme. This can be useful to make sure people see any requirements before they install.
* *setup-options* (string) - And here is the best part - this can be an HTML form (minus the form tags) that will pass any user-inputted options to the resolvers or validators. This means that you can take in user input before install, and process it during install\!

So let&#39;s use these in our build script:
{code}/* now pack in the license file, readme and setup options */
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;] . &#39;setup.options.php&#39;
    ),
));
{code}Obviously our license and readme values are being passed the contents of our license and readme files. We&#39;re doing them via file_get_contents() so that we can still store the actual files in the _modx/core/components/quip/docs_ directory after install, should the user want to view them later.

But &#39;setup-options&#39; looks a little different. We could just pass a file_get_contents() call that puts in a string, but then our setup options form wouldn&#39;t be dynamic\! There might be cases where you wouldn&#39;t want that, but we do. We want this options form to upgrade well. Note that you have to pass the file location as the &#39;source&#39; parameter - remember Resolvers? Looks familiar, eh? Same idea.

Our setup.options.php file looks like this:
{code}&lt;?php
/**
 * Build the setup options form.
 *
 * @package quip
 * @subpackage build
 */
/* set some default values */
$values = array(
    &#39;emailsTo&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsFrom&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsReplyTo&#39; =&gt; &#39;my@emailhere.com&#39;,
);
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) { $values[&#39;emailsTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) { $values[&#39;emailsFrom&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) { $values[&#39;emailsReplyTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);
    break;
    case xPDOTransport::ACTION_UNINSTALL: break;
}

$output = &#39;&lt;label for=&quot;quip-emailsTo&quot;&gt;Emails To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsTo&quot; id=&quot;quip-emailsTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsTo&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsFrom&quot;&gt;Emails From:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsFrom&quot; id=&quot;quip-emailsFrom&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsFrom&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsReplyTo&quot;&gt;Emails Reply-To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsReplyTo&quot; id=&quot;quip-emailsReplyTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsReplyTo&#39;].&#39;&quot; /&gt;&#39;;

return $output;
{code}As you can see, some new constants here. These are available to all setup options forms and resolvers:

* *xPDOTransport::PACKAGE_ACTION* \- This tells us what action is being performed on the package; it is one of the following 3 values:
** *xPDOTransport::ACTION_INSTALL* \- This is set when the package is being executed as an install.
** *xPDOTransport::ACTION_UPGRADE* \- This is set when the package is being upgraded.
** *xPDOTransport::ACTION_UNINSTALL* \- This is set when the package is being uninstalled. This doesn&#39;t apply to setup-options, obviously, since nothing is being set up. In future Revolution releases, it will allow you to do specific options for uninstall; but not yet.

Basically, we&#39;re presenting them with a form before install that looks like this:

!setupopt.png!

So that they can set or update the values of the emailsTo, emailsFrom, and emailsReplyTo system settings before they install the package. Now, the script will first check to see if those settings already exist; and if so, we&#39;ll fill them in with those values. This allows for upgrades to go gracefully, persisting the user&#39;s custom settings for those values. Pretty cool, huh?

Obviously, there&#39;s a lot you could do with this. You could set target directories for photo locations, setup basic email accounts, set login/pass information for 3rd party web service integrations, and more. We&#39;ll leave your imagination to do the work from here on out.

Let&#39;s go back to our PHP script resolver that processes this information:
{code}&lt;?php
/**
 * Resolves setup-options settings by setting email options.
 *
 * @package quip
 * @subpackage build
 */
$success= false;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        /* emailsTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsTo setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsFrom */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsFrom&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsFrom setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsReplyTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsReplyTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsReplyTo setting could not be found, so the setting could not be changed.&#39;);
        }

        $success= true;
        break;
    case xPDOTransport::ACTION_UNINSTALL:
        $success= true;
        break;
}
return $success;
{code}Note that $modx is not available here; you&#39;re actually running these scripts from within the transport object. The $modx object is available as a different name, however: $object-&gt;xpdo. $object is the object that the resolver is attached to; here, it would be the modCategory.

Our script, then, is setting the values set in the setup-options to the newly installed system settings.

And now that we&#39;ve got everything packaged and ready to go, let&#39;s pack the package into a zip file and give us the time it took to build the package:
{code}$builder-&gt;pack();

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\nPackage Built.\nExecution time: {$totalTime}\n&quot;);
exit();
{code}Great, we&#39;re done\! You&#39;ll only need to run this script now, and viola\! A fully zipped transport package file will appear in your core/packages directory.

[View the Source|http://modxcms.com/assets/tutorials/3pc/build.transport.phps]


h2. Related Pages

* [Package Management]
* [Transport Packages]
* [Transport Providers|Providers]

{scrollbar}";s:8:"versions";a:3:{i:0;a:3:{s:2:"id";s:8:"18678073";s:3:"ver";s:1:"3";s:4:"code";s:31891:"\\

{toc}
{note}Users using Revolution 2.0.0-beta-4 or earlier should note that the defines are different in beta5 and onward. An example: xPDOTransport::UNIQUE_KEYS in beta5\+ is XPDO_TRANSPORT_UNIQUE_KEYS in beta4 and earlier. MODx recommends to just update to beta5/SVN.{note}A build script. What is that, you might ask? This is the meat of the packaging process; here is where your component is actually put into the nice, neat .zip transport package that you find on modxcms.com or through Revolution&#39;s Package Management section.

This tutorial will guide you through how to create one of those scripts. We&#39;ll be using a sample component called Quip, which contains a modAction, a few menus, some chunks and a snippet, lexicons, setup options, a license, a readme, and system settings. It&#39;s basically a quick, easy run through of all the basics to creating a fundamental build script.

h2. Directory Structure

First off, let&#39;s take a quick look at our directory structure. This isn&#39;t always how you have to do it - this one is specifically built this way for SVN; but it&#39;s definitely recommended, especially with the _assets/components/quip/_ and _core/components/quip/_ structures, since that makes creating the transport package much easier.

!quip-dir1.png!

h2. Starting the Build Script

Let&#39;s first start with some phpdoc comments at the top, and then start the timer.
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0); /* makes sure our script doesnt timeout */
{code}Now let&#39;s define some basic paths. We can define these up top into a &quot;sources&quot; array to make them easier to reach later in the build script. Note how the &#39;source_core&#39; and &#39;source_assets&#39; directories do _not_ post-fix a foreslash onto their paths. This is required.
{code}$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/quip/lexicon/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root); /* save memory */
{code}Now, we&#39;ll need to include some files to get the build libraries we&#39;ll need. First, let&#39;s include a file we&#39;ll create called &#39;build.config.php&#39; in our build dir.
{code}require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
{code}In this file, we&#39;ll want to define the location of our MODx Revolution installation so that the build script can know where to get the modX class, as well as where to put the package when finished. Our file will look somewhat like this:
{code}&lt;?php
/**
 * Define the MODX path constants necessary for core installation
 *
 * @package quip
 * @subpackage build
 */
define(&#39;MODX_CORE_PATH&#39;, &#39;/absolute/path/to/modx/core/&#39;);
define(&#39;MODX_CONFIG_KEY&#39;,&#39;config&#39;);
{code}You&#39;ll want to make sure to change the value of MODX_CORE_PATH to the absolute path of where your MODx Revolution core is installed. MODX_CONFIG_KEY can stay the same, unless you&#39;re doing a multi-domain install.

Now, you&#39;ll want to include the modX class, and instantiate it. We&#39;ll also initialize it into the &#39;mgr&#39; context, and set the log output to HTML to make our errors and info messages nice and formatted - unless we&#39;re doing this from the cmd line, where we&#39;ll want just standard echo messages.
{code}require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);
{code}Okay, it&#39;s time for the meat. Let&#39;s first off use $modx-&gt;loadClass to load the modPackageBuilder class. Then we&#39;ll instantiate an instance of it, and create a package.
{code}$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha7&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}The modPackageBuilder::createPackage function has 3 parameters:
_name_, _version_, and _release_. For us,
we&#39;ll be doing quip-0.1-alpha7, so let&#39;s go with that.

Next, we&#39;ll register a [Namespace|Namespaces] to this package. Not all packages need [Namespaces]; but all 3rd Party Components do. Basically, a Namespace is an organizing tool for MODx so that MODx can know what objects are tied to what package. This is helpful later on should we want to uninstall our package; we&#39;d want it to remove the objects we&#39;d install.

Plus, should we want to add any [Lexicon Entries|Internationalization] to this package (which we will), MODx does so by relating it to it&#39;s Namespace. Our package builder will assign our Lexicon Entries to the Namespace, so we can easily manage _just_ our Lexicon Entries; not any others.

h2. Packaging in Objects

Objects are packaged as _Vehicles_ in MODx Revolution; basically think of a vehicle as a sort of storage system that transports the data and/or files into the zip package. Packages can contain many vehicles; vehicles can contain many objects or files - however, vehicles that contain an object must only have one reference object (or parent object, whichever you prefer) that the vehicle is based off of.

So, let&#39;s look at some examples for creating a vehicle before digging into our build script. This first example packages in a simple object, with some parameters:
{code}$snippet = $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,1);
$snippet-&gt;set(&#39;name&#39;,&#39;Test&#39;);
$vehicle = $builder-&gt;createVehicle($snippet,array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
));
{code}So, first off, we created a snippet object. Note that you&#39;ll have to specify an arbitrary ID for it, even though we wont keep it later. This is required. Then, we used the &#39;createVehicle&#39; function in modPackageBuilder to create the vehicle object. Let&#39;s look at those attributes options more closely:

* *xPDOTransport::UNIQUE_KEY* _(string/array)_ \- Here you&#39;d place the unique key that identifies the object you&#39;re creating. This will tell MODx to search for the modSnippet with the &#39;name&#39; equal to the packaged in name (here, &#39;Test&#39;) when updating or removing the object. For most objects, this will be &#39;name&#39;; others require different settings. Some might even require an array of two or more fields.
* *xPDOTransport::UPDATE_OBJECT* _(boolean)_ \- Either true or false, this tells MODx whether or not to update the object if it is found in the DB upon install (or update). Sometimes, if the object is already there, you may not want to update it - the update might erase the user&#39;s current settings for that object.
* *xPDOTransport::PRESERVE_KEYS* _(boolean)_ \- Either true or false, this tells MODx whether or not to rewrite the primary keys when the object is found. This can be useful if you&#39;re wanting the PKs to stay the same when you update - some PKs are auto_increment, and if you&#39;re wanting those to stay the same number, you&#39;d set this to true. Note: If the object already exists, this feature only works if xPDOTransport::UPDATE_OBJECT is set to true as well. If the object is not found, it will work regardless.

Simple enough? So our example tells it to look for a Snippet named &#39;Test&#39;, and if it finds it, update its contents. If it doesnt find it, create it. However, if it does find it; we told MODx not to update its PK - there&#39;s no need to adjust that in this situation.

Now, what about related objects? What if I want to package in my modMenu, along with its Action associated with the modMenu? Here&#39;s a bit more complex scenario:
{code}$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;0&#39;,
    &#39;controller&#39; =&gt; &#39;index&#39;,
    &#39;haslayout&#39; =&gt; &#39;1&#39;,
    &#39;lang_topics&#39; =&gt; &#39;quip:default,file&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;quip_desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; &#39;0&#39;,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
{code}Okay, a bit more meat here. We&#39;re introducing 2 new parameters:

* *xPDOTransport::RELATED_OBJECTS* _(boolean)_ \- Either true or false, this will tell MODx we want to search for related objects to this object. This must be set for the next parameter to work.
* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* _(array)_ \- This defines the types and details of the related objects we want to grab. If you note, the format is simply an associative array of attributes - similar to the parent object&#39;s attributes - where the key is the &quot;alias&quot; of the related object we want to grab. The aliases can be found in the Schema, located in _core/model/schema/modx.mysql.schema.xml_.

So our example above tells us on the modAction (found by looking for the modAction with a namespace of &#39;quip&#39; and a controller of &#39;index&#39;) to include the related modAction object that we package in. We packaged them in manually using xPDO&#39;s addOne function on the modAction.

Also, if we wanted to package in related objects to the modAction objects, we would just have had to define that in the &#39;Action&#39; attributes and addMany (or addOne) on that action. You can go however deep in nesting that you want.

So, back to our script. To recap, so far we have:
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;_build/lexicon/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha5&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}So, let&#39;s first package in our modActions and modMenus for our backend:
{code}/* load action/menu */
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;

$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$action); /* to keep memory low */
{code}Wait\! Notice how I put the action data in a different file? You don&#39;t have to do this - it&#39;s completely personal preference - but it does keep our build script clean, and isolate our actions/menus to a separate file for easy management.

Let&#39;s do the same with our system settings:
{code}/* load system settings */
$settings = include $sources[&#39;data&#39;].&#39;transport.settings.php&#39;;

$attributes= array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;key&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; false,
);
foreach ($settings as $setting) {
    $vehicle = $builder-&gt;createVehicle($setting,$attributes);
    $builder-&gt;putVehicle($vehicle);
}
unset($settings,$setting,$attributes);
{code}Great\! We&#39;ve got our actions, menus and settings packaged in. Now, using our newfound knowledge about related objects, let&#39;s create a category called &#39;Quip&#39; and put our Snippet and Chunks in that category. We&#39;ll go through this a bit slower, so we can easily see how this works:
{code}/* create category */
$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,&#39;Quip&#39;);
{code}Okay, great. Step one done: category created. Now about that Snippet:
{code}/* create the snippet */
$snippet= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,0);
$snippet-&gt;set(&#39;name&#39;, &#39;Quip&#39;);
$snippet-&gt;set(&#39;description&#39;, &#39;A simple commenting component.&#39;);
$snippet-&gt;set(&#39;snippet&#39;,file_get_contents($sources[&#39;source_core&#39;].&#39;/snippet.quip.php&#39;);
{code}Great\! Note how here we&#39;re actually using the file_get_contents() function to grab the contents of the snippet from our dev environment and place it here. This makes it easy to run the build in future iterations; no need to continually update this call - just update that file.

Now, we had some properties on that snippet...how do we put those in?
{code}$properties = include $sources[&#39;data&#39;].&#39;properties.inc.php&#39;;
$snippet-&gt;setProperties($properties);
$category-&gt;addMany($snippet);
{code}{note}

We&#39;re using the addMany method here, and not the addOne method. Wether you need to use one or the other does not so much depend on the amount of objects you are relating (in this case only one snippet), but the cardinality of the relationship. That may sound complex - but the cardinality simply means if it is a one-on-one or one-to-many relationship. In this case, a category has a one-to-many relationship with snippets (there can be many snippets in one category) and that means you will have to use the addMany method. You can pass an array of objects or just one object to that method, but which one you use depends on the cardinality. Read more about [relationships|xPDO20:Defining Relationships], [xPDO20:addOne] and [xPDO20:addMany].


{note}


You&#39;ll use modSnippet&#39;s setProperties function to pass in an array of property arrays. So, let&#39;s take a look at that properties.inc.php file:
{code}&lt;?php
/**
 * Default snippet properties
 *
 * @package quip
 * @subpackage build
 */
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;closed&#39;,
        &#39;desc&#39; =&gt; &#39;If set to true, the thread will not accept new comments.&#39;,
        &#39;type&#39; =&gt; &#39;combo-boolean&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; false,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dateFormat&#39;,
        &#39;desc&#39; =&gt; &#39;The format of the dates displayed for a comment.&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;%b %d, %Y at %I:%M %p&#39;,
    ),
    /* ...removed others for brevity... */
);
return $properties;
{code}Simple enough. And now on to the chunks:
{code}/* add chunks */
$chunks = include $sources[&#39;data&#39;].&#39;transport.chunks.php&#39;;
if (is_array($chunks)) {
    $category-&gt;addMany($chunks);
} else { $modx-&gt;log(modX::LOG_LEVEL_FATAL,&#39;Adding chunks failed.&#39;); }
{code}Good. We returned an array of chunks, and used modCategory&#39;s addMany() function to add them in. We also added a sanity check just in case we made a typo or something. Now, let&#39;s package all that into a vehicle:
{code}/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
        &#39;Chunks&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    )
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
{code}Great\! We&#39;ve got our category vehicle, complete with all the related chunks and snippet. They&#39;ll be installed in the right category when our users install our package, too - so it&#39;ll look nice and sharp\!

h2. Validators and Resolvers

Validators and resolvers are basically scripts that run during the install process. Validators are run pre-install; meaning that they are run before the main package installation happens. If they return false, the installation does not proceed.

Resolvers, on the other hand, execute after the main package has installed. They can either be file or PHP scripts. A file resolver simply copies over files into a specific target location. A PHP resolver executes a script after install.

With that said, we&#39;re going to attach 2 file resolvers, and one PHP resolver, to our script:

{code}$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;setupoptions.resolver.php&#39;,
));
$builder-&gt;putVehicle($vehicle);
{code}Okay, first things first. File resolvers take two options:

* *source* \- This is the target directory or script. If it&#39;s a file resolver, it must not end with a trailing slash and must be a valid directory. If it&#39;s a PHP script resolver, it must be a valid and accessible file.
* *target* \- Only applicable to file resolvers, this tells MODx where to install the source files. It is an eval()&#39;ed statement, so must be used as in the example. The standard MODx defines are available to you; use those to grab base paths to target.

So in our examples, we simply move all the files in our source core directory to modx/core/components/quip/ (since our directory that we&#39;re moving is named &quot;quip&quot;), and all the files in our source assets directory to modx/assets/components/quip/.

You might be asking why we&#39;re moving these to two directories. Well, in practice, it&#39;s best to keep non-web-accessible files - such as PHP scripts, tpl files, docs, etc - in the core (which can be placed outside the webroot) so that they are kept secure from web visitors. This keeps only the files that need to be accessed through the web by your Component in the web-accessible part of your site.

Next, we add a PHP resolver, called &#39;setupoptions.resolver.php&#39;. We&#39;ll get back to this in much more detail, because it actually deals with the setup options process we&#39;ll get to later.

And finally, we pack the vehicle into the package using the putVehicle function.

h2. Lexicons

So now we&#39;ve got a package with system settings, actions, menus, snippets, chunks, a category, and a few resolvers all set up. Let&#39;s talk about our lexicons.

We have our lexicon structured nicely in our \core/components/quip/lexicon directory:

!quip-dir2.png!

As you can see, we have a subdirectory as &#39;en&#39;, the IANA code for English. Then, we have a &#39;default.inc.php&#39; - this represents the &#39;default&#39; lexicon topic. Should we want to create separate lexicon topics, we would name them &#39;topicname.inc.php&#39;.

As of MODx Revolution RC-2, MODx will automatically find the lexicons in your lexicon directory, assuming that you put them in this structure in the following place: &#39;\{namespace_path\}lexicon/&#39;, where the Namespace path is the path you put for your Namespace earlier. You don&#39;t have to build in the lexicons directly at all; MODx will parse it for you.

This is because the lexicons are cached first from your files, then any overrides from the DB are merged and cached. This allows people to &#39;override&#39; your lexicons by using Lexicon Management in the Manager, should they choose to, without breaking their upgrade path for your Component.

h2. Package Attributes: License, Readme and Setup Options

Each package has what are called &#39;package attributes&#39;, which can be passed to any resolver or validator. You could pass pretty much anything you want into the function modPackageBuilder::setPackageAttributes(), in an array format. There are, however, three special keys that we&#39;ll deal with.

* *license* (string) - This represents your license agreement. Should MODx find this not empty during install, it will prompt the user to agree to it before they can proceed to install the package.
* *readme* (string) - This holds the readme. Before installing, if this is not empty, the user will be able to view the readme. This can be useful to make sure people see any requirements before they install.
* *setup-options* (string) - And here is the best part - this can be an HTML form (minus the form tags) that will pass any user-inputted options to the resolvers or validators. This means that you can take in user input before install, and process it during install\!

So let&#39;s use these in our build script:
{code}/* now pack in the license file, readme and setup options */
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;] . &#39;setup.options.php&#39;
    ),
));
{code}Obviously our license and readme values are being passed the contents of our license and readme files. We&#39;re doing them via file_get_contents() so that we can still store the actual files in the _modx/core/components/quip/docs_ directory after install, should the user want to view them later.

But &#39;setup-options&#39; looks a little different. We could just pass a file_get_contents() call that puts in a string, but then our setup options form wouldn&#39;t be dynamic\! There might be cases where you wouldn&#39;t want that, but we do. We want this options form to upgrade well. Note that you have to pass the file location as the &#39;source&#39; parameter - remember Resolvers? Looks familiar, eh? Same idea.

Our setup.options.php file looks like this:
{code}&lt;?php
/**
 * Build the setup options form.
 *
 * @package quip
 * @subpackage build
 */
/* set some default values */
$values = array(
    &#39;emailsTo&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsFrom&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsReplyTo&#39; =&gt; &#39;my@emailhere.com&#39;,
);
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) { $values[&#39;emailsTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) { $values[&#39;emailsFrom&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) { $values[&#39;emailsReplyTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);
    break;
    case xPDOTransport::ACTION_UNINSTALL: break;
}

$output = &#39;&lt;label for=&quot;quip-emailsTo&quot;&gt;Emails To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsTo&quot; id=&quot;quip-emailsTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsTo&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsFrom&quot;&gt;Emails From:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsFrom&quot; id=&quot;quip-emailsFrom&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsFrom&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsReplyTo&quot;&gt;Emails Reply-To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsReplyTo&quot; id=&quot;quip-emailsReplyTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsReplyTo&#39;].&#39;&quot; /&gt;&#39;;

return $output;
{code}As you can see, some new constants here. These are available to all setup options forms and resolvers:

* *xPDOTransport::PACKAGE_ACTION* \- This tells us what action is being performed on the package; it is one of the following 3 values:
** *xPDOTransport::ACTION_INSTALL* \- This is set when the package is being executed as an install.
** *xPDOTransport::ACTION_UPGRADE* \- This is set when the package is being upgraded.
** *xPDOTransport::ACTION_UNINSTALL* \- This is set when the package is being uninstalled. This doesn&#39;t apply to setup-options, obviously, since nothing is being set up. In future Revolution releases, it will allow you to do specific options for uninstall; but not yet.

Basically, we&#39;re presenting them with a form before install that looks like this:

!setupopt.png!

So that they can set or update the values of the emailsTo, emailsFrom, and emailsReplyTo system settings before they install the package. Now, the script will first check to see if those settings already exist; and if so, we&#39;ll fill them in with those values. This allows for upgrades to go gracefully, persisting the user&#39;s custom settings for those values. Pretty cool, huh?

Obviously, there&#39;s a lot you could do with this. You could set target directories for photo locations, setup basic email accounts, set login/pass information for 3rd party web service integrations, and more. We&#39;ll leave your imagination to do the work from here on out.

Let&#39;s go back to our PHP script resolver that processes this information:
{code}&lt;?php
/**
 * Resolves setup-options settings by setting email options.
 *
 * @package quip
 * @subpackage build
 */
$success= false;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        /* emailsTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsTo setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsFrom */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsFrom&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsFrom setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsReplyTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsReplyTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsReplyTo setting could not be found, so the setting could not be changed.&#39;);
        }

        $success= true;
        break;
    case xPDOTransport::ACTION_UNINSTALL:
        $success= true;
        break;
}
return $success;
{code}Note that $modx is not available here; you&#39;re actually running these scripts from within the transport object. The $modx object is available as a different name, however: $object-&gt;xpdo. $object is the object that the resolver is attached to; here, it would be the modCategory.

Our script, then, is setting the values set in the setup-options to the newly installed system settings.

And now that we&#39;ve got everything packaged and ready to go, let&#39;s pack the package into a zip file and give us the time it took to build the package:
{code}$builder-&gt;pack();

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\nPackage Built.\nExecution time: {$totalTime}\n&quot;);
exit();
{code}Great, we&#39;re done\! You&#39;ll only need to run this script now, and viola\! A fully zipped transport package file will appear in your core/packages directory.

[View the Source|http://modxcms.com/assets/tutorials/3pc/build.transport.phps]


h2. Related Pages

* [Package Management]
* [Transport Packages]
* [Transport Providers|Providers]

{scrollbar}";}i:1;a:3:{s:2:"id";s:8:"35586568";s:3:"ver";s:1:"2";s:4:"code";s:31124:"\\

{toc}
{note}Users using Revolution 2.0.0-beta-4 or earlier should note that the defines are different in beta5 and onward. An example: xPDOTransport::UNIQUE_KEYS in beta5\+ is XPDO_TRANSPORT_UNIQUE_KEYS in beta4 and earlier. MODx recommends to just update to beta5/SVN.{note}A build script. What is that, you might ask? This is the meat of the packaging process; here is where your component is actually put into the nice, neat .zip transport package that you find on modxcms.com or through Revolution&#39;s Package Management section.

This tutorial will guide you through how to create one of those scripts. We&#39;ll be using a sample component called Quip, which contains a modAction, a few menus, some chunks and a snippet, lexicons, setup options, a license, a readme, and system settings. It&#39;s basically a quick, easy run through of all the basics to creating a fundamental build script.

h2. Directory Structure

First off, let&#39;s take a quick look at our directory structure. This isn&#39;t always how you have to do it - this one is specifically built this way for SVN; but it&#39;s definitely recommended, especially with the _assets/components/quip/_ and _core/components/quip/_ structures, since that makes creating the transport package much easier.

!quip-dir1.png!

h2. Starting the Build Script

Let&#39;s first start with some phpdoc comments at the top, and then start the timer.
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0); /* makes sure our script doesnt timeout */
{code}Now let&#39;s define some basic paths. We can define these up top into a &quot;sources&quot; array to make them easier to reach later in the build script. Note how the &#39;source_core&#39; and &#39;source_assets&#39; directories do _not_ post-fix a foreslash onto their paths. This is required.
{code}$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/quip/lexicon/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root); /* save memory */
{code}Now, we&#39;ll need to include some files to get the build libraries we&#39;ll need. First, let&#39;s include a file we&#39;ll create called &#39;build.config.php&#39; in our build dir.
{code}require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
{code}In this file, we&#39;ll want to define the location of our MODx Revolution installation so that the build script can know where to get the modX class, as well as where to put the package when finished. Our file will look somewhat like this:
{code}&lt;?php
/**
 * Define the MODX path constants necessary for core installation
 *
 * @package quip
 * @subpackage build
 */
define(&#39;MODX_CORE_PATH&#39;, &#39;/absolute/path/to/modx/core/&#39;);
define(&#39;MODX_CONFIG_KEY&#39;,&#39;config&#39;);
{code}You&#39;ll want to make sure to change the value of MODX_CORE_PATH to the absolute path of where your MODx Revolution core is installed. MODX_CONFIG_KEY can stay the same, unless you&#39;re doing a multi-domain install.

Now, you&#39;ll want to include the modX class, and instantiate it. We&#39;ll also initialize it into the &#39;mgr&#39; context, and set the log output to HTML to make our errors and info messages nice and formatted - unless we&#39;re doing this from the cmd line, where we&#39;ll want just standard echo messages.
{code}require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);
{code}Okay, it&#39;s time for the meat. Let&#39;s first off use $modx-&gt;loadClass to load the modPackageBuilder class. Then we&#39;ll instantiate an instance of it, and create a package.
{code}$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha7&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}The modPackageBuilder::createPackage function has 3 parameters:
_name_, _version_, and _release_. For us,
we&#39;ll be doing quip-0.1-alpha7, so let&#39;s go with that.

Next, we&#39;ll register a [Namespace|Namespaces] to this package. Not all packages need [Namespaces]; but all 3rd Party Components do. Basically, a Namespace is an organizing tool for MODx so that MODx can know what objects are tied to what package. This is helpful later on should we want to uninstall our package; we&#39;d want it to remove the objects we&#39;d install.

Plus, should we want to add any [Lexicon Entries|Internationalization] to this package (which we will), MODx does so by relating it to it&#39;s Namespace. Our package builder will assign our Lexicon Entries to the Namespace, so we can easily manage _just_ our Lexicon Entries; not any others.

h2. Packaging in Objects

Objects are packaged as _Vehicles_ in MODx Revolution; basically think of a vehicle as a sort of storage system that transports the data and/or files into the zip package. Packages can contain many vehicles; vehicles can contain many objects or files - however, vehicles that contain an object must only have one reference object (or parent object, whichever you prefer) that the vehicle is based off of.

So, let&#39;s look at some examples for creating a vehicle before digging into our build script. This first example packages in a simple object, with some parameters:
{code}$snippet = $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,1);
$snippet-&gt;set(&#39;name&#39;,&#39;Test&#39;);
$vehicle = $builder-&gt;createVehicle($snippet,array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
));
{code}So, first off, we created a snippet object. Note that you&#39;ll have to specify an arbitrary ID for it, even though we wont keep it later. This is required. Then, we used the &#39;createVehicle&#39; function in modPackageBuilder to create the vehicle object. Let&#39;s look at those attributes options more closely:

* *xPDOTransport::UNIQUE_KEY* _(string/array)_ \- Here you&#39;d place the unique key that identifies the object you&#39;re creating. This will tell MODx to search for the modSnippet with the &#39;name&#39; equal to the packaged in name (here, &#39;Test&#39;) when updating or removing the object. For most objects, this will be &#39;name&#39;; others require different settings. Some might even require an array of two or more fields.
* *xPDOTransport::UPDATE_OBJECT* _(boolean)_ \- Either true or false, this tells MODx whether or not to update the object if it is found in the DB upon install (or update). Sometimes, if the object is already there, you may not want to update it - the update might erase the user&#39;s current settings for that object.
* *xPDOTransport::PRESERVE_KEYS* _(boolean)_ \- Either true or false, this tells MODx whether or not to rewrite the primary keys when the object is found. This can be useful if you&#39;re wanting the PKs to stay the same when you update - some PKs are auto_increment, and if you&#39;re wanting those to stay the same number, you&#39;d set this to true. Note: If the object already exists, this feature only works if xPDOTransport::UPDATE_OBJECT is set to true as well. If the object is not found, it will work regardless.

Simple enough? So our example tells it to look for a Snippet named &#39;Test&#39;, and if it finds it, update its contents. If it doesnt find it, create it. However, if it does find it; we told MODx not to update its PK - there&#39;s no need to adjust that in this situation.

Now, what about related objects? What if I want to package in my modMenu, along with its Action associated with the modMenu? Here&#39;s a bit more complex scenario:
{code}$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;0&#39;,
    &#39;controller&#39; =&gt; &#39;index&#39;,
    &#39;haslayout&#39; =&gt; &#39;1&#39;,
    &#39;lang_topics&#39; =&gt; &#39;quip:default,file&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;quip_desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; &#39;0&#39;,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
{code}Okay, a bit more meat here. We&#39;re introducing 2 new parameters:

* *xPDOTransport::RELATED_OBJECTS* _(boolean)_ \- Either true or false, this will tell MODx we want to search for related objects to this object. This must be set for the next parameter to work.
* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* _(array)_ \- This defines the types and details of the related objects we want to grab. If you note, the format is simply an associative array of attributes - similar to the parent object&#39;s attributes - where the key is the &quot;alias&quot; of the related object we want to grab. The aliases can be found in the Schema, located in _core/model/schema/modx.mysql.schema.xml_.

So our example above tells us on the modAction (found by looking for the modAction with a namespace of &#39;quip&#39; and a controller of &#39;index&#39;) to include the related modAction object that we package in. We packaged them in manually using xPDO&#39;s addOne function on the modAction.

Also, if we wanted to package in related objects to the modAction objects, we would just have had to define that in the &#39;Action&#39; attributes and addMany (or addOne) on that action. You can go however deep in nesting that you want.

So, back to our script. To recap, so far we have:
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;_build/lexicon/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha5&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}So, let&#39;s first package in our modActions and modMenus for our backend:
{code}/* load action/menu */
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;

$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$action); /* to keep memory low */
{code}Wait\! Notice how I put the action data in a different file? You don&#39;t have to do this - it&#39;s completely personal preference - but it does keep our build script clean, and isolate our actions/menus to a separate file for easy management.

Let&#39;s do the same with our system settings:
{code}/* load system settings */
$settings = include $sources[&#39;data&#39;].&#39;transport.settings.php&#39;;

$attributes= array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;key&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; false,
);
foreach ($settings as $setting) {
    $vehicle = $builder-&gt;createVehicle($setting,$attributes);
    $builder-&gt;putVehicle($vehicle);
}
unset($settings,$setting,$attributes);
{code}Great\! We&#39;ve got our actions, menus and settings packaged in. Now, using our newfound knowledge about related objects, let&#39;s create a category called &#39;Quip&#39; and put our Snippet and Chunks in that category. We&#39;ll go through this a bit slower, so we can easily see how this works:
{code}/* create category */
$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,&#39;Quip&#39;);
{code}Okay, great. Step one done: category created. Now about that Snippet:
{code}/* create the snippet */
$snippet= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,0);
$snippet-&gt;set(&#39;name&#39;, &#39;Quip&#39;);
$snippet-&gt;set(&#39;description&#39;, &#39;A simple commenting component.&#39;);
$snippet-&gt;set(&#39;snippet&#39;,file_get_contents($sources[&#39;source_core&#39;].&#39;/snippet.quip.php&#39;);
{code}Great\! Note how here we&#39;re actually using the file_get_contents() function to grab the contents of the snippet from our dev environment and place it here. This makes it easy to run the build in future iterations; no need to continually update this call - just update that file.

Now, we had some properties on that snippet...how do we put those in?
{code}$properties = include $sources[&#39;data&#39;].&#39;properties.inc.php&#39;;
$snippet-&gt;setProperties($properties);
$category-&gt;addMany($snippet);
{code}You&#39;ll use modSnippet&#39;s setProperties function to pass in an array of property arrays. So, let&#39;s take a look at that properties.inc.php file:
{code}&lt;?php
/**
 * Default snippet properties
 *
 * @package quip
 * @subpackage build
 */
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;closed&#39;,
        &#39;desc&#39; =&gt; &#39;If set to true, the thread will not accept new comments.&#39;,
        &#39;type&#39; =&gt; &#39;combo-boolean&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; false,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dateFormat&#39;,
        &#39;desc&#39; =&gt; &#39;The format of the dates displayed for a comment.&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;%b %d, %Y at %I:%M %p&#39;,
    ),
    /* ...removed others for brevity... */
);
return $properties;
{code}Simple enough. And now on to the chunks:
{code}/* add chunks */
$chunks = include $sources[&#39;data&#39;].&#39;transport.chunks.php&#39;;
if (is_array($chunks)) {
    $category-&gt;addMany($chunks);
} else { $modx-&gt;log(modX::LOG_LEVEL_FATAL,&#39;Adding chunks failed.&#39;); }
{code}Good. We returned an array of chunks, and used modCategory&#39;s addMany() function to add them in. We also added a sanity check just in case we made a typo or something. Now, let&#39;s package all that into a vehicle:
{code}/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
        &#39;Chunks&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    )
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
{code}Great\! We&#39;ve got our category vehicle, complete with all the related chunks and snippet. They&#39;ll be installed in the right category when our users install our package, too - so it&#39;ll look nice and sharp\!

h2. Validators and Resolvers

Validators and resolvers are basically scripts that run during the install process. Validators are run pre-install; meaning that they are run before the main package installation happens. If they return false, the installation does not proceed.

Resolvers, on the other hand, execute after the main package has installed. They can either be file or PHP scripts. A file resolver simply copies over files into a specific target location. A PHP resolver executes a script after install.

With that said, we&#39;re going to attach 2 file resolvers, and one PHP resolver, to our script:

{code}$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;setupoptions.resolver.php&#39;,
));
$builder-&gt;putVehicle($vehicle);
{code}Okay, first things first. File resolvers take two options:

* *source* \- This is the target directory or script. If it&#39;s a file resolver, it must not end with a trailing slash and must be a valid directory. If it&#39;s a PHP script resolver, it must be a valid and accessible file.
* *target* \- Only applicable to file resolvers, this tells MODx where to install the source files. It is an eval()&#39;ed statement, so must be used as in the example. The standard MODx defines are available to you; use those to grab base paths to target.

So in our examples, we simply move all the files in our source core directory to modx/core/components/quip/ (since our directory that we&#39;re moving is named &quot;quip&quot;), and all the files in our source assets directory to modx/assets/components/quip/.

You might be asking why we&#39;re moving these to two directories. Well, in practice, it&#39;s best to keep non-web-accessible files - such as PHP scripts, tpl files, docs, etc - in the core (which can be placed outside the webroot) so that they are kept secure from web visitors. This keeps only the files that need to be accessed through the web by your Component in the web-accessible part of your site.

Next, we add a PHP resolver, called &#39;setupoptions.resolver.php&#39;. We&#39;ll get back to this in much more detail, because it actually deals with the setup options process we&#39;ll get to later.

And finally, we pack the vehicle into the package using the putVehicle function.

h2. Lexicons

So now we&#39;ve got a package with system settings, actions, menus, snippets, chunks, a category, and a few resolvers all set up. Let&#39;s talk about our lexicons.

We have our lexicon structured nicely in our \core/components/quip/lexicon directory:

!quip-dir2.png!

As you can see, we have a subdirectory as &#39;en&#39;, the IANA code for English. Then, we have a &#39;default.inc.php&#39; - this represents the &#39;default&#39; lexicon topic. Should we want to create separate lexicon topics, we would name them &#39;topicname.inc.php&#39;.

As of MODx Revolution RC-2, MODx will automatically find the lexicons in your lexicon directory, assuming that you put them in this structure in the following place: &#39;\{namespace_path\}lexicon/&#39;, where the Namespace path is the path you put for your Namespace earlier. You don&#39;t have to build in the lexicons directly at all; MODx will parse it for you.

This is because the lexicons are cached first from your files, then any overrides from the DB are merged and cached. This allows people to &#39;override&#39; your lexicons by using Lexicon Management in the Manager, should they choose to, without breaking their upgrade path for your Component.

h2. Package Attributes: License, Readme and Setup Options

Each package has what are called &#39;package attributes&#39;, which can be passed to any resolver or validator. You could pass pretty much anything you want into the function modPackageBuilder::setPackageAttributes(), in an array format. There are, however, three special keys that we&#39;ll deal with.

* *license* (string) - This represents your license agreement. Should MODx find this not empty during install, it will prompt the user to agree to it before they can proceed to install the package.
* *readme* (string) - This holds the readme. Before installing, if this is not empty, the user will be able to view the readme. This can be useful to make sure people see any requirements before they install.
* *setup-options* (string) - And here is the best part - this can be an HTML form (minus the form tags) that will pass any user-inputted options to the resolvers or validators. This means that you can take in user input before install, and process it during install\!

So let&#39;s use these in our build script:
{code}/* now pack in the license file, readme and setup options */
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;] . &#39;setup.options.php&#39;
    ),
));
{code}Obviously our license and readme values are being passed the contents of our license and readme files. We&#39;re doing them via file_get_contents() so that we can still store the actual files in the _modx/core/components/quip/docs_ directory after install, should the user want to view them later.

But &#39;setup-options&#39; looks a little different. We could just pass a file_get_contents() call that puts in a string, but then our setup options form wouldn&#39;t be dynamic\! There might be cases where you wouldn&#39;t want that, but we do. We want this options form to upgrade well. Note that you have to pass the file location as the &#39;source&#39; parameter - remember Resolvers? Looks familiar, eh? Same idea.

Our setup.options.php file looks like this:
{code}&lt;?php
/**
 * Build the setup options form.
 *
 * @package quip
 * @subpackage build
 */
/* set some default values */
$values = array(
    &#39;emailsTo&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsFrom&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsReplyTo&#39; =&gt; &#39;my@emailhere.com&#39;,
);
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) { $values[&#39;emailsTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) { $values[&#39;emailsFrom&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) { $values[&#39;emailsReplyTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);
    break;
    case xPDOTransport::ACTION_UNINSTALL: break;
}

$output = &#39;&lt;label for=&quot;quip-emailsTo&quot;&gt;Emails To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsTo&quot; id=&quot;quip-emailsTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsTo&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsFrom&quot;&gt;Emails From:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsFrom&quot; id=&quot;quip-emailsFrom&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsFrom&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsReplyTo&quot;&gt;Emails Reply-To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsReplyTo&quot; id=&quot;quip-emailsReplyTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsReplyTo&#39;].&#39;&quot; /&gt;&#39;;

return $output;
{code}As you can see, some new constants here. These are available to all setup options forms and resolvers:

* *xPDOTransport::PACKAGE_ACTION* \- This tells us what action is being performed on the package; it is one of the following 3 values:
** *xPDOTransport::ACTION_INSTALL* \- This is set when the package is being executed as an install.
** *xPDOTransport::ACTION_UPGRADE* \- This is set when the package is being upgraded.
** *xPDOTransport::ACTION_UNINSTALL* \- This is set when the package is being uninstalled. This doesn&#39;t apply to setup-options, obviously, since nothing is being set up. In future Revolution releases, it will allow you to do specific options for uninstall; but not yet.

Basically, we&#39;re presenting them with a form before install that looks like this:

!setupopt.png!

So that they can set or update the values of the emailsTo, emailsFrom, and emailsReplyTo system settings before they install the package. Now, the script will first check to see if those settings already exist; and if so, we&#39;ll fill them in with those values. This allows for upgrades to go gracefully, persisting the user&#39;s custom settings for those values. Pretty cool, huh?

Obviously, there&#39;s a lot you could do with this. You could set target directories for photo locations, setup basic email accounts, set login/pass information for 3rd party web service integrations, and more. We&#39;ll leave your imagination to do the work from here on out.

Let&#39;s go back to our PHP script resolver that processes this information:
{code}&lt;?php
/**
 * Resolves setup-options settings by setting email options.
 *
 * @package quip
 * @subpackage build
 */
$success= false;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        /* emailsTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsTo setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsFrom */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsFrom&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsFrom setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsReplyTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsReplyTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsReplyTo setting could not be found, so the setting could not be changed.&#39;);
        }

        $success= true;
        break;
    case xPDOTransport::ACTION_UNINSTALL:
        $success= true;
        break;
}
return $success;
{code}Note that $modx is not available here; you&#39;re actually running these scripts from within the transport object. The $modx object is available as a different name, however: $object-&gt;xpdo. $object is the object that the resolver is attached to; here, it would be the modCategory.

Our script, then, is setting the values set in the setup-options to the newly installed system settings.

And now that we&#39;ve got everything packaged and ready to go, let&#39;s pack the package into a zip file and give us the time it took to build the package:
{code}$builder-&gt;pack();

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\nPackage Built.\nExecution time: {$totalTime}\n&quot;);
exit();
{code}Great, we&#39;re done\! You&#39;ll only need to run this script now, and viola\! A fully zipped transport package file will appear in your core/packages directory.

[View the Source|http://modxcms.com/assets/tutorials/3pc/build.transport.phps]

h2. Related Pages

* [Package Management]
* [Transport Packages]
* [Transport Providers|Providers]

{scrollbar}";}i:2;a:3:{s:2:"id";s:8:"33227197";s:3:"ver";s:1:"1";s:4:"code";s:31123:"\\

{toc}
{note}Users using Revolution 2.0.0-beta-4 or earlier should note that the defines are different in beta5 and onward. An example: xPDOTransport::UNIQUE_KEYS in beta5\+ is XPDO_TRANSPORT_UNIQUE_KEYS in beta4 and earlier. MODx recommends to just update to beta5/SVN.{note}A build script. What is that, you might ask? This is the meat of the packaging process; here is where your component is actually put into the nice, neat .zip transport package that you find on modxcms.com or through Revolution&#39;s Package Management section.

This tutorial will guide you through how to create one of those scripts. We&#39;ll be using a sample component called Quip, which contains a modAction, a few menus, some chunks and a snippet, lexicons, setup options, a license, a readme, and system settings. It&#39;s basically a quick, easy run through of all the basics to creating a fundamental build script.

h2. Directory Structure

First off, let&#39;s take a quick look at our directory structure. This isn&#39;t always how you have to do it - this one is specifically built this way for SVN; but it&#39;s definitely recommended, especially with the _assets/components/quip/_ and _core/components/quip/_ structures, since that makes creating the transport package much easier.

!quip-dir1.png!

h2. Starting the Build Script

Let&#39;s first start with some phpdoc comments at the top, and then start the timer.
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0); /* makes sure our script doesnt timeout */
{code}Now let&#39;s define some basic paths. We can define these up top into a &quot;sources&quot; array to make them easier to reach later in the build script. Note how the &#39;source_core&#39; and &#39;source_assets&#39; directories do _not_ post-fix a foreslash onto their paths. This is required.
{code}$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;core/components/quip/lexicon/&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root); /* save memory */
{code}Now, we&#39;ll need to include some files to get the build libraries we&#39;ll need. First, let&#39;s include a file we&#39;ll create called &#39;build.config.php&#39; in our build dir.
{code}require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
{code}In this file, we&#39;ll want to define the location of our MODx Revolution installation so that the build script can know where to get the modX class, as well as where to put the package when finished. Our file will look somewhat like this:
{code}&lt;?php
/**
 * Define the MODX path constants necessary for core installation
 *
 * @package quip
 * @subpackage build
 */
define(&#39;MODX_CORE_PATH&#39;, &#39;/absolute/path/to/modx/core/&#39;);
define(&#39;MODX_CONFIG_KEY&#39;,&#39;config&#39;);
{code}You&#39;ll want to make sure to change the value of MODX_CORE_PATH to the absolute path of where your MODx Revolution core is installed. MODX_CONFIG_KEY can stay the same, unless you&#39;re doing a multi-domain install.

Now, you&#39;ll want to include the modX class, and instantiate it. We&#39;ll also initialize it into the &#39;mgr&#39; context, and set the log output to HTML to make our errors and info messages nice and formatted - unless we&#39;re doing this from the cmd line, where we&#39;ll want just standard echo messages.
{code}require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);
{code}Okay, it&#39;s time for the meat. Let&#39;s first off use $modx-&gt;loadClass to load the modPackageBuilder class. Then we&#39;ll instantiate an instance of it, and create a package.
{code}$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha7&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}The modPackageBuilder::createPackage function has 3 parameters:
_name_, _version_, and _release_. For us,
we&#39;ll be doing quip-0.1-alpha7, so let&#39;s go with that.

Next, we&#39;ll register a [Namespace|Namespaces] to this package. Not all packages need [Namespaces]; but all 3rd Party Components do. Basically, a Namespace is an organizing tool for MODx so that MODx can know what objects are tied to what package. This is helpful later on should we want to uninstall our package; we&#39;d want it to remove the objects we&#39;d install.

Plus, should we want to add any [Lexicon Entries|Internationalization] to this package (which we will), MODx does so by relating it to it&#39;s Namespace. Our package builder will assign our Lexicon Entries to the Namespace, so we can easily manage _just_ our Lexicon Entries; not any others.

h2. Packaging in Objects

Objects are packaged as _Vehicles_ in MODx Revolution; basically think of a vehicle as a sort of storage system that transports the data and/or files into the zip package. Packages can contain many vehicles; vehicles can contain many objectsor files - however, vehicles that contain an object must only have one reference object (or parent object, whichever you prefer) that the vehicle is based off of.

So, let&#39;s look at some examples for creating a vehicle before digging into our build script. This first example packages in a simple object, with some parameters:
{code}$snippet = $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,1);
$snippet-&gt;set(&#39;name&#39;,&#39;Test&#39;);
$vehicle = $builder-&gt;createVehicle($snippet,array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
));
{code}So, first off, we created a snippet object. Note that you&#39;ll have to specify an arbitrary ID for it, even though we wont keep it later. This is required. Then, we used the &#39;createVehicle&#39; function in modPackageBuilder to create the vehicle object. Let&#39;s look at those attributes options more closely:

* *xPDOTransport::UNIQUE_KEY* _(string/array)_ \- Here you&#39;d place the unique key that identifies the object you&#39;re creating. This will tell MODx to search for the modSnippet with the &#39;name&#39; equal to the packaged in name (here, &#39;Test&#39;) when updating or removing the object. For most objects, this will be &#39;name&#39;; others require different settings. Some might even require an array of two or more fields.
* *xPDOTransport::UPDATE_OBJECT* _(boolean)_ \- Either true or false, this tells MODx whether or not to update the object if it is found in the DB upon install (or update). Sometimes, if the object is already there, you may not want to update it - the update might erase the user&#39;s current settings for that object.
* *xPDOTransport::PRESERVE_KEYS* _(boolean)_ \- Either true or false, this tells MODx whether or not to rewrite the primary keys when the object is found. This can be useful if you&#39;re wanting the PKs to stay the same when you update - some PKs are auto_increment, and if you&#39;re wanting those to stay the same number, you&#39;d set this to true. Note: If the object already exists, this feature only works if xPDOTransport::UPDATE_OBJECT is set to true as well. If the object is not found, it will work regardless.

Simple enough? So our example tells it to look for a Snippet named &#39;Test&#39;, and if it finds it, update its contents. If it doesnt find it, create it. However, if it does find it; we told MODx not to update its PK - there&#39;s no need to adjust that in this situation.

Now, what about related objects? What if I want to package in my modMenu, along with its Action associated with the modMenu? Here&#39;s a bit more complex scenario:
{code}$action= $modx-&gt;newObject(&#39;modAction&#39;);
$action-&gt;fromArray(array(
    &#39;id&#39; =&gt; 1,
    &#39;namespace&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;0&#39;,
    &#39;controller&#39; =&gt; &#39;index&#39;,
    &#39;haslayout&#39; =&gt; &#39;1&#39;,
    &#39;lang_topics&#39; =&gt; &#39;quip:default,file&#39;,
    &#39;assets&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu= $modx-&gt;newObject(&#39;modMenu&#39;);
$menu-&gt;fromArray(array(
    &#39;text&#39; =&gt; &#39;quip&#39;,
    &#39;parent&#39; =&gt; &#39;components&#39;,
    &#39;description&#39; =&gt; &#39;quip_desc&#39;,
    &#39;icon&#39; =&gt; &#39;images/icons/plugin.gif&#39;,
    &#39;menuindex&#39; =&gt; &#39;0&#39;,
    &#39;params&#39; =&gt; &#39;&#39;,
    &#39;handler&#39; =&gt; &#39;&#39;,
),&#39;&#39;,true,true);
$menu-&gt;addOne($action);
$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
{code}Okay, a bit more meat here. We&#39;re introducing 2 new parameters:

* *xPDOTransport::RELATED_OBJECTS* _(boolean)_ \- Either true or false, this will tell MODx we want to search for related objects to this object. This must be set for the next parameter to work.
* *xPDOTransport::RELATED_OBJECT_ATTRIBUTES* _(array)_ \- This defines the types and details of the related objects we want to grab. If you note, the format is simply an associative array of attributes - similar to the parent object&#39;s attributes - where the key is the &quot;alias&quot; of the related object we want to grab. The aliases can be found in the Schema, located in _core/model/schema/modx.mysql.schema.xml_.

So our example above tells us on the modAction (found by looking for the modAction with a namespace of &#39;quip&#39; and a controller of &#39;index&#39;) to include the related modAction object that we package in. We packaged them in manually using xPDO&#39;s addOne function on the modAction.

Also, if we wanted to package in related objects to the modAction objects, we would just have had to define that in the &#39;Action&#39; attributes and addMany (or addOne) on that action. You can go however deep in nesting that you want.

So, back to our script. To recap, so far we have:
{code}&lt;?php
/**
 * Quip build script
 *
 * @package quip
 * @subpackage build
 */
$mtime = microtime();
$mtime = explode(&quot; &quot;, $mtime);
$mtime = $mtime[1] + $mtime[0];
$tstart = $mtime;
set_time_limit(0);

$root = dirname(dirname(__FILE__)).&#39;/&#39;;
$sources= array (
    &#39;root&#39; =&gt; $root,
    &#39;build&#39; =&gt; $root .&#39;_build/&#39;,
    &#39;lexicon&#39; =&gt; $root . &#39;_build/lexicon/&#39;,
    &#39;resolvers&#39; =&gt; $root . &#39;_build/resolvers/&#39;,
    &#39;data&#39; =&gt; $root . &#39;_build/data/&#39;,
    &#39;source_core&#39; =&gt; $root.&#39;core/components/quip&#39;,
    &#39;source_assets&#39; =&gt; $root.&#39;assets/components/quip&#39;,
    &#39;docs&#39; =&gt; $root.&#39;core/components/quip/docs/&#39;,
);
unset($root);

/* override with your own defines here (see build.config.sample.php) */
require_once dirname(__FILE__) . &#39;/build.config.php&#39;;
require_once MODX_CORE_PATH . &#39;model/modx/modx.class.php&#39;;

$modx= new modX();
$modx-&gt;initialize(&#39;mgr&#39;);
$modx-&gt;setLogLevel(modX::LOG_LEVEL_INFO);
$modx-&gt;setLogTarget(XPDO_CLI_MODE ? &#39;ECHO&#39; : &#39;HTML&#39;);

$modx-&gt;loadClass(&#39;transport.modPackageBuilder&#39;,&#39;&#39;,false, true);
$builder = new modPackageBuilder($modx);
$builder-&gt;createPackage(&#39;quip&#39;,&#39;0.1&#39;,&#39;alpha5&#39;);
$builder-&gt;registerNamespace(&#39;quip&#39;,false,true,&#39;{core_path}components/quip/&#39;);
{code}So, let&#39;s first package in our modActions and modMenus for our backend:
{code}/* load action/menu */
$menu = include $sources[&#39;data&#39;].&#39;transport.menu.php&#39;;

$vehicle= $builder-&gt;createVehicle($menu,array (
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::UNIQUE_KEY =&gt; &#39;text&#39;,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Action&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; array (&#39;namespace&#39;,&#39;controller&#39;),
        ),
    ),
));
$builder-&gt;putVehicle($vehicle);
unset($vehicle,$action); /* to keep memory low */
{code}Wait\! Notice how I put the action data in a different file? You don&#39;t have to do this - it&#39;s completely personal preference - but it does keep our build script clean, and isolate our actions/menus to a separate file for easy management.

Let&#39;s do the same with our system settings:
{code}/* load system settings */
$settings = include $sources[&#39;data&#39;].&#39;transport.settings.php&#39;;

$attributes= array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;key&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; true,
    xPDOTransport::UPDATE_OBJECT =&gt; false,
);
foreach ($settings as $setting) {
    $vehicle = $builder-&gt;createVehicle($setting,$attributes);
    $builder-&gt;putVehicle($vehicle);
}
unset($settings,$setting,$attributes);
{code}Great\! We&#39;ve got our actions, menus and settings packaged in. Now, using our newfound knowledge about related objects, let&#39;s create a category called &#39;Quip&#39; and put our Snippet and Chunks in that category. We&#39;ll go through this a bit slower, so we can easily see how this works:
{code}/* create category */
$category= $modx-&gt;newObject(&#39;modCategory&#39;);
$category-&gt;set(&#39;id&#39;,1);
$category-&gt;set(&#39;category&#39;,&#39;Quip&#39;);
{code}Okay, great. Step one done: category created. Now about that Snippet:
{code}/* create the snippet */
$snippet= $modx-&gt;newObject(&#39;modSnippet&#39;);
$snippet-&gt;set(&#39;id&#39;,0);
$snippet-&gt;set(&#39;name&#39;, &#39;Quip&#39;);
$snippet-&gt;set(&#39;description&#39;, &#39;A simple commenting component.&#39;);
$snippet-&gt;set(&#39;snippet&#39;,file_get_contents($sources[&#39;source_core&#39;].&#39;/snippet.quip.php&#39;);
{code}Great\! Note how here we&#39;re actually using the file_get_contents() function to grab the contents of the snippet from our dev environment and place it here. This makes it easy to run the build in future iterations; no need to continually update this call - just update that file.

Now, we had some properties on that snippet...how do we put those in?
{code}$properties = include $sources[&#39;data&#39;].&#39;properties.inc.php&#39;;
$snippet-&gt;setProperties($properties);
$category-&gt;addMany($snippet);
{code}You&#39;ll use modSnippet&#39;s setProperties function to pass in an array of property arrays. So, let&#39;s take a look at that properties.inc.php file:
{code}&lt;?php
/**
 * Default snippet properties
 *
 * @package quip
 * @subpackage build
 */
$properties = array(
    array(
        &#39;name&#39; =&gt; &#39;closed&#39;,
        &#39;desc&#39; =&gt; &#39;If set to true, the thread will not accept new comments.&#39;,
        &#39;type&#39; =&gt; &#39;combo-boolean&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; false,
    ),
    array(
        &#39;name&#39; =&gt; &#39;dateFormat&#39;,
        &#39;desc&#39; =&gt; &#39;The format of the dates displayed for a comment.&#39;,
        &#39;type&#39; =&gt; &#39;textfield&#39;,
        &#39;options&#39; =&gt; &#39;&#39;,
        &#39;value&#39; =&gt; &#39;%b %d, %Y at %I:%M %p&#39;,
    ),
    /* ...removed others for brevity... */
);
return $properties;
{code}Simple enough. And now on to the chunks:
{code}/* add chunks */
$chunks = include $sources[&#39;data&#39;].&#39;transport.chunks.php&#39;;
if (is_array($chunks)) {
    $category-&gt;addMany($chunks);
} else { $modx-&gt;log(modX::LOG_LEVEL_FATAL,&#39;Adding chunks failed.&#39;); }
{code}Good. We returned an array of chunks, and used modCategory&#39;s addMany() function to add them in. We also added a sanity check just in case we made a typo or something. Now, let&#39;s package all that into a vehicle:
{code}/* create category vehicle */
$attr = array(
    xPDOTransport::UNIQUE_KEY =&gt; &#39;category&#39;,
    xPDOTransport::PRESERVE_KEYS =&gt; false,
    xPDOTransport::UPDATE_OBJECT =&gt; true,
    xPDOTransport::RELATED_OBJECTS =&gt; true,
    xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; array (
        &#39;Snippets&#39; =&gt; array(
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
        &#39;Chunks&#39; =&gt; array (
            xPDOTransport::PRESERVE_KEYS =&gt; false,
            xPDOTransport::UPDATE_OBJECT =&gt; true,
            xPDOTransport::UNIQUE_KEY =&gt; &#39;name&#39;,
        ),
    )
);
$vehicle = $builder-&gt;createVehicle($category,$attr);
{code}Great\! We&#39;ve got our category vehicle, complete with all the related chunks and snippet. They&#39;ll be installed in the right category when our users install our package, too - so it&#39;ll look nice and sharp\!

h2. Validators and Resolvers

Validators and resolvers are basically scripts that run during the install process. Validators are run pre-install; meaning that they are run before the main package installation happens. If they return false, the installation does not proceed.

Resolvers, on the other hand, execute after the main package has installed. They can either be file or PHP scripts. A file resolver simply copies over files into a specific target location. A PHP resolver executes a script after install.

With that said, we&#39;re going to attach 2 file resolvers, and one PHP resolver, to our script:

{code}$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_core&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_CORE_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;file&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;source_assets&#39;],
    &#39;target&#39; =&gt; &quot;return MODX_ASSETS_PATH . &#39;components/&#39;;&quot;,
));
$vehicle-&gt;resolve(&#39;php&#39;,array(
    &#39;source&#39; =&gt; $sources[&#39;resolvers&#39;] . &#39;setupoptions.resolver.php&#39;,
));
$builder-&gt;putVehicle($vehicle);
{code}Okay, first things first. File resolvers take two options:

* *source* \- This is the target directory or script. If it&#39;s a file resolver, it must not end with a trailing slash and must be a valid directory. If it&#39;s a PHP script resolver, it must be a valid and accessible file.
* *target* \- Only applicable to file resolvers, this tells MODx where to install the source files. It is an eval()&#39;ed statement, so must be used as in the example. The standard MODx defines are available to you; use those to grab base paths to target.

So in our examples, we simply move all the files in our source core directory to modx/core/components/quip/ (since our directory that we&#39;re moving is named &quot;quip&quot;), and all the files in our source assets directory to modx/assets/components/quip/.

You might be asking why we&#39;re moving these to two directories. Well, in practice, it&#39;s best to keep non-web-accessible files - such as PHP scripts, tpl files, docs, etc - in the core (which can be placed outside the webroot) so that they are kept secure from web visitors. This keeps only the files that need to be accessed through the web by your Component in the web-accessible part of your site.

Next, we add a PHP resolver, called &#39;setupoptions.resolver.php&#39;. We&#39;ll get back to this in much more detail, because it actually deals with the setup options process we&#39;ll get to later.

And finally, we pack the vehicle into the package using the putVehicle function.

h2. Lexicons

So now we&#39;ve got a package with system settings, actions, menus, snippets, chunks, a category, and a few resolvers all set up. Let&#39;s talk about our lexicons.

We have our lexicon structured nicely in our \core/components/quip/lexicon directory:

!quip-dir2.png!

As you can see, we have a subdirectory as &#39;en&#39;, the IANA code for English. Then, we have a &#39;default.inc.php&#39; - this represents the &#39;default&#39; lexicon topic. Should we want to create separate lexicon topics, we would name them &#39;topicname.inc.php&#39;.

As of MODx Revolution RC-2, MODx will automatically find the lexicons in your lexicon directory, assuming that you put them in this structure in the following place: &#39;\{namespace_path\}lexicon/&#39;, where the Namespace path is the path you put for your Namespace earlier. You don&#39;t have to build in the lexicons directly at all; MODx will parse it for you.

This is because the lexicons are cached first from your files, then any overrides from the DB are merged and cached. This allows people to &#39;override&#39; your lexicons by using Lexicon Management in the Manager, should they choose to, without breaking their upgrade path for your Component.

h2. Package Attributes: License, Readme and Setup Options

Each package has what are called &#39;package attributes&#39;, which can be passed to any resolver or validator. You could pass pretty much anything you want into the function modPackageBuilder::setPackageAttributes(), in an array format. There are, however, three special keys that we&#39;ll deal with.

* *license* (string) - This represents your license agreement. Should MODx find this not empty during install, it will prompt the user to agree to it before they can proceed to install the package.
* *readme* (string) - This holds the readme. Before installing, if this is not empty, the user will be able to view the readme. This can be useful to make sure people see any requirements before they install.
* *setup-options* (string) - And here is the best part - this can be an HTML form (minus the form tags) that will pass any user-inputted options to the resolvers or validators. This means that you can take in user input before install, and process it during install\!

So let&#39;s use these in our build script:
{code}/* now pack in the license file, readme and setup options */
$builder-&gt;setPackageAttributes(array(
    &#39;license&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;license.txt&#39;),
    &#39;readme&#39; =&gt; file_get_contents($sources[&#39;docs&#39;] . &#39;readme.txt&#39;),
    &#39;setup-options&#39; =&gt; array(
        &#39;source&#39; =&gt; $sources[&#39;build&#39;] . &#39;setup.options.php&#39;
    ),
));
{code}Obviously our license and readme values are being passed the contents of our license and readme files. We&#39;re doing them via file_get_contents() so that we can still store the actual files in the _modx/core/components/quip/docs_ directory after install, should the user want to view them later.

But &#39;setup-options&#39; looks a little different. We could just pass a file_get_contents() call that puts in a string, but then our setup options form wouldn&#39;t be dynamic\! There might be cases where you wouldn&#39;t want that, but we do. We want this options form to upgrade well. Note that you have to pass the file location as the &#39;source&#39; parameter - remember Resolvers? Looks familiar, eh? Same idea.

Our setup.options.php file looks like this:
{code}&lt;?php
/**
 * Build the setup options form.
 *
 * @package quip
 * @subpackage build
 */
/* set some default values */
$values = array(
    &#39;emailsTo&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsFrom&#39; =&gt; &#39;my@emailhere.com&#39;,
    &#39;emailsReplyTo&#39; =&gt; &#39;my@emailhere.com&#39;,
);
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) { $values[&#39;emailsTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) { $values[&#39;emailsFrom&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);

        $setting = $modx-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) { $values[&#39;emailsReplyTo&#39;] = $setting-&gt;get(&#39;value&#39;); }
        unset($setting);
    break;
    case xPDOTransport::ACTION_UNINSTALL: break;
}

$output = &#39;&lt;label for=&quot;quip-emailsTo&quot;&gt;Emails To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsTo&quot; id=&quot;quip-emailsTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsTo&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsFrom&quot;&gt;Emails From:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsFrom&quot; id=&quot;quip-emailsFrom&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsFrom&#39;].&#39;&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;label for=&quot;quip-emailsReplyTo&quot;&gt;Emails Reply-To:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;emailsReplyTo&quot; id=&quot;quip-emailsReplyTo&quot; width=&quot;300&quot; value=&quot;&#39;.$values[&#39;emailsReplyTo&#39;].&#39;&quot; /&gt;&#39;;

return $output;
{code}As you can see, some new constants here. These are available to all setup options forms and resolvers:

* *xPDOTransport::PACKAGE_ACTION* \- This tells us what action is being performed on the package; it is one of the following 3 values:
** *xPDOTransport::ACTION_INSTALL* \- This is set when the package is being executed as an install.
** *xPDOTransport::ACTION_UPGRADE* \- This is set when the package is being upgraded.
** *xPDOTransport::ACTION_UNINSTALL* \- This is set when the package is being uninstalled. This doesn&#39;t apply to setup-options, obviously, since nothing is being set up. In future Revolution releases, it will allow you to do specific options for uninstall; but not yet.

Basically, we&#39;re presenting them with a form before install that looks like this:

!setupopt.png!

So that they can set or update the values of the emailsTo, emailsFrom, and emailsReplyTo system settings before they install the package. Now, the script will first check to see if those settings already exist; and if so, we&#39;ll fill them in with those values. This allows for upgrades to go gracefully, persisting the user&#39;s custom settings for those values. Pretty cool, huh?

Obviously, there&#39;s a lot you could do with this. You could set target directories for photo locations, setup basic email accounts, set login/pass information for 3rd party web service integrations, and more. We&#39;ll leave your imagination to do the work from here on out.

Let&#39;s go back to our PHP script resolver that processes this information:
{code}&lt;?php
/**
 * Resolves setup-options settings by setting email options.
 *
 * @package quip
 * @subpackage build
 */
$success= false;
switch ($options[xPDOTransport::PACKAGE_ACTION]) {
    case xPDOTransport::ACTION_INSTALL:
    case xPDOTransport::ACTION_UPGRADE:
        /* emailsTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsTo setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsFrom */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsFrom&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsFrom&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsFrom setting could not be found, so the setting could not be changed.&#39;);
        }

        /* emailsReplyTo */
        $setting = $object-&gt;xpdo-&gt;getObject(&#39;modSystemSetting&#39;,array(&#39;key&#39; =&gt; &#39;quip.emailsReplyTo&#39;));
        if ($setting != null) {
            $setting-&gt;set(&#39;value&#39;,$options[&#39;emailsReplyTo&#39;]);
            $setting-&gt;save();
        } else {
            $object-&gt;xpdo-&gt;log(xPDO::LOG_LEVEL_ERROR,&#39;[Quip] emailsReplyTo setting could not be found, so the setting could not be changed.&#39;);
        }

        $success= true;
        break;
    case xPDOTransport::ACTION_UNINSTALL:
        $success= true;
        break;
}
return $success;
{code}Note that $modx is not available here; you&#39;re actually running these scripts from within the transport object. The $modx object is available as a different name, however: $object-&gt;xpdo. $object is the object that the resolver is attached to; here, it would be the modCategory.

Our script, then, is setting the values set in the setup-options to the newly installed system settings.

And now that we&#39;ve got everything packaged and ready to go, let&#39;s pack the package into a zip file and give us the time it took to build the package:
{code}$builder-&gt;pack();

$mtime= microtime();
$mtime= explode(&quot; &quot;, $mtime);
$mtime= $mtime[1] + $mtime[0];
$tend= $mtime;
$totalTime= ($tend - $tstart);
$totalTime= sprintf(&quot;%2.4f s&quot;, $totalTime);

$modx-&gt;log(modX::LOG_LEVEL_INFO,&quot;\nPackage Built.\nExecution time: {$totalTime}\n&quot;);
exit();
{code}Great, we&#39;re done\! You&#39;ll only need to run this script now, and viola\! A fully zipped transport package file will appear in your core/packages directory.

[View the Source|http://modxcms.com/assets/tutorials/3pc/build.transport.phps]

h2. Related Pages

* [Package Management]
* [Transport Packages]
* [Transport Providers|Providers]

{scrollbar}";}}}